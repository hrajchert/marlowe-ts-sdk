import { c as commonjsGlobal, g as getAugmentedNamespace, a as hexToUTF8_1 } from './index-a07fe7cc.js';
import require$$0$5 from 'url';
import require$$0$4 from 'events';
import require$$1 from 'util';
import require$$0$2 from 'stream';
import require$$2$2 from 'fs';
import require$$4 from 'http';
import require$$1$3 from 'https';
import require$$0$1 from 'dns';
import require$$2$1 from 'os';
import require$$0$3 from 'buffer';
import require$$1$1 from 'zlib';
import require$$0$6 from 'http2';
import require$$1$2 from 'tls';
import require$$0$7 from 'net';
import require$$0$8 from 'crypto';
import require$$1$4 from 'path';
import { toUnit, fromText, C, Lucid, Blockfrost, fromUnit, getAddressDetails, fromHex, toHex as toHex$2 } from 'lucid-cardano';
import { unsafeTaskEither } from '@marlowe.io/adapter/fp-ts';
import { unAddressBech32, unPolicyId, addressBech32, lovelaces, token, assetId, mkPolicyId } from '@marlowe.io/runtime-core';

var lib$1 = {};

var BlockFrostAPI$1 = {};

var config = {};

Object.defineProperty(config, "__esModule", { value: true });
config.ADDRESS_GAP_LIMIT = config.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT = config.DEFAULT_PAGINATION_PAGE_COUNT = config.DEFAULT_ORDER = config.DEFAULT_BATCH_SIZE = config.DEFAULT_API_VERSION = config.API_URLS = void 0;
config.API_URLS = {
    mainnet: 'https://cardano-mainnet.blockfrost.io/api',
    testnet: 'https://cardano-testnet.blockfrost.io/api',
    preview: 'https://cardano-preview.blockfrost.io/api',
    preprod: 'https://cardano-preprod.blockfrost.io/api',
    ipfs: 'https://ipfs.blockfrost.io/api',
};
config.DEFAULT_API_VERSION = 0;
config.DEFAULT_BATCH_SIZE = 10;
config.DEFAULT_ORDER = 'asc';
config.DEFAULT_PAGINATION_PAGE_COUNT = 1;
config.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT = 100;
config.ADDRESS_GAP_LIMIT = 20;

var accounts$1 = {};

var utils = {};

var limiter = {};

var parser$3 = {};

parser$3.load = function (received, defaults, onto = {}) {
  var k, ref, v;

  for (k in defaults) {
    v = defaults[k];
    onto[k] = (ref = received[k]) != null ? ref : v;
  }

  return onto;
};

parser$3.overwrite = function (received, defaults, onto = {}) {
  var k, v;

  for (k in received) {
    v = received[k];

    if (defaults[k] !== void 0) {
      onto[k] = v;
    }
  }

  return onto;
};

var DLList$2;
DLList$2 = class DLList {
  constructor(incr, decr) {
    this.incr = incr;
    this.decr = decr;
    this._first = null;
    this._last = null;
    this.length = 0;
  }

  push(value) {
    var node;
    this.length++;

    if (typeof this.incr === "function") {
      this.incr();
    }

    node = {
      value,
      prev: this._last,
      next: null
    };

    if (this._last != null) {
      this._last.next = node;
      this._last = node;
    } else {
      this._first = this._last = node;
    }

    return void 0;
  }

  shift() {
    var value;

    if (this._first == null) {
      return;
    } else {
      this.length--;

      if (typeof this.decr === "function") {
        this.decr();
      }
    }

    value = this._first.value;

    if ((this._first = this._first.next) != null) {
      this._first.prev = null;
    } else {
      this._last = null;
    }

    return value;
  }

  first() {
    if (this._first != null) {
      return this._first.value;
    }
  }

  getArray() {
    var node, ref, results;
    node = this._first;
    results = [];

    while (node != null) {
      results.push((ref = node, node = node.next, ref.value));
    }

    return results;
  }

  forEachShift(cb) {
    var node;
    node = this.shift();

    while (node != null) {
      cb(node), node = this.shift();
    }

    return void 0;
  }

  debug() {
    var node, ref, ref1, ref2, results;
    node = this._first;
    results = [];

    while (node != null) {
      results.push((ref = node, node = node.next, {
        value: ref.value,
        prev: (ref1 = ref.prev) != null ? ref1.value : void 0,
        next: (ref2 = ref.next) != null ? ref2.value : void 0
      }));
    }

    return results;
  }

};
var DLList_1 = DLList$2;

function asyncGeneratorStep$4(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator$4(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep$4(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep$4(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var Events$1;
Events$1 = class Events {
  constructor(instance) {
    this.instance = instance;
    this._events = {};

    if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {
      throw new Error("An Emitter already exists for this object");
    }

    this.instance.on = (name, cb) => {
      return this._addListener(name, "many", cb);
    };

    this.instance.once = (name, cb) => {
      return this._addListener(name, "once", cb);
    };

    this.instance.removeAllListeners = (name = null) => {
      if (name != null) {
        return delete this._events[name];
      } else {
        return this._events = {};
      }
    };
  }

  _addListener(name, status, cb) {
    var base;

    if ((base = this._events)[name] == null) {
      base[name] = [];
    }

    this._events[name].push({
      cb,
      status
    });

    return this.instance;
  }

  listenerCount(name) {
    if (this._events[name] != null) {
      return this._events[name].length;
    } else {
      return 0;
    }
  }

  trigger(name, ...args) {
    var _this = this;

    return _asyncToGenerator$4(function* () {
      var e, promises;

      try {
        if (name !== "debug") {
          _this.trigger("debug", `Event triggered: ${name}`, args);
        }

        if (_this._events[name] == null) {
          return;
        }

        _this._events[name] = _this._events[name].filter(function (listener) {
          return listener.status !== "none";
        });
        promises = _this._events[name].map(
        /*#__PURE__*/
        function () {
          var _ref = _asyncToGenerator$4(function* (listener) {
            var e, returned;

            if (listener.status === "none") {
              return;
            }

            if (listener.status === "once") {
              listener.status = "none";
            }

            try {
              returned = typeof listener.cb === "function" ? listener.cb(...args) : void 0;

              if (typeof (returned != null ? returned.then : void 0) === "function") {
                return yield returned;
              } else {
                return returned;
              }
            } catch (error) {
              e = error;

              if ("name" !== "error") {
                _this.trigger("error", e);
              }

              return null;
            }
          });

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }());
        return (yield Promise.all(promises)).find(function (x) {
          return x != null;
        });
      } catch (error) {
        e = error;

        {
          _this.trigger("error", e);
        }

        return null;
      }
    })();
  }

};
var Events_1 = Events$1;

var DLList$1, Events, Queues;
DLList$1 = DLList_1;
Events = Events_1;
Queues = class Queues {
  constructor(num_priorities) {
    this.Events = new Events(this);
    this._length = 0;

    this._lists = function () {
      var j, ref, results;
      results = [];

      for (j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? ++j : --j) {
        results.push(new DLList$1(() => {
          return this.incr();
        }, () => {
          return this.decr();
        }));
      }

      return results;
    }.call(this);
  }

  incr() {
    if (this._length++ === 0) {
      return this.Events.trigger("leftzero");
    }
  }

  decr() {
    if (--this._length === 0) {
      return this.Events.trigger("zero");
    }
  }

  push(job) {
    return this._lists[job.options.priority].push(job);
  }

  queued(priority) {
    if (priority != null) {
      return this._lists[priority].length;
    } else {
      return this._length;
    }
  }

  shiftAll(fn) {
    return this._lists.forEach(function (list) {
      return list.forEachShift(fn);
    });
  }

  getFirst(arr = this._lists) {
    var j, len, list;

    for (j = 0, len = arr.length; j < len; j++) {
      list = arr[j];

      if (list.length > 0) {
        return list;
      }
    }

    return [];
  }

  shiftLastFrom(priority) {
    return this.getFirst(this._lists.slice(priority).reverse()).shift();
  }

};
var Queues_1 = Queues;

var BottleneckError_1;
var hasRequiredBottleneckError;

function requireBottleneckError () {
	if (hasRequiredBottleneckError) return BottleneckError_1;
	hasRequiredBottleneckError = 1;

	var BottleneckError;
	BottleneckError = class BottleneckError extends Error {};
	BottleneckError_1 = BottleneckError;
	return BottleneckError_1;
}

function asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator$3(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var BottleneckError$3, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$2;
NUM_PRIORITIES = 10;
DEFAULT_PRIORITY = 5;
parser$2 = parser$3;
BottleneckError$3 = requireBottleneckError();
Job = class Job {
  constructor(task, args, options, jobDefaults, rejectOnDrop, Events, _states, Promise) {
    this.task = task;
    this.args = args;
    this.rejectOnDrop = rejectOnDrop;
    this.Events = Events;
    this._states = _states;
    this.Promise = Promise;
    this.options = parser$2.load(options, jobDefaults);
    this.options.priority = this._sanitizePriority(this.options.priority);

    if (this.options.id === jobDefaults.id) {
      this.options.id = `${this.options.id}-${this._randomIndex()}`;
    }

    this.promise = new this.Promise((_resolve, _reject) => {
      this._resolve = _resolve;
      this._reject = _reject;
    });
    this.retryCount = 0;
  }

  _sanitizePriority(priority) {
    var sProperty;
    sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;

    if (sProperty < 0) {
      return 0;
    } else if (sProperty > NUM_PRIORITIES - 1) {
      return NUM_PRIORITIES - 1;
    } else {
      return sProperty;
    }
  }

  _randomIndex() {
    return Math.random().toString(36).slice(2);
  }

  doDrop({
    error,
    message = "This job has been dropped by Bottleneck"
  } = {}) {
    if (this._states.remove(this.options.id)) {
      if (this.rejectOnDrop) {
        this._reject(error != null ? error : new BottleneckError$3(message));
      }

      this.Events.trigger("dropped", {
        args: this.args,
        options: this.options,
        task: this.task,
        promise: this.promise
      });
      return true;
    } else {
      return false;
    }
  }

  _assertStatus(expected) {
    var status;
    status = this._states.jobStatus(this.options.id);

    if (!(status === expected || expected === "DONE" && status === null)) {
      throw new BottleneckError$3(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
    }
  }

  doReceive() {
    this._states.start(this.options.id);

    return this.Events.trigger("received", {
      args: this.args,
      options: this.options
    });
  }

  doQueue(reachedHWM, blocked) {
    this._assertStatus("RECEIVED");

    this._states.next(this.options.id);

    return this.Events.trigger("queued", {
      args: this.args,
      options: this.options,
      reachedHWM,
      blocked
    });
  }

  doRun() {
    if (this.retryCount === 0) {
      this._assertStatus("QUEUED");

      this._states.next(this.options.id);
    } else {
      this._assertStatus("EXECUTING");
    }

    return this.Events.trigger("scheduled", {
      args: this.args,
      options: this.options
    });
  }

  doExecute(chained, clearGlobalState, run, free) {
    var _this = this;

    return _asyncToGenerator$3(function* () {
      var error, eventInfo, passed;

      if (_this.retryCount === 0) {
        _this._assertStatus("RUNNING");

        _this._states.next(_this.options.id);
      } else {
        _this._assertStatus("EXECUTING");
      }

      eventInfo = {
        args: _this.args,
        options: _this.options,
        retryCount: _this.retryCount
      };

      _this.Events.trigger("executing", eventInfo);

      try {
        passed = yield chained != null ? chained.schedule(_this.options, _this.task, ..._this.args) : _this.task(..._this.args);

        if (clearGlobalState()) {
          _this.doDone(eventInfo);

          yield free(_this.options, eventInfo);

          _this._assertStatus("DONE");

          return _this._resolve(passed);
        }
      } catch (error1) {
        error = error1;
        return _this._onFailure(error, eventInfo, clearGlobalState, run, free);
      }
    })();
  }

  doExpire(clearGlobalState, run, free) {
    var error, eventInfo;

    if (this._states.jobStatus(this.options.id === "RUNNING")) {
      this._states.next(this.options.id);
    }

    this._assertStatus("EXECUTING");

    eventInfo = {
      args: this.args,
      options: this.options,
      retryCount: this.retryCount
    };
    error = new BottleneckError$3(`This job timed out after ${this.options.expiration} ms.`);
    return this._onFailure(error, eventInfo, clearGlobalState, run, free);
  }

  _onFailure(error, eventInfo, clearGlobalState, run, free) {
    var _this2 = this;

    return _asyncToGenerator$3(function* () {
      var retry, retryAfter;

      if (clearGlobalState()) {
        retry = yield _this2.Events.trigger("failed", error, eventInfo);

        if (retry != null) {
          retryAfter = ~~retry;

          _this2.Events.trigger("retry", `Retrying ${_this2.options.id} after ${retryAfter} ms`, eventInfo);

          _this2.retryCount++;
          return run(retryAfter);
        } else {
          _this2.doDone(eventInfo);

          yield free(_this2.options, eventInfo);

          _this2._assertStatus("DONE");

          return _this2._reject(error);
        }
      }
    })();
  }

  doDone(eventInfo) {
    this._assertStatus("EXECUTING");

    this._states.next(this.options.id);

    return this.Events.trigger("done", eventInfo);
  }

};
var Job_1 = Job;

function asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator$2(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var BottleneckError$2, LocalDatastore, parser$1;
parser$1 = parser$3;
BottleneckError$2 = requireBottleneckError();
LocalDatastore = class LocalDatastore {
  constructor(instance, storeOptions, storeInstanceOptions) {
    this.instance = instance;
    this.storeOptions = storeOptions;
    this.clientId = this.instance._randomIndex();
    parser$1.load(storeInstanceOptions, storeInstanceOptions, this);
    this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();
    this._running = 0;
    this._done = 0;
    this._unblockTime = 0;
    this.ready = this.Promise.resolve();
    this.clients = {};

    this._startHeartbeat();
  }

  _startHeartbeat() {
    var base;

    if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {
      return typeof (base = this.heartbeat = setInterval(() => {
        var amount, incr, maximum, now, reservoir;
        now = Date.now();

        if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {
          this._lastReservoirRefresh = now;
          this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;

          this.instance._drainAll(this.computeCapacity());
        }

        if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
          var _this$storeOptions = this.storeOptions;
          amount = _this$storeOptions.reservoirIncreaseAmount;
          maximum = _this$storeOptions.reservoirIncreaseMaximum;
          reservoir = _this$storeOptions.reservoir;
          this._lastReservoirIncrease = now;
          incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;

          if (incr > 0) {
            this.storeOptions.reservoir += incr;
            return this.instance._drainAll(this.computeCapacity());
          }
        }
      }, this.heartbeatInterval)).unref === "function" ? base.unref() : void 0;
    } else {
      return clearInterval(this.heartbeat);
    }
  }

  __publish__(message) {
    var _this = this;

    return _asyncToGenerator$2(function* () {
      yield _this.yieldLoop();
      return _this.instance.Events.trigger("message", message.toString());
    })();
  }

  __disconnect__(flush) {
    var _this2 = this;

    return _asyncToGenerator$2(function* () {
      yield _this2.yieldLoop();
      clearInterval(_this2.heartbeat);
      return _this2.Promise.resolve();
    })();
  }

  yieldLoop(t = 0) {
    return new this.Promise(function (resolve, reject) {
      return setTimeout(resolve, t);
    });
  }

  computePenalty() {
    var ref;
    return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;
  }

  __updateSettings__(options) {
    var _this3 = this;

    return _asyncToGenerator$2(function* () {
      yield _this3.yieldLoop();
      parser$1.overwrite(options, options, _this3.storeOptions);

      _this3._startHeartbeat();

      _this3.instance._drainAll(_this3.computeCapacity());

      return true;
    })();
  }

  __running__() {
    var _this4 = this;

    return _asyncToGenerator$2(function* () {
      yield _this4.yieldLoop();
      return _this4._running;
    })();
  }

  __queued__() {
    var _this5 = this;

    return _asyncToGenerator$2(function* () {
      yield _this5.yieldLoop();
      return _this5.instance.queued();
    })();
  }

  __done__() {
    var _this6 = this;

    return _asyncToGenerator$2(function* () {
      yield _this6.yieldLoop();
      return _this6._done;
    })();
  }

  __groupCheck__(time) {
    var _this7 = this;

    return _asyncToGenerator$2(function* () {
      yield _this7.yieldLoop();
      return _this7._nextRequest + _this7.timeout < time;
    })();
  }

  computeCapacity() {
    var maxConcurrent, reservoir;
    var _this$storeOptions2 = this.storeOptions;
    maxConcurrent = _this$storeOptions2.maxConcurrent;
    reservoir = _this$storeOptions2.reservoir;

    if (maxConcurrent != null && reservoir != null) {
      return Math.min(maxConcurrent - this._running, reservoir);
    } else if (maxConcurrent != null) {
      return maxConcurrent - this._running;
    } else if (reservoir != null) {
      return reservoir;
    } else {
      return null;
    }
  }

  conditionsCheck(weight) {
    var capacity;
    capacity = this.computeCapacity();
    return capacity == null || weight <= capacity;
  }

  __incrementReservoir__(incr) {
    var _this8 = this;

    return _asyncToGenerator$2(function* () {
      var reservoir;
      yield _this8.yieldLoop();
      reservoir = _this8.storeOptions.reservoir += incr;

      _this8.instance._drainAll(_this8.computeCapacity());

      return reservoir;
    })();
  }

  __currentReservoir__() {
    var _this9 = this;

    return _asyncToGenerator$2(function* () {
      yield _this9.yieldLoop();
      return _this9.storeOptions.reservoir;
    })();
  }

  isBlocked(now) {
    return this._unblockTime >= now;
  }

  check(weight, now) {
    return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
  }

  __check__(weight) {
    var _this10 = this;

    return _asyncToGenerator$2(function* () {
      var now;
      yield _this10.yieldLoop();
      now = Date.now();
      return _this10.check(weight, now);
    })();
  }

  __register__(index, weight, expiration) {
    var _this11 = this;

    return _asyncToGenerator$2(function* () {
      var now, wait;
      yield _this11.yieldLoop();
      now = Date.now();

      if (_this11.conditionsCheck(weight)) {
        _this11._running += weight;

        if (_this11.storeOptions.reservoir != null) {
          _this11.storeOptions.reservoir -= weight;
        }

        wait = Math.max(_this11._nextRequest - now, 0);
        _this11._nextRequest = now + wait + _this11.storeOptions.minTime;
        return {
          success: true,
          wait,
          reservoir: _this11.storeOptions.reservoir
        };
      } else {
        return {
          success: false
        };
      }
    })();
  }

  strategyIsBlock() {
    return this.storeOptions.strategy === 3;
  }

  __submit__(queueLength, weight) {
    var _this12 = this;

    return _asyncToGenerator$2(function* () {
      var blocked, now, reachedHWM;
      yield _this12.yieldLoop();

      if (_this12.storeOptions.maxConcurrent != null && weight > _this12.storeOptions.maxConcurrent) {
        throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${_this12.storeOptions.maxConcurrent}`);
      }

      now = Date.now();
      reachedHWM = _this12.storeOptions.highWater != null && queueLength === _this12.storeOptions.highWater && !_this12.check(weight, now);
      blocked = _this12.strategyIsBlock() && (reachedHWM || _this12.isBlocked(now));

      if (blocked) {
        _this12._unblockTime = now + _this12.computePenalty();
        _this12._nextRequest = _this12._unblockTime + _this12.storeOptions.minTime;

        _this12.instance._dropAllQueued();
      }

      return {
        reachedHWM,
        blocked,
        strategy: _this12.storeOptions.strategy
      };
    })();
  }

  __free__(index, weight) {
    var _this13 = this;

    return _asyncToGenerator$2(function* () {
      yield _this13.yieldLoop();
      _this13._running -= weight;
      _this13._done += weight;

      _this13.instance._drainAll(_this13.computeCapacity());

      return {
        running: _this13._running
      };
    })();
  }

};
var LocalDatastore_1 = LocalDatastore;

var Scripts = {};

var require$$0 = {
	"blacklist_client.lua": "local blacklist = ARGV[num_static_argv + 1]\n\nif redis.call('zscore', client_last_seen_key, blacklist) then\n  redis.call('zadd', client_last_seen_key, 0, blacklist)\nend\n\n\nreturn {}\n",
	"check.lua": "local weight = tonumber(ARGV[num_static_argv + 1])\n\nlocal capacity = process_tick(now, false)['capacity']\nlocal nextRequest = tonumber(redis.call('hget', settings_key, 'nextRequest'))\n\nreturn conditions_check(capacity, weight) and nextRequest - now <= 0\n",
	"conditions_check.lua": "local conditions_check = function (capacity, weight)\n  return capacity == nil or weight <= capacity\nend\n",
	"current_reservoir.lua": "return process_tick(now, false)['reservoir']\n",
	"done.lua": "process_tick(now, false)\n\nreturn tonumber(redis.call('hget', settings_key, 'done'))\n",
	"free.lua": "local index = ARGV[num_static_argv + 1]\n\nredis.call('zadd', job_expirations_key, 0, index)\n\nreturn process_tick(now, false)['running']\n",
	"get_time.lua": "redis.replicate_commands()\n\nlocal get_time = function ()\n  local time = redis.call('time')\n\n  return tonumber(time[1]..string.sub(time[2], 1, 3))\nend\n",
	"group_check.lua": "return not (redis.call('exists', settings_key) == 1)\n",
	"heartbeat.lua": "process_tick(now, true)\n",
	"increment_reservoir.lua": "local incr = tonumber(ARGV[num_static_argv + 1])\n\nredis.call('hincrby', settings_key, 'reservoir', incr)\n\nlocal reservoir = process_tick(now, true)['reservoir']\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn reservoir\n",
	"init.lua": "local clear = tonumber(ARGV[num_static_argv + 1])\nlocal limiter_version = ARGV[num_static_argv + 2]\nlocal num_local_argv = num_static_argv + 2\n\nif clear == 1 then\n  redis.call('del', unpack(KEYS))\nend\n\nif redis.call('exists', settings_key) == 0 then\n  -- Create\n  local args = {'hmset', settings_key}\n\n  for i = num_local_argv + 1, #ARGV do\n    table.insert(args, ARGV[i])\n  end\n\n  redis.call(unpack(args))\n  redis.call('hmset', settings_key,\n    'nextRequest', now,\n    'lastReservoirRefresh', now,\n    'lastReservoirIncrease', now,\n    'running', 0,\n    'done', 0,\n    'unblockTime', 0,\n    'capacityPriorityCounter', 0\n  )\n\nelse\n  -- Apply migrations\n  local settings = redis.call('hmget', settings_key,\n    'id',\n    'version'\n  )\n  local id = settings[1]\n  local current_version = settings[2]\n\n  if current_version ~= limiter_version then\n    local version_digits = {}\n    for k, v in string.gmatch(current_version, \"([^.]+)\") do\n      table.insert(version_digits, tonumber(k))\n    end\n\n    -- 2.10.0\n    if version_digits[2] < 10 then\n      redis.call('hsetnx', settings_key, 'reservoirRefreshInterval', '')\n      redis.call('hsetnx', settings_key, 'reservoirRefreshAmount', '')\n      redis.call('hsetnx', settings_key, 'lastReservoirRefresh', '')\n      redis.call('hsetnx', settings_key, 'done', 0)\n      redis.call('hset', settings_key, 'version', '2.10.0')\n    end\n\n    -- 2.11.1\n    if version_digits[2] < 11 or (version_digits[2] == 11 and version_digits[3] < 1) then\n      if redis.call('hstrlen', settings_key, 'lastReservoirRefresh') == 0 then\n        redis.call('hmset', settings_key,\n          'lastReservoirRefresh', now,\n          'version', '2.11.1'\n        )\n      end\n    end\n\n    -- 2.14.0\n    if version_digits[2] < 14 then\n      local old_running_key = 'b_'..id..'_running'\n      local old_executing_key = 'b_'..id..'_executing'\n\n      if redis.call('exists', old_running_key) == 1 then\n        redis.call('rename', old_running_key, job_weights_key)\n      end\n      if redis.call('exists', old_executing_key) == 1 then\n        redis.call('rename', old_executing_key, job_expirations_key)\n      end\n      redis.call('hset', settings_key, 'version', '2.14.0')\n    end\n\n    -- 2.15.2\n    if version_digits[2] < 15 or (version_digits[2] == 15 and version_digits[3] < 2) then\n      redis.call('hsetnx', settings_key, 'capacityPriorityCounter', 0)\n      redis.call('hset', settings_key, 'version', '2.15.2')\n    end\n\n    -- 2.17.0\n    if version_digits[2] < 17 then\n      redis.call('hsetnx', settings_key, 'clientTimeout', 10000)\n      redis.call('hset', settings_key, 'version', '2.17.0')\n    end\n\n    -- 2.18.0\n    if version_digits[2] < 18 then\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseInterval', '')\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseAmount', '')\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseMaximum', '')\n      redis.call('hsetnx', settings_key, 'lastReservoirIncrease', now)\n      redis.call('hset', settings_key, 'version', '2.18.0')\n    end\n\n  end\n\n  process_tick(now, false)\nend\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn {}\n",
	"process_tick.lua": "local process_tick = function (now, always_publish)\n\n  local compute_capacity = function (maxConcurrent, running, reservoir)\n    if maxConcurrent ~= nil and reservoir ~= nil then\n      return math.min((maxConcurrent - running), reservoir)\n    elseif maxConcurrent ~= nil then\n      return maxConcurrent - running\n    elseif reservoir ~= nil then\n      return reservoir\n    else\n      return nil\n    end\n  end\n\n  local settings = redis.call('hmget', settings_key,\n    'id',\n    'maxConcurrent',\n    'running',\n    'reservoir',\n    'reservoirRefreshInterval',\n    'reservoirRefreshAmount',\n    'lastReservoirRefresh',\n    'reservoirIncreaseInterval',\n    'reservoirIncreaseAmount',\n    'reservoirIncreaseMaximum',\n    'lastReservoirIncrease',\n    'capacityPriorityCounter',\n    'clientTimeout'\n  )\n  local id = settings[1]\n  local maxConcurrent = tonumber(settings[2])\n  local running = tonumber(settings[3])\n  local reservoir = tonumber(settings[4])\n  local reservoirRefreshInterval = tonumber(settings[5])\n  local reservoirRefreshAmount = tonumber(settings[6])\n  local lastReservoirRefresh = tonumber(settings[7])\n  local reservoirIncreaseInterval = tonumber(settings[8])\n  local reservoirIncreaseAmount = tonumber(settings[9])\n  local reservoirIncreaseMaximum = tonumber(settings[10])\n  local lastReservoirIncrease = tonumber(settings[11])\n  local capacityPriorityCounter = tonumber(settings[12])\n  local clientTimeout = tonumber(settings[13])\n\n  local initial_capacity = compute_capacity(maxConcurrent, running, reservoir)\n\n  --\n  -- Process 'running' changes\n  --\n  local expired = redis.call('zrangebyscore', job_expirations_key, '-inf', '('..now)\n\n  if #expired > 0 then\n    redis.call('zremrangebyscore', job_expirations_key, '-inf', '('..now)\n\n    local flush_batch = function (batch, acc)\n      local weights = redis.call('hmget', job_weights_key, unpack(batch))\n                      redis.call('hdel',  job_weights_key, unpack(batch))\n      local clients = redis.call('hmget', job_clients_key, unpack(batch))\n                      redis.call('hdel',  job_clients_key, unpack(batch))\n\n      -- Calculate sum of removed weights\n      for i = 1, #weights do\n        acc['total'] = acc['total'] + (tonumber(weights[i]) or 0)\n      end\n\n      -- Calculate sum of removed weights by client\n      local client_weights = {}\n      for i = 1, #clients do\n        local removed = tonumber(weights[i]) or 0\n        if removed > 0 then\n          acc['client_weights'][clients[i]] = (acc['client_weights'][clients[i]] or 0) + removed\n        end\n      end\n    end\n\n    local acc = {\n      ['total'] = 0,\n      ['client_weights'] = {}\n    }\n    local batch_size = 1000\n\n    -- Compute changes to Zsets and apply changes to Hashes\n    for i = 1, #expired, batch_size do\n      local batch = {}\n      for j = i, math.min(i + batch_size - 1, #expired) do\n        table.insert(batch, expired[j])\n      end\n\n      flush_batch(batch, acc)\n    end\n\n    -- Apply changes to Zsets\n    if acc['total'] > 0 then\n      redis.call('hincrby', settings_key, 'done', acc['total'])\n      running = tonumber(redis.call('hincrby', settings_key, 'running', -acc['total']))\n    end\n\n    for client, weight in pairs(acc['client_weights']) do\n      redis.call('zincrby', client_running_key, -weight, client)\n    end\n  end\n\n  --\n  -- Process 'reservoir' changes\n  --\n  local reservoirRefreshActive = reservoirRefreshInterval ~= nil and reservoirRefreshAmount ~= nil\n  if reservoirRefreshActive and now >= lastReservoirRefresh + reservoirRefreshInterval then\n    reservoir = reservoirRefreshAmount\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'lastReservoirRefresh', now\n    )\n  end\n\n  local reservoirIncreaseActive = reservoirIncreaseInterval ~= nil and reservoirIncreaseAmount ~= nil\n  if reservoirIncreaseActive and now >= lastReservoirIncrease + reservoirIncreaseInterval then\n    local num_intervals = math.floor((now - lastReservoirIncrease) / reservoirIncreaseInterval)\n    local incr = reservoirIncreaseAmount * num_intervals\n    if reservoirIncreaseMaximum ~= nil then\n      incr = math.min(incr, reservoirIncreaseMaximum - (reservoir or 0))\n    end\n    if incr > 0 then\n      reservoir = (reservoir or 0) + incr\n    end\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'lastReservoirIncrease', lastReservoirIncrease + (num_intervals * reservoirIncreaseInterval)\n    )\n  end\n\n  --\n  -- Clear unresponsive clients\n  --\n  local unresponsive = redis.call('zrangebyscore', client_last_seen_key, '-inf', (now - clientTimeout))\n  local unresponsive_lookup = {}\n  local terminated_clients = {}\n  for i = 1, #unresponsive do\n    unresponsive_lookup[unresponsive[i]] = true\n    if tonumber(redis.call('zscore', client_running_key, unresponsive[i])) == 0 then\n      table.insert(terminated_clients, unresponsive[i])\n    end\n  end\n  if #terminated_clients > 0 then\n    redis.call('zrem', client_running_key,         unpack(terminated_clients))\n    redis.call('hdel', client_num_queued_key,      unpack(terminated_clients))\n    redis.call('zrem', client_last_registered_key, unpack(terminated_clients))\n    redis.call('zrem', client_last_seen_key,       unpack(terminated_clients))\n  end\n\n  --\n  -- Broadcast capacity changes\n  --\n  local final_capacity = compute_capacity(maxConcurrent, running, reservoir)\n\n  if always_publish or (initial_capacity ~= nil and final_capacity == nil) then\n    -- always_publish or was not unlimited, now unlimited\n    redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\n\n  elseif initial_capacity ~= nil and final_capacity ~= nil and final_capacity > initial_capacity then\n    -- capacity was increased\n    -- send the capacity message to the limiter having the lowest number of running jobs\n    -- the tiebreaker is the limiter having not registered a job in the longest time\n\n    local lowest_concurrency_value = nil\n    local lowest_concurrency_clients = {}\n    local lowest_concurrency_last_registered = {}\n    local client_concurrencies = redis.call('zrange', client_running_key, 0, -1, 'withscores')\n\n    for i = 1, #client_concurrencies, 2 do\n      local client = client_concurrencies[i]\n      local concurrency = tonumber(client_concurrencies[i+1])\n\n      if (\n        lowest_concurrency_value == nil or lowest_concurrency_value == concurrency\n      ) and (\n        not unresponsive_lookup[client]\n      ) and (\n        tonumber(redis.call('hget', client_num_queued_key, client)) > 0\n      ) then\n        lowest_concurrency_value = concurrency\n        table.insert(lowest_concurrency_clients, client)\n        local last_registered = tonumber(redis.call('zscore', client_last_registered_key, client))\n        table.insert(lowest_concurrency_last_registered, last_registered)\n      end\n    end\n\n    if #lowest_concurrency_clients > 0 then\n      local position = 1\n      local earliest = lowest_concurrency_last_registered[1]\n\n      for i,v in ipairs(lowest_concurrency_last_registered) do\n        if v < earliest then\n          position = i\n          earliest = v\n        end\n      end\n\n      local next_client = lowest_concurrency_clients[position]\n      redis.call('publish', 'b_'..id,\n        'capacity-priority:'..(final_capacity or '')..\n        ':'..next_client..\n        ':'..capacityPriorityCounter\n      )\n      redis.call('hincrby', settings_key, 'capacityPriorityCounter', '1')\n    else\n      redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\n    end\n  end\n\n  return {\n    ['capacity'] = final_capacity,\n    ['running'] = running,\n    ['reservoir'] = reservoir\n  }\nend\n",
	"queued.lua": "local clientTimeout = tonumber(redis.call('hget', settings_key, 'clientTimeout'))\nlocal valid_clients = redis.call('zrangebyscore', client_last_seen_key, (now - clientTimeout), 'inf')\nlocal client_queued = redis.call('hmget', client_num_queued_key, unpack(valid_clients))\n\nlocal sum = 0\nfor i = 1, #client_queued do\n  sum = sum + tonumber(client_queued[i])\nend\n\nreturn sum\n",
	"refresh_expiration.lua": "local refresh_expiration = function (now, nextRequest, groupTimeout)\n\n  if groupTimeout ~= nil then\n    local ttl = (nextRequest + groupTimeout) - now\n\n    for i = 1, #KEYS do\n      redis.call('pexpire', KEYS[i], ttl)\n    end\n  end\n\nend\n",
	"refs.lua": "local settings_key = KEYS[1]\nlocal job_weights_key = KEYS[2]\nlocal job_expirations_key = KEYS[3]\nlocal job_clients_key = KEYS[4]\nlocal client_running_key = KEYS[5]\nlocal client_num_queued_key = KEYS[6]\nlocal client_last_registered_key = KEYS[7]\nlocal client_last_seen_key = KEYS[8]\n\nlocal now = tonumber(ARGV[1])\nlocal client = ARGV[2]\n\nlocal num_static_argv = 2\n",
	"register.lua": "local index = ARGV[num_static_argv + 1]\nlocal weight = tonumber(ARGV[num_static_argv + 2])\nlocal expiration = tonumber(ARGV[num_static_argv + 3])\n\nlocal state = process_tick(now, false)\nlocal capacity = state['capacity']\nlocal reservoir = state['reservoir']\n\nlocal settings = redis.call('hmget', settings_key,\n  'nextRequest',\n  'minTime',\n  'groupTimeout'\n)\nlocal nextRequest = tonumber(settings[1])\nlocal minTime = tonumber(settings[2])\nlocal groupTimeout = tonumber(settings[3])\n\nif conditions_check(capacity, weight) then\n\n  redis.call('hincrby', settings_key, 'running', weight)\n  redis.call('hset', job_weights_key, index, weight)\n  if expiration ~= nil then\n    redis.call('zadd', job_expirations_key, now + expiration, index)\n  end\n  redis.call('hset', job_clients_key, index, client)\n  redis.call('zincrby', client_running_key, weight, client)\n  redis.call('hincrby', client_num_queued_key, client, -1)\n  redis.call('zadd', client_last_registered_key, now, client)\n\n  local wait = math.max(nextRequest - now, 0)\n  local newNextRequest = now + wait + minTime\n\n  if reservoir == nil then\n    redis.call('hset', settings_key,\n      'nextRequest', newNextRequest\n    )\n  else\n    reservoir = reservoir - weight\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'nextRequest', newNextRequest\n    )\n  end\n\n  refresh_expiration(now, newNextRequest, groupTimeout)\n\n  return {true, wait, reservoir}\n\nelse\n  return {false}\nend\n",
	"register_client.lua": "local queued = tonumber(ARGV[num_static_argv + 1])\n\n-- Could have been re-registered concurrently\nif not redis.call('zscore', client_last_seen_key, client) then\n  redis.call('zadd', client_running_key, 0, client)\n  redis.call('hset', client_num_queued_key, client, queued)\n  redis.call('zadd', client_last_registered_key, 0, client)\nend\n\nredis.call('zadd', client_last_seen_key, now, client)\n\nreturn {}\n",
	"running.lua": "return process_tick(now, false)['running']\n",
	"submit.lua": "local queueLength = tonumber(ARGV[num_static_argv + 1])\nlocal weight = tonumber(ARGV[num_static_argv + 2])\n\nlocal capacity = process_tick(now, false)['capacity']\n\nlocal settings = redis.call('hmget', settings_key,\n  'id',\n  'maxConcurrent',\n  'highWater',\n  'nextRequest',\n  'strategy',\n  'unblockTime',\n  'penalty',\n  'minTime',\n  'groupTimeout'\n)\nlocal id = settings[1]\nlocal maxConcurrent = tonumber(settings[2])\nlocal highWater = tonumber(settings[3])\nlocal nextRequest = tonumber(settings[4])\nlocal strategy = tonumber(settings[5])\nlocal unblockTime = tonumber(settings[6])\nlocal penalty = tonumber(settings[7])\nlocal minTime = tonumber(settings[8])\nlocal groupTimeout = tonumber(settings[9])\n\nif maxConcurrent ~= nil and weight > maxConcurrent then\n  return redis.error_reply('OVERWEIGHT:'..weight..':'..maxConcurrent)\nend\n\nlocal reachedHWM = (highWater ~= nil and queueLength == highWater\n  and not (\n    conditions_check(capacity, weight)\n    and nextRequest - now <= 0\n  )\n)\n\nlocal blocked = strategy == 3 and (reachedHWM or unblockTime >= now)\n\nif blocked then\n  local computedPenalty = penalty\n  if computedPenalty == nil then\n    if minTime == 0 then\n      computedPenalty = 5000\n    else\n      computedPenalty = 15 * minTime\n    end\n  end\n\n  local newNextRequest = now + computedPenalty + minTime\n\n  redis.call('hmset', settings_key,\n    'unblockTime', now + computedPenalty,\n    'nextRequest', newNextRequest\n  )\n\n  local clients_queued_reset = redis.call('hkeys', client_num_queued_key)\n  local queued_reset = {}\n  for i = 1, #clients_queued_reset do\n    table.insert(queued_reset, clients_queued_reset[i])\n    table.insert(queued_reset, 0)\n  end\n  redis.call('hmset', client_num_queued_key, unpack(queued_reset))\n\n  redis.call('publish', 'b_'..id, 'blocked:')\n\n  refresh_expiration(now, newNextRequest, groupTimeout)\nend\n\nif not blocked and not reachedHWM then\n  redis.call('hincrby', client_num_queued_key, client, 1)\nend\n\nreturn {reachedHWM, blocked, strategy}\n",
	"update_settings.lua": "local args = {'hmset', settings_key}\n\nfor i = num_static_argv + 1, #ARGV do\n  table.insert(args, ARGV[i])\nend\n\nredis.call(unpack(args))\n\nprocess_tick(now, true)\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn {}\n",
	"validate_client.lua": "if not redis.call('zscore', client_last_seen_key, client) then\n  return redis.error_reply('UNKNOWN_CLIENT')\nend\n\nredis.call('zadd', client_last_seen_key, now, client)\n",
	"validate_keys.lua": "if not (redis.call('exists', settings_key) == 1) then\n  return redis.error_reply('SETTINGS_KEY_NOT_FOUND')\nend\n"
};

var hasRequiredScripts;

function requireScripts () {
	if (hasRequiredScripts) return Scripts;
	hasRequiredScripts = 1;
	(function (exports) {

		var headers, lua, templates;
		lua = require$$0;
		headers = {
		  refs: lua["refs.lua"],
		  validate_keys: lua["validate_keys.lua"],
		  validate_client: lua["validate_client.lua"],
		  refresh_expiration: lua["refresh_expiration.lua"],
		  process_tick: lua["process_tick.lua"],
		  conditions_check: lua["conditions_check.lua"],
		  get_time: lua["get_time.lua"]
		};

		exports.allKeys = function (id) {
		  return [
		  /*
		  HASH
		  */
		  `b_${id}_settings`,
		  /*
		  HASH
		  job index -> weight
		  */
		  `b_${id}_job_weights`,
		  /*
		  ZSET
		  job index -> expiration
		  */
		  `b_${id}_job_expirations`,
		  /*
		  HASH
		  job index -> client
		  */
		  `b_${id}_job_clients`,
		  /*
		  ZSET
		  client -> sum running
		  */
		  `b_${id}_client_running`,
		  /*
		  HASH
		  client -> num queued
		  */
		  `b_${id}_client_num_queued`,
		  /*
		  ZSET
		  client -> last job registered
		  */
		  `b_${id}_client_last_registered`,
		  /*
		  ZSET
		  client -> last seen
		  */
		  `b_${id}_client_last_seen`];
		};

		templates = {
		  init: {
		    keys: exports.allKeys,
		    headers: ["process_tick"],
		    refresh_expiration: true,
		    code: lua["init.lua"]
		  },
		  group_check: {
		    keys: exports.allKeys,
		    headers: [],
		    refresh_expiration: false,
		    code: lua["group_check.lua"]
		  },
		  register_client: {
		    keys: exports.allKeys,
		    headers: ["validate_keys"],
		    refresh_expiration: false,
		    code: lua["register_client.lua"]
		  },
		  blacklist_client: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client"],
		    refresh_expiration: false,
		    code: lua["blacklist_client.lua"]
		  },
		  heartbeat: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client", "process_tick"],
		    refresh_expiration: false,
		    code: lua["heartbeat.lua"]
		  },
		  update_settings: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client", "process_tick"],
		    refresh_expiration: true,
		    code: lua["update_settings.lua"]
		  },
		  running: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client", "process_tick"],
		    refresh_expiration: false,
		    code: lua["running.lua"]
		  },
		  queued: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client"],
		    refresh_expiration: false,
		    code: lua["queued.lua"]
		  },
		  done: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client", "process_tick"],
		    refresh_expiration: false,
		    code: lua["done.lua"]
		  },
		  check: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client", "process_tick", "conditions_check"],
		    refresh_expiration: false,
		    code: lua["check.lua"]
		  },
		  submit: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client", "process_tick", "conditions_check"],
		    refresh_expiration: true,
		    code: lua["submit.lua"]
		  },
		  register: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client", "process_tick", "conditions_check"],
		    refresh_expiration: true,
		    code: lua["register.lua"]
		  },
		  free: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client", "process_tick"],
		    refresh_expiration: true,
		    code: lua["free.lua"]
		  },
		  current_reservoir: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client", "process_tick"],
		    refresh_expiration: false,
		    code: lua["current_reservoir.lua"]
		  },
		  increment_reservoir: {
		    keys: exports.allKeys,
		    headers: ["validate_keys", "validate_client", "process_tick"],
		    refresh_expiration: true,
		    code: lua["increment_reservoir.lua"]
		  }
		};
		exports.names = Object.keys(templates);

		exports.keys = function (name, id) {
		  return templates[name].keys(id);
		};

		exports.payload = function (name) {
		  var template;
		  template = templates[name];
		  return Array.prototype.concat(headers.refs, template.headers.map(function (h) {
		    return headers[h];
		  }), template.refresh_expiration ? headers.refresh_expiration : "", template.code).join("\n");
		}; 
	} (Scripts));
	return Scripts;
}

var RedisConnection_1;
var hasRequiredRedisConnection;

function requireRedisConnection () {
	if (hasRequiredRedisConnection) return RedisConnection_1;
	hasRequiredRedisConnection = 1;

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	var Events, RedisConnection, Scripts, parser;
	parser = parser$3;
	Events = Events_1;
	Scripts = requireScripts();

	RedisConnection = function () {
	  class RedisConnection {
	    constructor(options = {}) {
	      parser.load(options, this.defaults, this);

	      if (this.Redis == null) {
	        this.Redis = eval("require")("redis"); // Obfuscated or else Webpack/Angular will try to inline the optional redis module. To override this behavior: pass the redis module to Bottleneck as the 'Redis' option.
	      }

	      if (this.Events == null) {
	        this.Events = new Events(this);
	      }

	      this.terminated = false;

	      if (this.client == null) {
	        this.client = this.Redis.createClient(this.clientOptions);
	      }

	      this.subscriber = this.client.duplicate();
	      this.limiters = {};
	      this.shas = {};
	      this.ready = this.Promise.all([this._setup(this.client, false), this._setup(this.subscriber, true)]).then(() => {
	        return this._loadScripts();
	      }).then(() => {
	        return {
	          client: this.client,
	          subscriber: this.subscriber
	        };
	      });
	    }

	    _setup(client, sub) {
	      client.setMaxListeners(0);
	      return new this.Promise((resolve, reject) => {
	        client.on("error", e => {
	          return this.Events.trigger("error", e);
	        });

	        if (sub) {
	          client.on("message", (channel, message) => {
	            var ref;
	            return (ref = this.limiters[channel]) != null ? ref._store.onMessage(channel, message) : void 0;
	          });
	        }

	        if (client.ready) {
	          return resolve();
	        } else {
	          return client.once("ready", resolve);
	        }
	      });
	    }

	    _loadScript(name) {
	      return new this.Promise((resolve, reject) => {
	        var payload;
	        payload = Scripts.payload(name);
	        return this.client.multi([["script", "load", payload]]).exec((err, replies) => {
	          if (err != null) {
	            return reject(err);
	          }

	          this.shas[name] = replies[0];
	          return resolve(replies[0]);
	        });
	      });
	    }

	    _loadScripts() {
	      return this.Promise.all(Scripts.names.map(k => {
	        return this._loadScript(k);
	      }));
	    }

	    __runCommand__(cmd) {
	      var _this = this;

	      return _asyncToGenerator(function* () {
	        yield _this.ready;
	        return new _this.Promise((resolve, reject) => {
	          return _this.client.multi([cmd]).exec_atomic(function (err, replies) {
	            if (err != null) {
	              return reject(err);
	            } else {
	              return resolve(replies[0]);
	            }
	          });
	        });
	      })();
	    }

	    __addLimiter__(instance) {
	      return this.Promise.all([instance.channel(), instance.channel_client()].map(channel => {
	        return new this.Promise((resolve, reject) => {
	          var handler;

	          handler = chan => {
	            if (chan === channel) {
	              this.subscriber.removeListener("subscribe", handler);
	              this.limiters[channel] = instance;
	              return resolve();
	            }
	          };

	          this.subscriber.on("subscribe", handler);
	          return this.subscriber.subscribe(channel);
	        });
	      }));
	    }

	    __removeLimiter__(instance) {
	      var _this2 = this;

	      return this.Promise.all([instance.channel(), instance.channel_client()].map(
	      /*#__PURE__*/
	      function () {
	        var _ref = _asyncToGenerator(function* (channel) {
	          if (!_this2.terminated) {
	            yield new _this2.Promise((resolve, reject) => {
	              return _this2.subscriber.unsubscribe(channel, function (err, chan) {
	                if (err != null) {
	                  return reject(err);
	                }

	                if (chan === channel) {
	                  return resolve();
	                }
	              });
	            });
	          }

	          return delete _this2.limiters[channel];
	        });

	        return function (_x) {
	          return _ref.apply(this, arguments);
	        };
	      }()));
	    }

	    __scriptArgs__(name, id, args, cb) {
	      var keys;
	      keys = Scripts.keys(name, id);
	      return [this.shas[name], keys.length].concat(keys, args, cb);
	    }

	    __scriptFn__(name) {
	      return this.client.evalsha.bind(this.client);
	    }

	    disconnect(flush = true) {
	      var i, k, len, ref;
	      ref = Object.keys(this.limiters);

	      for (i = 0, len = ref.length; i < len; i++) {
	        k = ref[i];
	        clearInterval(this.limiters[k]._store.heartbeat);
	      }

	      this.limiters = {};
	      this.terminated = true;
	      this.client.end(flush);
	      this.subscriber.end(flush);
	      return this.Promise.resolve();
	    }

	  }
	  RedisConnection.prototype.datastore = "redis";
	  RedisConnection.prototype.defaults = {
	    Redis: null,
	    clientOptions: {},
	    client: null,
	    Promise: Promise,
	    Events: null
	  };
	  return RedisConnection;
	}.call(void 0);

	RedisConnection_1 = RedisConnection;
	return RedisConnection_1;
}

var IORedisConnection_1;
var hasRequiredIORedisConnection;

function requireIORedisConnection () {
	if (hasRequiredIORedisConnection) return IORedisConnection_1;
	hasRequiredIORedisConnection = 1;

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	var Events, IORedisConnection, Scripts, parser;
	parser = parser$3;
	Events = Events_1;
	Scripts = requireScripts();

	IORedisConnection = function () {
	  class IORedisConnection {
	    constructor(options = {}) {
	      parser.load(options, this.defaults, this);

	      if (this.Redis == null) {
	        this.Redis = eval("require")("ioredis"); // Obfuscated or else Webpack/Angular will try to inline the optional ioredis module. To override this behavior: pass the ioredis module to Bottleneck as the 'Redis' option.
	      }

	      if (this.Events == null) {
	        this.Events = new Events(this);
	      }

	      this.terminated = false;

	      if (this.clusterNodes != null) {
	        this.client = new this.Redis.Cluster(this.clusterNodes, this.clientOptions);
	        this.subscriber = new this.Redis.Cluster(this.clusterNodes, this.clientOptions);
	      } else if (this.client != null && this.client.duplicate == null) {
	        this.subscriber = new this.Redis.Cluster(this.client.startupNodes, this.client.options);
	      } else {
	        if (this.client == null) {
	          this.client = new this.Redis(this.clientOptions);
	        }

	        this.subscriber = this.client.duplicate();
	      }

	      this.limiters = {};
	      this.ready = this.Promise.all([this._setup(this.client, false), this._setup(this.subscriber, true)]).then(() => {
	        this._loadScripts();

	        return {
	          client: this.client,
	          subscriber: this.subscriber
	        };
	      });
	    }

	    _setup(client, sub) {
	      client.setMaxListeners(0);
	      return new this.Promise((resolve, reject) => {
	        client.on("error", e => {
	          return this.Events.trigger("error", e);
	        });

	        if (sub) {
	          client.on("message", (channel, message) => {
	            var ref;
	            return (ref = this.limiters[channel]) != null ? ref._store.onMessage(channel, message) : void 0;
	          });
	        }

	        if (client.status === "ready") {
	          return resolve();
	        } else {
	          return client.once("ready", resolve);
	        }
	      });
	    }

	    _loadScripts() {
	      return Scripts.names.forEach(name => {
	        return this.client.defineCommand(name, {
	          lua: Scripts.payload(name)
	        });
	      });
	    }

	    __runCommand__(cmd) {
	      var _this = this;

	      return _asyncToGenerator(function* () {
	        var deleted;

	        yield _this.ready;

	        var _ref = yield _this.client.pipeline([cmd]).exec();

	        var _ref2 = _slicedToArray(_ref, 1);

	        var _ref2$ = _slicedToArray(_ref2[0], 2);

	        _ref2$[0];
	        deleted = _ref2$[1];
	        return deleted;
	      })();
	    }

	    __addLimiter__(instance) {
	      return this.Promise.all([instance.channel(), instance.channel_client()].map(channel => {
	        return new this.Promise((resolve, reject) => {
	          return this.subscriber.subscribe(channel, () => {
	            this.limiters[channel] = instance;
	            return resolve();
	          });
	        });
	      }));
	    }

	    __removeLimiter__(instance) {
	      var _this2 = this;

	      return [instance.channel(), instance.channel_client()].forEach(
	      /*#__PURE__*/
	      function () {
	        var _ref3 = _asyncToGenerator(function* (channel) {
	          if (!_this2.terminated) {
	            yield _this2.subscriber.unsubscribe(channel);
	          }

	          return delete _this2.limiters[channel];
	        });

	        return function (_x) {
	          return _ref3.apply(this, arguments);
	        };
	      }());
	    }

	    __scriptArgs__(name, id, args, cb) {
	      var keys;
	      keys = Scripts.keys(name, id);
	      return [keys.length].concat(keys, args, cb);
	    }

	    __scriptFn__(name) {
	      return this.client[name].bind(this.client);
	    }

	    disconnect(flush = true) {
	      var i, k, len, ref;
	      ref = Object.keys(this.limiters);

	      for (i = 0, len = ref.length; i < len; i++) {
	        k = ref[i];
	        clearInterval(this.limiters[k]._store.heartbeat);
	      }

	      this.limiters = {};
	      this.terminated = true;

	      if (flush) {
	        return this.Promise.all([this.client.quit(), this.subscriber.quit()]);
	      } else {
	        this.client.disconnect();
	        this.subscriber.disconnect();
	        return this.Promise.resolve();
	      }
	    }

	  }
	  IORedisConnection.prototype.datastore = "ioredis";
	  IORedisConnection.prototype.defaults = {
	    Redis: null,
	    clientOptions: {},
	    clusterNodes: null,
	    client: null,
	    Promise: Promise,
	    Events: null
	  };
	  return IORedisConnection;
	}.call(void 0);

	IORedisConnection_1 = IORedisConnection;
	return IORedisConnection_1;
}

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator$1(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var BottleneckError$1, IORedisConnection, RedisConnection, RedisDatastore, parser;
parser = parser$3;
BottleneckError$1 = requireBottleneckError();
RedisConnection = requireRedisConnection();
IORedisConnection = requireIORedisConnection();
RedisDatastore = class RedisDatastore {
  constructor(instance, storeOptions, storeInstanceOptions) {
    this.instance = instance;
    this.storeOptions = storeOptions;
    this.originalId = this.instance.id;
    this.clientId = this.instance._randomIndex();
    parser.load(storeInstanceOptions, storeInstanceOptions, this);
    this.clients = {};
    this.capacityPriorityCounters = {};
    this.sharedConnection = this.connection != null;

    if (this.connection == null) {
      this.connection = this.instance.datastore === "redis" ? new RedisConnection({
        Redis: this.Redis,
        clientOptions: this.clientOptions,
        Promise: this.Promise,
        Events: this.instance.Events
      }) : this.instance.datastore === "ioredis" ? new IORedisConnection({
        Redis: this.Redis,
        clientOptions: this.clientOptions,
        clusterNodes: this.clusterNodes,
        Promise: this.Promise,
        Events: this.instance.Events
      }) : void 0;
    }

    this.instance.connection = this.connection;
    this.instance.datastore = this.connection.datastore;
    this.ready = this.connection.ready.then(clients => {
      this.clients = clients;
      return this.runScript("init", this.prepareInitSettings(this.clearDatastore));
    }).then(() => {
      return this.connection.__addLimiter__(this.instance);
    }).then(() => {
      return this.runScript("register_client", [this.instance.queued()]);
    }).then(() => {
      var base;

      if (typeof (base = this.heartbeat = setInterval(() => {
        return this.runScript("heartbeat", []).catch(e => {
          return this.instance.Events.trigger("error", e);
        });
      }, this.heartbeatInterval)).unref === "function") {
        base.unref();
      }

      return this.clients;
    });
  }

  __publish__(message) {
    var _this = this;

    return _asyncToGenerator$1(function* () {
      var client;

      var _ref = yield _this.ready;

      client = _ref.client;
      return client.publish(_this.instance.channel(), `message:${message.toString()}`);
    })();
  }

  onMessage(channel, message) {
    var _this2 = this;

    return _asyncToGenerator$1(function* () {
      var capacity, counter, data, drained, e, newCapacity, pos, priorityClient, rawCapacity, type;

      try {
        pos = message.indexOf(":");
        var _ref2 = [message.slice(0, pos), message.slice(pos + 1)];
        type = _ref2[0];
        data = _ref2[1];

        if (type === "capacity") {
          return yield _this2.instance._drainAll(data.length > 0 ? ~~data : void 0);
        } else if (type === "capacity-priority") {
          var _data$split = data.split(":");

          var _data$split2 = _slicedToArray(_data$split, 3);

          rawCapacity = _data$split2[0];
          priorityClient = _data$split2[1];
          counter = _data$split2[2];
          capacity = rawCapacity.length > 0 ? ~~rawCapacity : void 0;

          if (priorityClient === _this2.clientId) {
            drained = yield _this2.instance._drainAll(capacity);
            newCapacity = capacity != null ? capacity - (drained || 0) : "";
            return yield _this2.clients.client.publish(_this2.instance.channel(), `capacity-priority:${newCapacity}::${counter}`);
          } else if (priorityClient === "") {
            clearTimeout(_this2.capacityPriorityCounters[counter]);
            delete _this2.capacityPriorityCounters[counter];
            return _this2.instance._drainAll(capacity);
          } else {
            return _this2.capacityPriorityCounters[counter] = setTimeout(
            /*#__PURE__*/
            _asyncToGenerator$1(function* () {
              var e;

              try {
                delete _this2.capacityPriorityCounters[counter];
                yield _this2.runScript("blacklist_client", [priorityClient]);
                return yield _this2.instance._drainAll(capacity);
              } catch (error) {
                e = error;
                return _this2.instance.Events.trigger("error", e);
              }
            }), 1000);
          }
        } else if (type === "message") {
          return _this2.instance.Events.trigger("message", data);
        } else if (type === "blocked") {
          return yield _this2.instance._dropAllQueued();
        }
      } catch (error) {
        e = error;
        return _this2.instance.Events.trigger("error", e);
      }
    })();
  }

  __disconnect__(flush) {
    clearInterval(this.heartbeat);

    if (this.sharedConnection) {
      return this.connection.__removeLimiter__(this.instance);
    } else {
      return this.connection.disconnect(flush);
    }
  }

  runScript(name, args) {
    var _this3 = this;

    return _asyncToGenerator$1(function* () {
      if (!(name === "init" || name === "register_client")) {
        yield _this3.ready;
      }

      return new _this3.Promise((resolve, reject) => {
        var all_args, arr;
        all_args = [Date.now(), _this3.clientId].concat(args);

        _this3.instance.Events.trigger("debug", `Calling Redis script: ${name}.lua`, all_args);

        arr = _this3.connection.__scriptArgs__(name, _this3.originalId, all_args, function (err, replies) {
          if (err != null) {
            return reject(err);
          }

          return resolve(replies);
        });
        return _this3.connection.__scriptFn__(name)(...arr);
      }).catch(e => {
        if (e.message === "SETTINGS_KEY_NOT_FOUND") {
          if (name === "heartbeat") {
            return _this3.Promise.resolve();
          } else {
            return _this3.runScript("init", _this3.prepareInitSettings(false)).then(() => {
              return _this3.runScript(name, args);
            });
          }
        } else if (e.message === "UNKNOWN_CLIENT") {
          return _this3.runScript("register_client", [_this3.instance.queued()]).then(() => {
            return _this3.runScript(name, args);
          });
        } else {
          return _this3.Promise.reject(e);
        }
      });
    })();
  }

  prepareArray(arr) {
    var i, len, results, x;
    results = [];

    for (i = 0, len = arr.length; i < len; i++) {
      x = arr[i];
      results.push(x != null ? x.toString() : "");
    }

    return results;
  }

  prepareObject(obj) {
    var arr, k, v;
    arr = [];

    for (k in obj) {
      v = obj[k];
      arr.push(k, v != null ? v.toString() : "");
    }

    return arr;
  }

  prepareInitSettings(clear) {
    var args;
    args = this.prepareObject(Object.assign({}, this.storeOptions, {
      id: this.originalId,
      version: this.instance.version,
      groupTimeout: this.timeout,
      clientTimeout: this.clientTimeout
    }));
    args.unshift(clear ? 1 : 0, this.instance.version);
    return args;
  }

  convertBool(b) {
    return !!b;
  }

  __updateSettings__(options) {
    var _this4 = this;

    return _asyncToGenerator$1(function* () {
      yield _this4.runScript("update_settings", _this4.prepareObject(options));
      return parser.overwrite(options, options, _this4.storeOptions);
    })();
  }

  __running__() {
    return this.runScript("running", []);
  }

  __queued__() {
    return this.runScript("queued", []);
  }

  __done__() {
    return this.runScript("done", []);
  }

  __groupCheck__() {
    var _this5 = this;

    return _asyncToGenerator$1(function* () {
      return _this5.convertBool((yield _this5.runScript("group_check", [])));
    })();
  }

  __incrementReservoir__(incr) {
    return this.runScript("increment_reservoir", [incr]);
  }

  __currentReservoir__() {
    return this.runScript("current_reservoir", []);
  }

  __check__(weight) {
    var _this6 = this;

    return _asyncToGenerator$1(function* () {
      return _this6.convertBool((yield _this6.runScript("check", _this6.prepareArray([weight]))));
    })();
  }

  __register__(index, weight, expiration) {
    var _this7 = this;

    return _asyncToGenerator$1(function* () {
      var reservoir, success, wait;

      var _ref4 = yield _this7.runScript("register", _this7.prepareArray([index, weight, expiration]));

      var _ref5 = _slicedToArray(_ref4, 3);

      success = _ref5[0];
      wait = _ref5[1];
      reservoir = _ref5[2];
      return {
        success: _this7.convertBool(success),
        wait,
        reservoir
      };
    })();
  }

  __submit__(queueLength, weight) {
    var _this8 = this;

    return _asyncToGenerator$1(function* () {
      var blocked, e, maxConcurrent, reachedHWM, strategy;

      try {
        var _ref6 = yield _this8.runScript("submit", _this8.prepareArray([queueLength, weight]));

        var _ref7 = _slicedToArray(_ref6, 3);

        reachedHWM = _ref7[0];
        blocked = _ref7[1];
        strategy = _ref7[2];
        return {
          reachedHWM: _this8.convertBool(reachedHWM),
          blocked: _this8.convertBool(blocked),
          strategy
        };
      } catch (error) {
        e = error;

        if (e.message.indexOf("OVERWEIGHT") === 0) {
          var _e$message$split = e.message.split(":");

          var _e$message$split2 = _slicedToArray(_e$message$split, 3);

          _e$message$split2[0];
          weight = _e$message$split2[1];
          maxConcurrent = _e$message$split2[2];
          throw new BottleneckError$1(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${maxConcurrent}`);
        } else {
          throw e;
        }
      }
    })();
  }

  __free__(index, weight) {
    var _this9 = this;

    return _asyncToGenerator$1(function* () {
      var running;
      running = yield _this9.runScript("free", _this9.prepareArray([index]));
      return {
        running
      };
    })();
  }

};
var RedisDatastore_1 = RedisDatastore;

var BottleneckError, States;
BottleneckError = requireBottleneckError();
States = class States {
  constructor(status1) {
    this.status = status1;
    this._jobs = {};
    this.counts = this.status.map(function () {
      return 0;
    });
  }

  next(id) {
    var current, next;
    current = this._jobs[id];
    next = current + 1;

    if (current != null && next < this.status.length) {
      this.counts[current]--;
      this.counts[next]++;
      return this._jobs[id]++;
    } else if (current != null) {
      this.counts[current]--;
      return delete this._jobs[id];
    }
  }

  start(id) {
    var initial;
    initial = 0;
    this._jobs[id] = initial;
    return this.counts[initial]++;
  }

  remove(id) {
    var current;
    current = this._jobs[id];

    if (current != null) {
      this.counts[current]--;
      delete this._jobs[id];
    }

    return current != null;
  }

  jobStatus(id) {
    var ref;
    return (ref = this.status[this._jobs[id]]) != null ? ref : null;
  }

  statusJobs(status) {
    var k, pos, ref, results, v;

    if (status != null) {
      pos = this.status.indexOf(status);

      if (pos < 0) {
        throw new BottleneckError(`status must be one of ${this.status.join(', ')}`);
      }

      ref = this._jobs;
      results = [];

      for (k in ref) {
        v = ref[k];

        if (v === pos) {
          results.push(k);
        }
      }

      return results;
    } else {
      return Object.keys(this._jobs);
    }
  }

  statusCounts() {
    return this.counts.reduce((acc, v, i) => {
      acc[this.status[i]] = v;
      return acc;
    }, {});
  }

};
var States_1 = States;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var DLList, Sync;
DLList = DLList_1;
Sync = class Sync {
  constructor(name, Promise) {
    this.schedule = this.schedule.bind(this);
    this.name = name;
    this.Promise = Promise;
    this._running = 0;
    this._queue = new DLList();
  }

  isEmpty() {
    return this._queue.length === 0;
  }

  _tryToRun() {
    var _this = this;

    return _asyncToGenerator(function* () {
      var args, cb, error, reject, resolve, returned, task;

      if (_this._running < 1 && _this._queue.length > 0) {
        _this._running++;

        var _this$_queue$shift = _this._queue.shift();

        task = _this$_queue$shift.task;
        args = _this$_queue$shift.args;
        resolve = _this$_queue$shift.resolve;
        reject = _this$_queue$shift.reject;
        cb = yield _asyncToGenerator(function* () {
          try {
            returned = yield task(...args);
            return function () {
              return resolve(returned);
            };
          } catch (error1) {
            error = error1;
            return function () {
              return reject(error);
            };
          }
        })();
        _this._running--;

        _this._tryToRun();

        return cb();
      }
    })();
  }

  schedule(task, ...args) {
    var promise, reject, resolve;
    resolve = reject = null;
    promise = new this.Promise(function (_resolve, _reject) {
      resolve = _resolve;
      return reject = _reject;
    });

    this._queue.push({
      task,
      args,
      resolve,
      reject
    });

    this._tryToRun();

    return promise;
  }

};
var Sync_1 = Sync;

var version$1 = "2.19.5";
var require$$8 = {
	version: version$1
};

var Group_1;
var hasRequiredGroup;

function requireGroup () {
	if (hasRequiredGroup) return Group_1;
	hasRequiredGroup = 1;

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	var Events, Group, IORedisConnection, RedisConnection, Scripts, parser;
	parser = parser$3;
	Events = Events_1;
	RedisConnection = requireRedisConnection();
	IORedisConnection = requireIORedisConnection();
	Scripts = requireScripts();

	Group = function () {
	  class Group {
	    constructor(limiterOptions = {}) {
	      this.deleteKey = this.deleteKey.bind(this);
	      this.limiterOptions = limiterOptions;
	      parser.load(this.limiterOptions, this.defaults, this);
	      this.Events = new Events(this);
	      this.instances = {};
	      this.Bottleneck = requireBottleneck();

	      this._startAutoCleanup();

	      this.sharedConnection = this.connection != null;

	      if (this.connection == null) {
	        if (this.limiterOptions.datastore === "redis") {
	          this.connection = new RedisConnection(Object.assign({}, this.limiterOptions, {
	            Events: this.Events
	          }));
	        } else if (this.limiterOptions.datastore === "ioredis") {
	          this.connection = new IORedisConnection(Object.assign({}, this.limiterOptions, {
	            Events: this.Events
	          }));
	        }
	      }
	    }

	    key(key = "") {
	      var ref;
	      return (ref = this.instances[key]) != null ? ref : (() => {
	        var limiter;
	        limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
	          id: `${this.id}-${key}`,
	          timeout: this.timeout,
	          connection: this.connection
	        }));
	        this.Events.trigger("created", limiter, key);
	        return limiter;
	      })();
	    }

	    deleteKey(key = "") {
	      var _this = this;

	      return _asyncToGenerator(function* () {
	        var deleted, instance;
	        instance = _this.instances[key];

	        if (_this.connection) {
	          deleted = yield _this.connection.__runCommand__(['del', ...Scripts.allKeys(`${_this.id}-${key}`)]);
	        }

	        if (instance != null) {
	          delete _this.instances[key];
	          yield instance.disconnect();
	        }

	        return instance != null || deleted > 0;
	      })();
	    }

	    limiters() {
	      var k, ref, results, v;
	      ref = this.instances;
	      results = [];

	      for (k in ref) {
	        v = ref[k];
	        results.push({
	          key: k,
	          limiter: v
	        });
	      }

	      return results;
	    }

	    keys() {
	      return Object.keys(this.instances);
	    }

	    clusterKeys() {
	      var _this2 = this;

	      return _asyncToGenerator(function* () {
	        var cursor, end, found, i, k, keys, len, next, start;

	        if (_this2.connection == null) {
	          return _this2.Promise.resolve(_this2.keys());
	        }

	        keys = [];
	        cursor = null;
	        start = `b_${_this2.id}-`.length;
	        end = "_settings".length;

	        while (cursor !== 0) {
	          var _ref = yield _this2.connection.__runCommand__(["scan", cursor != null ? cursor : 0, "match", `b_${_this2.id}-*_settings`, "count", 10000]);

	          var _ref2 = _slicedToArray(_ref, 2);

	          next = _ref2[0];
	          found = _ref2[1];
	          cursor = ~~next;

	          for (i = 0, len = found.length; i < len; i++) {
	            k = found[i];
	            keys.push(k.slice(start, -end));
	          }
	        }

	        return keys;
	      })();
	    }

	    _startAutoCleanup() {
	      var _this3 = this;

	      var base;
	      clearInterval(this.interval);
	      return typeof (base = this.interval = setInterval(
	      /*#__PURE__*/
	      _asyncToGenerator(function* () {
	        var e, k, ref, results, time, v;
	        time = Date.now();
	        ref = _this3.instances;
	        results = [];

	        for (k in ref) {
	          v = ref[k];

	          try {
	            if (yield v._store.__groupCheck__(time)) {
	              results.push(_this3.deleteKey(k));
	            } else {
	              results.push(void 0);
	            }
	          } catch (error) {
	            e = error;
	            results.push(v.Events.trigger("error", e));
	          }
	        }

	        return results;
	      }), this.timeout / 2)).unref === "function" ? base.unref() : void 0;
	    }

	    updateSettings(options = {}) {
	      parser.overwrite(options, this.defaults, this);
	      parser.overwrite(options, options, this.limiterOptions);

	      if (options.timeout != null) {
	        return this._startAutoCleanup();
	      }
	    }

	    disconnect(flush = true) {
	      var ref;

	      if (!this.sharedConnection) {
	        return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;
	      }
	    }

	  }
	  Group.prototype.defaults = {
	    timeout: 1000 * 60 * 5,
	    connection: null,
	    Promise: Promise,
	    id: "group-key"
	  };
	  return Group;
	}.call(void 0);

	Group_1 = Group;
	return Group_1;
}

var Batcher_1;
var hasRequiredBatcher;

function requireBatcher () {
	if (hasRequiredBatcher) return Batcher_1;
	hasRequiredBatcher = 1;

	var Batcher, Events, parser;
	parser = parser$3;
	Events = Events_1;

	Batcher = function () {
	  class Batcher {
	    constructor(options = {}) {
	      this.options = options;
	      parser.load(this.options, this.defaults, this);
	      this.Events = new Events(this);
	      this._arr = [];

	      this._resetPromise();

	      this._lastFlush = Date.now();
	    }

	    _resetPromise() {
	      return this._promise = new this.Promise((res, rej) => {
	        return this._resolve = res;
	      });
	    }

	    _flush() {
	      clearTimeout(this._timeout);
	      this._lastFlush = Date.now();

	      this._resolve();

	      this.Events.trigger("batch", this._arr);
	      this._arr = [];
	      return this._resetPromise();
	    }

	    add(data) {
	      var ret;

	      this._arr.push(data);

	      ret = this._promise;

	      if (this._arr.length === this.maxSize) {
	        this._flush();
	      } else if (this.maxTime != null && this._arr.length === 1) {
	        this._timeout = setTimeout(() => {
	          return this._flush();
	        }, this.maxTime);
	      }

	      return ret;
	    }

	  }
	  Batcher.prototype.defaults = {
	    maxTime: null,
	    maxSize: null,
	    Promise: Promise
	  };
	  return Batcher;
	}.call(void 0);

	Batcher_1 = Batcher;
	return Batcher_1;
}

var Bottleneck_1;
var hasRequiredBottleneck;

function requireBottleneck () {
	if (hasRequiredBottleneck) return Bottleneck_1;
	hasRequiredBottleneck = 1;

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	var Bottleneck,
	    DEFAULT_PRIORITY,
	    Events,
	    Job,
	    LocalDatastore,
	    NUM_PRIORITIES,
	    Queues,
	    RedisDatastore,
	    States,
	    Sync,
	    parser,
	    splice = [].splice;
	NUM_PRIORITIES = 10;
	DEFAULT_PRIORITY = 5;
	parser = parser$3;
	Queues = Queues_1;
	Job = Job_1;
	LocalDatastore = LocalDatastore_1;
	RedisDatastore = RedisDatastore_1;
	Events = Events_1;
	States = States_1;
	Sync = Sync_1;

	Bottleneck = function () {
	  class Bottleneck {
	    constructor(options = {}, ...invalid) {
	      var storeInstanceOptions, storeOptions;
	      this._addToQueue = this._addToQueue.bind(this);

	      this._validateOptions(options, invalid);

	      parser.load(options, this.instanceDefaults, this);
	      this._queues = new Queues(NUM_PRIORITIES);
	      this._scheduled = {};
	      this._states = new States(["RECEIVED", "QUEUED", "RUNNING", "EXECUTING"].concat(this.trackDoneStatus ? ["DONE"] : []));
	      this._limiter = null;
	      this.Events = new Events(this);
	      this._submitLock = new Sync("submit", this.Promise);
	      this._registerLock = new Sync("register", this.Promise);
	      storeOptions = parser.load(options, this.storeDefaults, {});

	      this._store = function () {
	        if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null) {
	          storeInstanceOptions = parser.load(options, this.redisStoreDefaults, {});
	          return new RedisDatastore(this, storeOptions, storeInstanceOptions);
	        } else if (this.datastore === "local") {
	          storeInstanceOptions = parser.load(options, this.localStoreDefaults, {});
	          return new LocalDatastore(this, storeOptions, storeInstanceOptions);
	        } else {
	          throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
	        }
	      }.call(this);

	      this._queues.on("leftzero", () => {
	        var ref;
	        return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : void 0 : void 0;
	      });

	      this._queues.on("zero", () => {
	        var ref;
	        return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : void 0 : void 0;
	      });
	    }

	    _validateOptions(options, invalid) {
	      if (!(options != null && typeof options === "object" && invalid.length === 0)) {
	        throw new Bottleneck.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
	      }
	    }

	    ready() {
	      return this._store.ready;
	    }

	    clients() {
	      return this._store.clients;
	    }

	    channel() {
	      return `b_${this.id}`;
	    }

	    channel_client() {
	      return `b_${this.id}_${this._store.clientId}`;
	    }

	    publish(message) {
	      return this._store.__publish__(message);
	    }

	    disconnect(flush = true) {
	      return this._store.__disconnect__(flush);
	    }

	    chain(_limiter) {
	      this._limiter = _limiter;
	      return this;
	    }

	    queued(priority) {
	      return this._queues.queued(priority);
	    }

	    clusterQueued() {
	      return this._store.__queued__();
	    }

	    empty() {
	      return this.queued() === 0 && this._submitLock.isEmpty();
	    }

	    running() {
	      return this._store.__running__();
	    }

	    done() {
	      return this._store.__done__();
	    }

	    jobStatus(id) {
	      return this._states.jobStatus(id);
	    }

	    jobs(status) {
	      return this._states.statusJobs(status);
	    }

	    counts() {
	      return this._states.statusCounts();
	    }

	    _randomIndex() {
	      return Math.random().toString(36).slice(2);
	    }

	    check(weight = 1) {
	      return this._store.__check__(weight);
	    }

	    _clearGlobalState(index) {
	      if (this._scheduled[index] != null) {
	        clearTimeout(this._scheduled[index].expiration);
	        delete this._scheduled[index];
	        return true;
	      } else {
	        return false;
	      }
	    }

	    _free(index, job, options, eventInfo) {
	      var _this = this;

	      return _asyncToGenerator(function* () {
	        var e, running;

	        try {
	          var _ref = yield _this._store.__free__(index, options.weight);

	          running = _ref.running;

	          _this.Events.trigger("debug", `Freed ${options.id}`, eventInfo);

	          if (running === 0 && _this.empty()) {
	            return _this.Events.trigger("idle");
	          }
	        } catch (error1) {
	          e = error1;
	          return _this.Events.trigger("error", e);
	        }
	      })();
	    }

	    _run(index, job, wait) {
	      var clearGlobalState, free, run;
	      job.doRun();
	      clearGlobalState = this._clearGlobalState.bind(this, index);
	      run = this._run.bind(this, index, job);
	      free = this._free.bind(this, index, job);
	      return this._scheduled[index] = {
	        timeout: setTimeout(() => {
	          return job.doExecute(this._limiter, clearGlobalState, run, free);
	        }, wait),
	        expiration: job.options.expiration != null ? setTimeout(function () {
	          return job.doExpire(clearGlobalState, run, free);
	        }, wait + job.options.expiration) : void 0,
	        job: job
	      };
	    }

	    _drainOne(capacity) {
	      return this._registerLock.schedule(() => {
	        var args, index, next, options, queue;

	        if (this.queued() === 0) {
	          return this.Promise.resolve(null);
	        }

	        queue = this._queues.getFirst();

	        var _next2 = next = queue.first();

	        options = _next2.options;
	        args = _next2.args;

	        if (capacity != null && options.weight > capacity) {
	          return this.Promise.resolve(null);
	        }

	        this.Events.trigger("debug", `Draining ${options.id}`, {
	          args,
	          options
	        });
	        index = this._randomIndex();
	        return this._store.__register__(index, options.weight, options.expiration).then(({
	          success,
	          wait,
	          reservoir
	        }) => {
	          var empty;
	          this.Events.trigger("debug", `Drained ${options.id}`, {
	            success,
	            args,
	            options
	          });

	          if (success) {
	            queue.shift();
	            empty = this.empty();

	            if (empty) {
	              this.Events.trigger("empty");
	            }

	            if (reservoir === 0) {
	              this.Events.trigger("depleted", empty);
	            }

	            this._run(index, next, wait);

	            return this.Promise.resolve(options.weight);
	          } else {
	            return this.Promise.resolve(null);
	          }
	        });
	      });
	    }

	    _drainAll(capacity, total = 0) {
	      return this._drainOne(capacity).then(drained => {
	        var newCapacity;

	        if (drained != null) {
	          newCapacity = capacity != null ? capacity - drained : capacity;
	          return this._drainAll(newCapacity, total + drained);
	        } else {
	          return this.Promise.resolve(total);
	        }
	      }).catch(e => {
	        return this.Events.trigger("error", e);
	      });
	    }

	    _dropAllQueued(message) {
	      return this._queues.shiftAll(function (job) {
	        return job.doDrop({
	          message
	        });
	      });
	    }

	    stop(options = {}) {
	      var done, waitForExecuting;
	      options = parser.load(options, this.stopDefaults);

	      waitForExecuting = at => {
	        var finished;

	        finished = () => {
	          var counts;
	          counts = this._states.counts;
	          return counts[0] + counts[1] + counts[2] + counts[3] === at;
	        };

	        return new this.Promise((resolve, reject) => {
	          if (finished()) {
	            return resolve();
	          } else {
	            return this.on("done", () => {
	              if (finished()) {
	                this.removeAllListeners("done");
	                return resolve();
	              }
	            });
	          }
	        });
	      };

	      done = options.dropWaitingJobs ? (this._run = function (index, next) {
	        return next.doDrop({
	          message: options.dropErrorMessage
	        });
	      }, this._drainOne = () => {
	        return this.Promise.resolve(null);
	      }, this._registerLock.schedule(() => {
	        return this._submitLock.schedule(() => {
	          var k, ref, v;
	          ref = this._scheduled;

	          for (k in ref) {
	            v = ref[k];

	            if (this.jobStatus(v.job.options.id) === "RUNNING") {
	              clearTimeout(v.timeout);
	              clearTimeout(v.expiration);
	              v.job.doDrop({
	                message: options.dropErrorMessage
	              });
	            }
	          }

	          this._dropAllQueued(options.dropErrorMessage);

	          return waitForExecuting(0);
	        });
	      })) : this.schedule({
	        priority: NUM_PRIORITIES - 1,
	        weight: 0
	      }, () => {
	        return waitForExecuting(1);
	      });

	      this._receive = function (job) {
	        return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage));
	      };

	      this.stop = () => {
	        return this.Promise.reject(new Bottleneck.prototype.BottleneckError("stop() has already been called"));
	      };

	      return done;
	    }

	    _addToQueue(job) {
	      var _this2 = this;

	      return _asyncToGenerator(function* () {
	        var args, blocked, error, options, reachedHWM, shifted, strategy;
	        args = job.args;
	        options = job.options;

	        try {
	          var _ref2 = yield _this2._store.__submit__(_this2.queued(), options.weight);

	          reachedHWM = _ref2.reachedHWM;
	          blocked = _ref2.blocked;
	          strategy = _ref2.strategy;
	        } catch (error1) {
	          error = error1;

	          _this2.Events.trigger("debug", `Could not queue ${options.id}`, {
	            args,
	            options,
	            error
	          });

	          job.doDrop({
	            error
	          });
	          return false;
	        }

	        if (blocked) {
	          job.doDrop();
	          return true;
	        } else if (reachedHWM) {
	          shifted = strategy === Bottleneck.prototype.strategy.LEAK ? _this2._queues.shiftLastFrom(options.priority) : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? _this2._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;

	          if (shifted != null) {
	            shifted.doDrop();
	          }

	          if (shifted == null || strategy === Bottleneck.prototype.strategy.OVERFLOW) {
	            if (shifted == null) {
	              job.doDrop();
	            }

	            return reachedHWM;
	          }
	        }

	        job.doQueue(reachedHWM, blocked);

	        _this2._queues.push(job);

	        yield _this2._drainAll();
	        return reachedHWM;
	      })();
	    }

	    _receive(job) {
	      if (this._states.jobStatus(job.options.id) != null) {
	        job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));

	        return false;
	      } else {
	        job.doReceive();
	        return this._submitLock.schedule(this._addToQueue, job);
	      }
	    }

	    submit(...args) {
	      var cb, fn, job, options, ref, ref1, task;

	      if (typeof args[0] === "function") {
	        var _ref3, _ref4, _splice$call, _splice$call2;

	        ref = args, (_ref3 = ref, _ref4 = _toArray(_ref3), fn = _ref4[0], args = _ref4.slice(1), _ref3), (_splice$call = splice.call(args, -1), _splice$call2 = _slicedToArray(_splice$call, 1), cb = _splice$call2[0], _splice$call);
	        options = parser.load({}, this.jobDefaults);
	      } else {
	        var _ref5, _ref6, _splice$call3, _splice$call4;

	        ref1 = args, (_ref5 = ref1, _ref6 = _toArray(_ref5), options = _ref6[0], fn = _ref6[1], args = _ref6.slice(2), _ref5), (_splice$call3 = splice.call(args, -1), _splice$call4 = _slicedToArray(_splice$call3, 1), cb = _splice$call4[0], _splice$call3);
	        options = parser.load(options, this.jobDefaults);
	      }

	      task = (...args) => {
	        return new this.Promise(function (resolve, reject) {
	          return fn(...args, function (...args) {
	            return (args[0] != null ? reject : resolve)(args);
	          });
	        });
	      };

	      job = new Job(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
	      job.promise.then(function (args) {
	        return typeof cb === "function" ? cb(...args) : void 0;
	      }).catch(function (args) {
	        if (Array.isArray(args)) {
	          return typeof cb === "function" ? cb(...args) : void 0;
	        } else {
	          return typeof cb === "function" ? cb(args) : void 0;
	        }
	      });
	      return this._receive(job);
	    }

	    schedule(...args) {
	      var job, options, task;

	      if (typeof args[0] === "function") {
	        var _args = args;

	        var _args2 = _toArray(_args);

	        task = _args2[0];
	        args = _args2.slice(1);
	        options = {};
	      } else {
	        var _args3 = args;

	        var _args4 = _toArray(_args3);

	        options = _args4[0];
	        task = _args4[1];
	        args = _args4.slice(2);
	      }

	      job = new Job(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);

	      this._receive(job);

	      return job.promise;
	    }

	    wrap(fn) {
	      var schedule, wrapped;
	      schedule = this.schedule.bind(this);

	      wrapped = function wrapped(...args) {
	        return schedule(fn.bind(this), ...args);
	      };

	      wrapped.withOptions = function (options, ...args) {
	        return schedule(options, fn, ...args);
	      };

	      return wrapped;
	    }

	    updateSettings(options = {}) {
	      var _this3 = this;

	      return _asyncToGenerator(function* () {
	        yield _this3._store.__updateSettings__(parser.overwrite(options, _this3.storeDefaults));
	        parser.overwrite(options, _this3.instanceDefaults, _this3);
	        return _this3;
	      })();
	    }

	    currentReservoir() {
	      return this._store.__currentReservoir__();
	    }

	    incrementReservoir(incr = 0) {
	      return this._store.__incrementReservoir__(incr);
	    }

	  }
	  Bottleneck.default = Bottleneck;
	  Bottleneck.Events = Events;
	  Bottleneck.version = Bottleneck.prototype.version = require$$8.version;
	  Bottleneck.strategy = Bottleneck.prototype.strategy = {
	    LEAK: 1,
	    OVERFLOW: 2,
	    OVERFLOW_PRIORITY: 4,
	    BLOCK: 3
	  };
	  Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = requireBottleneckError();
	  Bottleneck.Group = Bottleneck.prototype.Group = requireGroup();
	  Bottleneck.RedisConnection = Bottleneck.prototype.RedisConnection = requireRedisConnection();
	  Bottleneck.IORedisConnection = Bottleneck.prototype.IORedisConnection = requireIORedisConnection();
	  Bottleneck.Batcher = Bottleneck.prototype.Batcher = requireBatcher();
	  Bottleneck.prototype.jobDefaults = {
	    priority: DEFAULT_PRIORITY,
	    weight: 1,
	    expiration: null,
	    id: "<no-id>"
	  };
	  Bottleneck.prototype.storeDefaults = {
	    maxConcurrent: null,
	    minTime: 0,
	    highWater: null,
	    strategy: Bottleneck.prototype.strategy.LEAK,
	    penalty: null,
	    reservoir: null,
	    reservoirRefreshInterval: null,
	    reservoirRefreshAmount: null,
	    reservoirIncreaseInterval: null,
	    reservoirIncreaseAmount: null,
	    reservoirIncreaseMaximum: null
	  };
	  Bottleneck.prototype.localStoreDefaults = {
	    Promise: Promise,
	    timeout: null,
	    heartbeatInterval: 250
	  };
	  Bottleneck.prototype.redisStoreDefaults = {
	    Promise: Promise,
	    timeout: null,
	    heartbeatInterval: 5000,
	    clientTimeout: 10000,
	    Redis: null,
	    clientOptions: {},
	    clusterNodes: null,
	    clearDatastore: false,
	    connection: null
	  };
	  Bottleneck.prototype.instanceDefaults = {
	    datastore: "local",
	    connection: null,
	    id: "<no-id>",
	    rejectOnDrop: true,
	    trackDoneStatus: false,
	    Promise: Promise
	  };
	  Bottleneck.prototype.stopDefaults = {
	    enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
	    dropWaitingJobs: true,
	    dropErrorMessage: "This limiter has been stopped."
	  };
	  return Bottleneck;
	}.call(void 0);

	Bottleneck_1 = Bottleneck;
	return Bottleneck_1;
}

var lib = requireBottleneck();

var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(limiter, "__esModule", { value: true });
limiter.getLimiter = limiter.RATE_LIMITER_DEFAULT_CONFIG = void 0;
const bottleneck_1 = __importDefault$3(lib);
// default values are matching https://docs.blockfrost.io/#section/Limits
// burst 500 reqs/50s with 10req/1s cool-off
limiter.RATE_LIMITER_DEFAULT_CONFIG = {
    size: 500,
    increaseInterval: 1000,
    increaseAmount: 10,
};
const getLimiter = (config) => {
    // see Bottleneck docs https://www.npmjs.com/package/bottleneck#constructor=
    const limiter = new bottleneck_1.default({
        /*
          How many jobs can be executed before the limiter stops executing jobs.
          If reservoir reaches 0, no jobs will be executed until it is no longer 0.
          New jobs will still be queued up.
        */
        reservoir: config.size,
        /*
          The increment applied to reservoir when reservoirIncreaseInterval is in use.
        */
        reservoirIncreaseAmount: config.increaseAmount,
        /* Every reservoirRefreshInterval milliseconds, the reservoir value will be automatically updated to the value of reservoirRefreshAmount.
           The reservoirRefreshInterval value should be a multiple of 250(5000 for Clustering).
        */
        reservoirIncreaseInterval: config.increaseInterval,
        /*
          The maximum value that reservoir can reach when reservoirIncreaseInterval is in use.
        */
        reservoirIncreaseMaximum: config.size,
    });
    limiter.on('error', function (error) {
        console.error(error);
    });
    return limiter;
};
limiter.getLimiter = getLimiter;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.paginateMethod = exports.getAllMethodOptions = exports.getPaginationOptions = exports.getAdditionalParams = exports.validateOptions = exports.isDebugEnabled = void 0;
	const config_1 = config;
	const limiter_1 = limiter;
	const isDebugEnabled = () => process.env.BLOCKFROST_DEBUG === 'true';
	exports.isDebugEnabled = isDebugEnabled;
	const validateOptions = (options) => {
	    var _a, _b, _c, _d, _e;
	    if (!options || (!options.customBackend && !options.projectId)) {
	        throw Error('Missing customBackend or projectId option');
	    }
	    if (!options.projectId && !options.customBackend) {
	        throw Error('Missing param projectId in options');
	    }
	    if (options.version && isNaN(options.version)) {
	        throw Error('Param version is not a number');
	    }
	    if (options.requestTimeout && isNaN(options.requestTimeout)) {
	        throw Error('Param requestTimeout is not a number');
	    }
	    const debug = (_a = options.debug) !== null && _a !== void 0 ? _a : (0, exports.isDebugEnabled)();
	    let rateLimiter;
	    if (options.rateLimiter === false) {
	        rateLimiter = false;
	    }
	    else if (options.rateLimiter === true ||
	        options.rateLimiter === undefined) {
	        rateLimiter = limiter_1.RATE_LIMITER_DEFAULT_CONFIG;
	    }
	    else if (options.rateLimiter) {
	        // custom config
	        // eslint-disable-next-line prefer-destructuring
	        rateLimiter = options.rateLimiter;
	    }
	    const errorCodesToRetry = [
	        'ETIMEDOUT',
	        'ECONNRESET',
	        'EADDRINUSE',
	        'ECONNREFUSED',
	        'EPIPE',
	        'ENOTFOUND',
	        'ENETUNREACH',
	        'EAI_AGAIN',
	    ];
	    return {
	        customBackend: options.customBackend,
	        projectId: options.projectId,
	        network: (_b = options.network) !== null && _b !== void 0 ? _b : deriveNetworkOption(options.projectId),
	        rateLimiter,
	        version: options.version || config_1.DEFAULT_API_VERSION,
	        debug,
	        http2: (_c = options.http2) !== null && _c !== void 0 ? _c : false,
	        requestTimeout: (_d = options.requestTimeout) !== null && _d !== void 0 ? _d : 20000,
	        // see: https://github.com/sindresorhus/got/blob/main/documentation/7-retry.md#retry
	        retrySettings: (_e = options.retrySettings) !== null && _e !== void 0 ? _e : {
	            limit: 3,
	            methods: ['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'TRACE'],
	            statusCodes: [408, 413, 429, 500, 502, 503, 504, 521, 522, 524],
	            errorCodes: [
	                'ETIMEDOUT',
	                'ECONNRESET',
	                'EADDRINUSE',
	                'ECONNREFUSED',
	                'EPIPE',
	                'ENOTFOUND',
	                'ENETUNREACH',
	                'EAI_AGAIN',
	            ],
	            calculateDelay: (retryObject) => {
	                if (errorCodesToRetry.includes(retryObject.error.code)) {
	                    // network errors are retried only 3 times
	                    if (retryObject.attemptCount === 3) {
	                        return 0;
	                    }
	                }
	                // check if retry should be enabled, if so set 1s retry delay
	                return retryObject.computedValue !== 0 ? 1000 : 0;
	            },
	            // maxRetryAfter: undefined,
	            // backoffLimit: Number.POSITIVE_INFINITY,
	            // noise: 100
	        },
	    };
	};
	exports.validateOptions = validateOptions;
	const deriveNetworkOption = (projectId) => {
	    if (!projectId)
	        return undefined;
	    if (projectId.startsWith('mainnet')) {
	        return 'mainnet';
	    }
	    else if (projectId.startsWith('testnet')) {
	        return 'testnet';
	    }
	    else if (projectId.startsWith('preview')) {
	        return 'preview';
	    }
	    else if (projectId.startsWith('preprod')) {
	        return 'preprod';
	    }
	    else if (projectId.startsWith('ipfs')) {
	        return 'ipfs';
	    }
	    else {
	        console.warn('WARNING: Old token was used without network parameter. Switching to mainnet network');
	        return 'mainnet';
	    }
	};
	const getAdditionalParams = (options) => {
	    if (!options) {
	        return {
	            from: undefined,
	            to: undefined,
	        };
	    }
	    return {
	        from: options.from || undefined,
	        to: options.to || undefined,
	    };
	};
	exports.getAdditionalParams = getAdditionalParams;
	const getPaginationOptions = (options) => {
	    if (!options) {
	        return {
	            page: config_1.DEFAULT_PAGINATION_PAGE_COUNT,
	            count: config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT,
	            order: config_1.DEFAULT_ORDER,
	        };
	    }
	    return {
	        page: options.page || config_1.DEFAULT_PAGINATION_PAGE_COUNT,
	        count: options.count || config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT,
	        order: options.order || config_1.DEFAULT_ORDER,
	    };
	};
	exports.getPaginationOptions = getPaginationOptions;
	const getAllMethodOptions = (options) => {
	    if (!options) {
	        return {
	            batchSize: config_1.DEFAULT_BATCH_SIZE,
	            order: config_1.DEFAULT_ORDER,
	        };
	    }
	    return {
	        batchSize: options.batchSize || config_1.DEFAULT_PAGINATION_PAGE_COUNT,
	        order: options.order || config_1.DEFAULT_ORDER,
	    };
	};
	exports.getAllMethodOptions = getAllMethodOptions;
	const paginateMethod = async (fn, allMethodOptions, additionalOptions) => {
	    const res = [];
	    let page = 1;
	    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
	    const options = (0, exports.getAllMethodOptions)(allMethodOptions);
	    const getSlice = () => {
	        const promises = [...Array(options.batchSize).keys()].map(i => fn({
	            page: page + i,
	            count,
	            order: options.order,
	        }, {
	            from: additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.from,
	            to: additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.to,
	        }));
	        page += options.batchSize;
	        return promises;
	    };
	    // eslint-disable-next-line no-constant-condition
	    while (true) {
	        const pages = await Promise.all(getSlice());
	        for (const p of pages) {
	            res.push(...p);
	            if (p.length < count) {
	                return res; // yikes
	            }
	        }
	    }
	};
	exports.paginateMethod = paginateMethod; 
} (utils));

var errors$1 = {};

var source$4 = {exports: {}};

var create = {};

var dist$1 = {exports: {}};

(function (module, exports) {
	/// <reference lib="es2018"/>
	/// <reference lib="dom"/>
	/// <reference types="node"/>
	Object.defineProperty(exports, "__esModule", { value: true });
	const typedArrayTypeNames = [
	    'Int8Array',
	    'Uint8Array',
	    'Uint8ClampedArray',
	    'Int16Array',
	    'Uint16Array',
	    'Int32Array',
	    'Uint32Array',
	    'Float32Array',
	    'Float64Array',
	    'BigInt64Array',
	    'BigUint64Array'
	];
	function isTypedArrayName(name) {
	    return typedArrayTypeNames.includes(name);
	}
	const objectTypeNames = [
	    'Function',
	    'Generator',
	    'AsyncGenerator',
	    'GeneratorFunction',
	    'AsyncGeneratorFunction',
	    'AsyncFunction',
	    'Observable',
	    'Array',
	    'Buffer',
	    'Blob',
	    'Object',
	    'RegExp',
	    'Date',
	    'Error',
	    'Map',
	    'Set',
	    'WeakMap',
	    'WeakSet',
	    'ArrayBuffer',
	    'SharedArrayBuffer',
	    'DataView',
	    'Promise',
	    'URL',
	    'FormData',
	    'URLSearchParams',
	    'HTMLElement',
	    ...typedArrayTypeNames
	];
	function isObjectTypeName(name) {
	    return objectTypeNames.includes(name);
	}
	const primitiveTypeNames = [
	    'null',
	    'undefined',
	    'string',
	    'number',
	    'bigint',
	    'boolean',
	    'symbol'
	];
	function isPrimitiveTypeName(name) {
	    return primitiveTypeNames.includes(name);
	}
	// eslint-disable-next-line @typescript-eslint/ban-types
	function isOfType(type) {
	    return (value) => typeof value === type;
	}
	const { toString } = Object.prototype;
	const getObjectType = (value) => {
	    const objectTypeName = toString.call(value).slice(8, -1);
	    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
	        return 'HTMLElement';
	    }
	    if (isObjectTypeName(objectTypeName)) {
	        return objectTypeName;
	    }
	    return undefined;
	};
	const isObjectOfType = (type) => (value) => getObjectType(value) === type;
	function is(value) {
	    if (value === null) {
	        return 'null';
	    }
	    switch (typeof value) {
	        case 'undefined':
	            return 'undefined';
	        case 'string':
	            return 'string';
	        case 'number':
	            return 'number';
	        case 'boolean':
	            return 'boolean';
	        case 'function':
	            return 'Function';
	        case 'bigint':
	            return 'bigint';
	        case 'symbol':
	            return 'symbol';
	    }
	    if (is.observable(value)) {
	        return 'Observable';
	    }
	    if (is.array(value)) {
	        return 'Array';
	    }
	    if (is.buffer(value)) {
	        return 'Buffer';
	    }
	    const tagType = getObjectType(value);
	    if (tagType) {
	        return tagType;
	    }
	    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
	        throw new TypeError('Please don\'t use object wrappers for primitive types');
	    }
	    return 'Object';
	}
	is.undefined = isOfType('undefined');
	is.string = isOfType('string');
	const isNumberType = isOfType('number');
	is.number = (value) => isNumberType(value) && !is.nan(value);
	is.bigint = isOfType('bigint');
	// eslint-disable-next-line @typescript-eslint/ban-types
	is.function_ = isOfType('function');
	is.null_ = (value) => value === null;
	is.class_ = (value) => is.function_(value) && value.toString().startsWith('class ');
	is.boolean = (value) => value === true || value === false;
	is.symbol = isOfType('symbol');
	is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
	is.array = (value, assertion) => {
	    if (!Array.isArray(value)) {
	        return false;
	    }
	    if (!is.function_(assertion)) {
	        return true;
	    }
	    return value.every(assertion);
	};
	is.buffer = (value) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false; };
	is.blob = (value) => isObjectOfType('Blob')(value);
	is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
	is.object = (value) => !is.null_(value) && (typeof value === 'object' || is.function_(value));
	is.iterable = (value) => { var _a; return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]); };
	is.asyncIterable = (value) => { var _a; return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]); };
	is.generator = (value) => { var _a, _b; return is.iterable(value) && is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.next) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.throw); };
	is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
	is.nativePromise = (value) => isObjectOfType('Promise')(value);
	const hasPromiseAPI = (value) => {
	    var _a, _b;
	    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) &&
	        is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
	};
	is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
	is.generatorFunction = isObjectOfType('GeneratorFunction');
	is.asyncGeneratorFunction = (value) => getObjectType(value) === 'AsyncGeneratorFunction';
	is.asyncFunction = (value) => getObjectType(value) === 'AsyncFunction';
	// eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types
	is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty('prototype');
	is.regExp = isObjectOfType('RegExp');
	is.date = isObjectOfType('Date');
	is.error = isObjectOfType('Error');
	is.map = (value) => isObjectOfType('Map')(value);
	is.set = (value) => isObjectOfType('Set')(value);
	is.weakMap = (value) => isObjectOfType('WeakMap')(value);
	is.weakSet = (value) => isObjectOfType('WeakSet')(value);
	is.int8Array = isObjectOfType('Int8Array');
	is.uint8Array = isObjectOfType('Uint8Array');
	is.uint8ClampedArray = isObjectOfType('Uint8ClampedArray');
	is.int16Array = isObjectOfType('Int16Array');
	is.uint16Array = isObjectOfType('Uint16Array');
	is.int32Array = isObjectOfType('Int32Array');
	is.uint32Array = isObjectOfType('Uint32Array');
	is.float32Array = isObjectOfType('Float32Array');
	is.float64Array = isObjectOfType('Float64Array');
	is.bigInt64Array = isObjectOfType('BigInt64Array');
	is.bigUint64Array = isObjectOfType('BigUint64Array');
	is.arrayBuffer = isObjectOfType('ArrayBuffer');
	is.sharedArrayBuffer = isObjectOfType('SharedArrayBuffer');
	is.dataView = isObjectOfType('DataView');
	is.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);
	is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
	is.urlInstance = (value) => isObjectOfType('URL')(value);
	is.urlString = (value) => {
	    if (!is.string(value)) {
	        return false;
	    }
	    try {
	        new URL(value); // eslint-disable-line no-new
	        return true;
	    }
	    catch (_a) {
	        return false;
	    }
	};
	// Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`
	is.truthy = (value) => Boolean(value);
	// Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`
	is.falsy = (value) => !value;
	is.nan = (value) => Number.isNaN(value);
	is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
	is.integer = (value) => Number.isInteger(value);
	is.safeInteger = (value) => Number.isSafeInteger(value);
	is.plainObject = (value) => {
	    // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
	    if (toString.call(value) !== '[object Object]') {
	        return false;
	    }
	    const prototype = Object.getPrototypeOf(value);
	    return prototype === null || prototype === Object.getPrototypeOf({});
	};
	is.typedArray = (value) => isTypedArrayName(getObjectType(value));
	const isValidLength = (value) => is.safeInteger(value) && value >= 0;
	is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
	is.inRange = (value, range) => {
	    if (is.number(range)) {
	        return value >= Math.min(0, range) && value <= Math.max(range, 0);
	    }
	    if (is.array(range) && range.length === 2) {
	        return value >= Math.min(...range) && value <= Math.max(...range);
	    }
	    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
	};
	const NODE_TYPE_ELEMENT = 1;
	const DOM_PROPERTIES_TO_CHECK = [
	    'innerHTML',
	    'ownerDocument',
	    'style',
	    'attributes',
	    'nodeValue'
	];
	is.domElement = (value) => {
	    return is.object(value) &&
	        value.nodeType === NODE_TYPE_ELEMENT &&
	        is.string(value.nodeName) &&
	        !is.plainObject(value) &&
	        DOM_PROPERTIES_TO_CHECK.every(property => property in value);
	};
	is.observable = (value) => {
	    var _a, _b, _c, _d;
	    if (!value) {
	        return false;
	    }
	    // eslint-disable-next-line no-use-extend-native/no-use-extend-native
	    if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
	        return true;
	    }
	    if (value === ((_d = (_c = value)['@@observable']) === null || _d === void 0 ? void 0 : _d.call(_c))) {
	        return true;
	    }
	    return false;
	};
	is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
	is.infinite = (value) => value === Infinity || value === -Infinity;
	const isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
	is.evenInteger = isAbsoluteMod2(0);
	is.oddInteger = isAbsoluteMod2(1);
	is.emptyArray = (value) => is.array(value) && value.length === 0;
	is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
	is.emptyString = (value) => is.string(value) && value.length === 0;
	const isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
	is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
	// TODO: Use `not ''` when the `not` operator is available.
	is.nonEmptyString = (value) => is.string(value) && value.length > 0;
	// TODO: Use `not ''` when the `not` operator is available.
	is.nonEmptyStringAndNotWhitespace = (value) => is.string(value) && !is.emptyStringOrWhitespace(value);
	is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
	// TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
	// - https://github.com/Microsoft/TypeScript/pull/29317
	is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
	is.emptySet = (value) => is.set(value) && value.size === 0;
	is.nonEmptySet = (value) => is.set(value) && value.size > 0;
	is.emptyMap = (value) => is.map(value) && value.size === 0;
	is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
	// `PropertyKey` is any value that can be used as an object key (string, number, or symbol)
	is.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);
	is.formData = (value) => isObjectOfType('FormData')(value);
	is.urlSearchParams = (value) => isObjectOfType('URLSearchParams')(value);
	const predicateOnArray = (method, predicate, values) => {
	    if (!is.function_(predicate)) {
	        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
	    }
	    if (values.length === 0) {
	        throw new TypeError('Invalid number of values');
	    }
	    return method.call(values, predicate);
	};
	is.any = (predicate, ...values) => {
	    const predicates = is.array(predicate) ? predicate : [predicate];
	    return predicates.some(singlePredicate => predicateOnArray(Array.prototype.some, singlePredicate, values));
	};
	is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
	const assertType = (condition, description, value, options = {}) => {
	    if (!condition) {
	        const { multipleValues } = options;
	        const valuesMessage = multipleValues ?
	            `received values of types ${[
	                ...new Set(value.map(singleValue => `\`${is(singleValue)}\``))
	            ].join(', ')}` :
	            `received value of type \`${is(value)}\``;
	        throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
	    }
	};
	exports.assert = {
	    // Unknowns.
	    undefined: (value) => assertType(is.undefined(value), 'undefined', value),
	    string: (value) => assertType(is.string(value), 'string', value),
	    number: (value) => assertType(is.number(value), 'number', value),
	    bigint: (value) => assertType(is.bigint(value), 'bigint', value),
	    // eslint-disable-next-line @typescript-eslint/ban-types
	    function_: (value) => assertType(is.function_(value), 'Function', value),
	    null_: (value) => assertType(is.null_(value), 'null', value),
	    class_: (value) => assertType(is.class_(value), "Class" /* class_ */, value),
	    boolean: (value) => assertType(is.boolean(value), 'boolean', value),
	    symbol: (value) => assertType(is.symbol(value), 'symbol', value),
	    numericString: (value) => assertType(is.numericString(value), "string with a number" /* numericString */, value),
	    array: (value, assertion) => {
	        const assert = assertType;
	        assert(is.array(value), 'Array', value);
	        if (assertion) {
	            value.forEach(assertion);
	        }
	    },
	    buffer: (value) => assertType(is.buffer(value), 'Buffer', value),
	    blob: (value) => assertType(is.blob(value), 'Blob', value),
	    nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined" /* nullOrUndefined */, value),
	    object: (value) => assertType(is.object(value), 'Object', value),
	    iterable: (value) => assertType(is.iterable(value), "Iterable" /* iterable */, value),
	    asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable" /* asyncIterable */, value),
	    generator: (value) => assertType(is.generator(value), 'Generator', value),
	    asyncGenerator: (value) => assertType(is.asyncGenerator(value), 'AsyncGenerator', value),
	    nativePromise: (value) => assertType(is.nativePromise(value), "native Promise" /* nativePromise */, value),
	    promise: (value) => assertType(is.promise(value), 'Promise', value),
	    generatorFunction: (value) => assertType(is.generatorFunction(value), 'GeneratorFunction', value),
	    asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), 'AsyncGeneratorFunction', value),
	    // eslint-disable-next-line @typescript-eslint/ban-types
	    asyncFunction: (value) => assertType(is.asyncFunction(value), 'AsyncFunction', value),
	    // eslint-disable-next-line @typescript-eslint/ban-types
	    boundFunction: (value) => assertType(is.boundFunction(value), 'Function', value),
	    regExp: (value) => assertType(is.regExp(value), 'RegExp', value),
	    date: (value) => assertType(is.date(value), 'Date', value),
	    error: (value) => assertType(is.error(value), 'Error', value),
	    map: (value) => assertType(is.map(value), 'Map', value),
	    set: (value) => assertType(is.set(value), 'Set', value),
	    weakMap: (value) => assertType(is.weakMap(value), 'WeakMap', value),
	    weakSet: (value) => assertType(is.weakSet(value), 'WeakSet', value),
	    int8Array: (value) => assertType(is.int8Array(value), 'Int8Array', value),
	    uint8Array: (value) => assertType(is.uint8Array(value), 'Uint8Array', value),
	    uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), 'Uint8ClampedArray', value),
	    int16Array: (value) => assertType(is.int16Array(value), 'Int16Array', value),
	    uint16Array: (value) => assertType(is.uint16Array(value), 'Uint16Array', value),
	    int32Array: (value) => assertType(is.int32Array(value), 'Int32Array', value),
	    uint32Array: (value) => assertType(is.uint32Array(value), 'Uint32Array', value),
	    float32Array: (value) => assertType(is.float32Array(value), 'Float32Array', value),
	    float64Array: (value) => assertType(is.float64Array(value), 'Float64Array', value),
	    bigInt64Array: (value) => assertType(is.bigInt64Array(value), 'BigInt64Array', value),
	    bigUint64Array: (value) => assertType(is.bigUint64Array(value), 'BigUint64Array', value),
	    arrayBuffer: (value) => assertType(is.arrayBuffer(value), 'ArrayBuffer', value),
	    sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), 'SharedArrayBuffer', value),
	    dataView: (value) => assertType(is.dataView(value), 'DataView', value),
	    enumCase: (value, targetEnum) => assertType(is.enumCase(value, targetEnum), 'EnumCase', value),
	    urlInstance: (value) => assertType(is.urlInstance(value), 'URL', value),
	    urlString: (value) => assertType(is.urlString(value), "string with a URL" /* urlString */, value),
	    truthy: (value) => assertType(is.truthy(value), "truthy" /* truthy */, value),
	    falsy: (value) => assertType(is.falsy(value), "falsy" /* falsy */, value),
	    nan: (value) => assertType(is.nan(value), "NaN" /* nan */, value),
	    primitive: (value) => assertType(is.primitive(value), "primitive" /* primitive */, value),
	    integer: (value) => assertType(is.integer(value), "integer" /* integer */, value),
	    safeInteger: (value) => assertType(is.safeInteger(value), "integer" /* safeInteger */, value),
	    plainObject: (value) => assertType(is.plainObject(value), "plain object" /* plainObject */, value),
	    typedArray: (value) => assertType(is.typedArray(value), "TypedArray" /* typedArray */, value),
	    arrayLike: (value) => assertType(is.arrayLike(value), "array-like" /* arrayLike */, value),
	    domElement: (value) => assertType(is.domElement(value), "HTMLElement" /* domElement */, value),
	    observable: (value) => assertType(is.observable(value), 'Observable', value),
	    nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream" /* nodeStream */, value),
	    infinite: (value) => assertType(is.infinite(value), "infinite number" /* infinite */, value),
	    emptyArray: (value) => assertType(is.emptyArray(value), "empty array" /* emptyArray */, value),
	    nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array" /* nonEmptyArray */, value),
	    emptyString: (value) => assertType(is.emptyString(value), "empty string" /* emptyString */, value),
	    emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace" /* emptyStringOrWhitespace */, value),
	    nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string" /* nonEmptyString */, value),
	    nonEmptyStringAndNotWhitespace: (value) => assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace" /* nonEmptyStringAndNotWhitespace */, value),
	    emptyObject: (value) => assertType(is.emptyObject(value), "empty object" /* emptyObject */, value),
	    nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object" /* nonEmptyObject */, value),
	    emptySet: (value) => assertType(is.emptySet(value), "empty set" /* emptySet */, value),
	    nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set" /* nonEmptySet */, value),
	    emptyMap: (value) => assertType(is.emptyMap(value), "empty map" /* emptyMap */, value),
	    nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map" /* nonEmptyMap */, value),
	    propertyKey: (value) => assertType(is.propertyKey(value), 'PropertyKey', value),
	    formData: (value) => assertType(is.formData(value), 'FormData', value),
	    urlSearchParams: (value) => assertType(is.urlSearchParams(value), 'URLSearchParams', value),
	    // Numbers.
	    evenInteger: (value) => assertType(is.evenInteger(value), "even integer" /* evenInteger */, value),
	    oddInteger: (value) => assertType(is.oddInteger(value), "odd integer" /* oddInteger */, value),
	    // Two arguments.
	    directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T" /* directInstanceOf */, instance),
	    inRange: (value, range) => assertType(is.inRange(value, range), "in range" /* inRange */, value),
	    // Variadic functions.
	    any: (predicate, ...values) => {
	        return assertType(is.any(predicate, ...values), "predicate returns truthy for any value" /* any */, values, { multipleValues: true });
	    },
	    all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values" /* all */, values, { multipleValues: true })
	};
	// Some few keywords are reserved, but we'll populate them for Node.js users
	// See https://github.com/Microsoft/TypeScript/issues/2536
	Object.defineProperties(is, {
	    class: {
	        value: is.class_
	    },
	    function: {
	        value: is.function_
	    },
	    null: {
	        value: is.null_
	    }
	});
	Object.defineProperties(exports.assert, {
	    class: {
	        value: exports.assert.class_
	    },
	    function: {
	        value: exports.assert.function_
	    },
	    null: {
	        value: exports.assert.null_
	    }
	});
	exports.default = is;
	// For CommonJS default export support
	module.exports = is;
	module.exports.default = is;
	module.exports.assert = exports.assert; 
} (dist$1, dist$1.exports));

var distExports = dist$1.exports;

var asPromise = {};

var pCancelable = {exports: {}};

var hasRequiredPCancelable;

function requirePCancelable () {
	if (hasRequiredPCancelable) return pCancelable.exports;
	hasRequiredPCancelable = 1;

	class CancelError extends Error {
		constructor(reason) {
			super(reason || 'Promise was canceled');
			this.name = 'CancelError';
		}

		get isCanceled() {
			return true;
		}
	}

	class PCancelable {
		static fn(userFn) {
			return (...arguments_) => {
				return new PCancelable((resolve, reject, onCancel) => {
					arguments_.push(onCancel);
					// eslint-disable-next-line promise/prefer-await-to-then
					userFn(...arguments_).then(resolve, reject);
				});
			};
		}

		constructor(executor) {
			this._cancelHandlers = [];
			this._isPending = true;
			this._isCanceled = false;
			this._rejectOnCancel = true;

			this._promise = new Promise((resolve, reject) => {
				this._reject = reject;

				const onResolve = value => {
					if (!this._isCanceled || !onCancel.shouldReject) {
						this._isPending = false;
						resolve(value);
					}
				};

				const onReject = error => {
					this._isPending = false;
					reject(error);
				};

				const onCancel = handler => {
					if (!this._isPending) {
						throw new Error('The `onCancel` handler was attached after the promise settled.');
					}

					this._cancelHandlers.push(handler);
				};

				Object.defineProperties(onCancel, {
					shouldReject: {
						get: () => this._rejectOnCancel,
						set: boolean => {
							this._rejectOnCancel = boolean;
						}
					}
				});

				return executor(onResolve, onReject, onCancel);
			});
		}

		then(onFulfilled, onRejected) {
			// eslint-disable-next-line promise/prefer-await-to-then
			return this._promise.then(onFulfilled, onRejected);
		}

		catch(onRejected) {
			return this._promise.catch(onRejected);
		}

		finally(onFinally) {
			return this._promise.finally(onFinally);
		}

		cancel(reason) {
			if (!this._isPending || this._isCanceled) {
				return;
			}

			this._isCanceled = true;

			if (this._cancelHandlers.length > 0) {
				try {
					for (const handler of this._cancelHandlers) {
						handler();
					}
				} catch (error) {
					this._reject(error);
					return;
				}
			}

			if (this._rejectOnCancel) {
				this._reject(new CancelError(reason));
			}
		}

		get isCanceled() {
			return this._isCanceled;
		}
	}

	Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

	pCancelable.exports = PCancelable;
	pCancelable.exports.CancelError = CancelError;
	return pCancelable.exports;
}

var types$1 = {};

var core = {};

var source$3 = {exports: {}};

var source$2 = {exports: {}};

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	function isTLSSocket(socket) {
	    return socket.encrypted;
	}
	const deferToConnect = (socket, fn) => {
	    let listeners;
	    if (typeof fn === 'function') {
	        const connect = fn;
	        listeners = { connect };
	    }
	    else {
	        listeners = fn;
	    }
	    const hasConnectListener = typeof listeners.connect === 'function';
	    const hasSecureConnectListener = typeof listeners.secureConnect === 'function';
	    const hasCloseListener = typeof listeners.close === 'function';
	    const onConnect = () => {
	        if (hasConnectListener) {
	            listeners.connect();
	        }
	        if (isTLSSocket(socket) && hasSecureConnectListener) {
	            if (socket.authorized) {
	                listeners.secureConnect();
	            }
	            else if (!socket.authorizationError) {
	                socket.once('secureConnect', listeners.secureConnect);
	            }
	        }
	        if (hasCloseListener) {
	            socket.once('close', listeners.close);
	        }
	    };
	    if (socket.writable && !socket.connecting) {
	        onConnect();
	    }
	    else if (socket.connecting) {
	        socket.once('connect', onConnect);
	    }
	    else if (socket.destroyed && hasCloseListener) {
	        listeners.close(socket._hadError);
	    }
	};
	exports.default = deferToConnect;
	// For CommonJS default export support
	module.exports = deferToConnect;
	module.exports.default = deferToConnect; 
} (source$2, source$2.exports));

var sourceExports$3 = source$2.exports;

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const defer_to_connect_1 = sourceExports$3;
	const util_1 = require$$1;
	const nodejsMajorVersion = Number(process.versions.node.split('.')[0]);
	const timer = (request) => {
	    if (request.timings) {
	        return request.timings;
	    }
	    const timings = {
	        start: Date.now(),
	        socket: undefined,
	        lookup: undefined,
	        connect: undefined,
	        secureConnect: undefined,
	        upload: undefined,
	        response: undefined,
	        end: undefined,
	        error: undefined,
	        abort: undefined,
	        phases: {
	            wait: undefined,
	            dns: undefined,
	            tcp: undefined,
	            tls: undefined,
	            request: undefined,
	            firstByte: undefined,
	            download: undefined,
	            total: undefined
	        }
	    };
	    request.timings = timings;
	    const handleError = (origin) => {
	        const emit = origin.emit.bind(origin);
	        origin.emit = (event, ...args) => {
	            // Catches the `error` event
	            if (event === 'error') {
	                timings.error = Date.now();
	                timings.phases.total = timings.error - timings.start;
	                origin.emit = emit;
	            }
	            // Saves the original behavior
	            return emit(event, ...args);
	        };
	    };
	    handleError(request);
	    const onAbort = () => {
	        timings.abort = Date.now();
	        // Let the `end` response event be responsible for setting the total phase,
	        // unless the Node.js major version is >= 13.
	        if (!timings.response || nodejsMajorVersion >= 13) {
	            timings.phases.total = Date.now() - timings.start;
	        }
	    };
	    request.prependOnceListener('abort', onAbort);
	    const onSocket = (socket) => {
	        timings.socket = Date.now();
	        timings.phases.wait = timings.socket - timings.start;
	        if (util_1.types.isProxy(socket)) {
	            return;
	        }
	        const lookupListener = () => {
	            timings.lookup = Date.now();
	            timings.phases.dns = timings.lookup - timings.socket;
	        };
	        socket.prependOnceListener('lookup', lookupListener);
	        defer_to_connect_1.default(socket, {
	            connect: () => {
	                timings.connect = Date.now();
	                if (timings.lookup === undefined) {
	                    socket.removeListener('lookup', lookupListener);
	                    timings.lookup = timings.connect;
	                    timings.phases.dns = timings.lookup - timings.socket;
	                }
	                timings.phases.tcp = timings.connect - timings.lookup;
	                // This callback is called before flushing any data,
	                // so we don't need to set `timings.phases.request` here.
	            },
	            secureConnect: () => {
	                timings.secureConnect = Date.now();
	                timings.phases.tls = timings.secureConnect - timings.connect;
	            }
	        });
	    };
	    if (request.socket) {
	        onSocket(request.socket);
	    }
	    else {
	        request.prependOnceListener('socket', onSocket);
	    }
	    const onUpload = () => {
	        var _a;
	        timings.upload = Date.now();
	        timings.phases.request = timings.upload - ((_a = timings.secureConnect) !== null && _a !== void 0 ? _a : timings.connect);
	    };
	    const writableFinished = () => {
	        if (typeof request.writableFinished === 'boolean') {
	            return request.writableFinished;
	        }
	        // Node.js doesn't have `request.writableFinished` property
	        return request.finished && request.outputSize === 0 && (!request.socket || request.socket.writableLength === 0);
	    };
	    if (writableFinished()) {
	        onUpload();
	    }
	    else {
	        request.prependOnceListener('finish', onUpload);
	    }
	    request.prependOnceListener('response', (response) => {
	        timings.response = Date.now();
	        timings.phases.firstByte = timings.response - timings.upload;
	        response.timings = timings;
	        handleError(response);
	        response.prependOnceListener('end', () => {
	            timings.end = Date.now();
	            timings.phases.download = timings.end - timings.response;
	            timings.phases.total = timings.end - timings.start;
	        });
	        response.prependOnceListener('aborted', onAbort);
	    });
	    return timings;
	};
	exports.default = timer;
	// For CommonJS default export support
	module.exports = timer;
	module.exports.default = timer; 
} (source$3, source$3.exports));

var sourceExports$2 = source$3.exports;

var source$1 = {exports: {}};

const {
	V4MAPPED,
	ADDRCONFIG,
	ALL,
	promises: {
		Resolver: AsyncResolver
	},
	lookup: dnsLookup
} = require$$0$1;
const {promisify} = require$$1;
const os = require$$2$1;

const kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');
const kCacheableLookupInstance = Symbol('cacheableLookupInstance');
const kExpires = Symbol('expires');

const supportsALL = typeof ALL === 'number';

const verifyAgent = agent => {
	if (!(agent && typeof agent.createConnection === 'function')) {
		throw new Error('Expected an Agent instance as the first argument');
	}
};

const map4to6 = entries => {
	for (const entry of entries) {
		if (entry.family === 6) {
			continue;
		}

		entry.address = `::ffff:${entry.address}`;
		entry.family = 6;
	}
};

const getIfaceInfo = () => {
	let has4 = false;
	let has6 = false;

	for (const device of Object.values(os.networkInterfaces())) {
		for (const iface of device) {
			if (iface.internal) {
				continue;
			}

			if (iface.family === 'IPv6') {
				has6 = true;
			} else {
				has4 = true;
			}

			if (has4 && has6) {
				return {has4, has6};
			}
		}
	}

	return {has4, has6};
};

const isIterable = map => {
	return Symbol.iterator in map;
};

const ttl = {ttl: true};
const all = {all: true};

class CacheableLookup {
	constructor({
		cache = new Map(),
		maxTtl = Infinity,
		fallbackDuration = 3600,
		errorTtl = 0.15,
		resolver = new AsyncResolver(),
		lookup = dnsLookup
	} = {}) {
		this.maxTtl = maxTtl;
		this.errorTtl = errorTtl;

		this._cache = cache;
		this._resolver = resolver;
		this._dnsLookup = promisify(lookup);

		if (this._resolver instanceof AsyncResolver) {
			this._resolve4 = this._resolver.resolve4.bind(this._resolver);
			this._resolve6 = this._resolver.resolve6.bind(this._resolver);
		} else {
			this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));
			this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));
		}

		this._iface = getIfaceInfo();

		this._pending = {};
		this._nextRemovalTime = false;
		this._hostnamesToFallback = new Set();

		if (fallbackDuration < 1) {
			this._fallback = false;
		} else {
			this._fallback = true;

			const interval = setInterval(() => {
				this._hostnamesToFallback.clear();
			}, fallbackDuration * 1000);

			/* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */
			if (interval.unref) {
				interval.unref();
			}
		}

		this.lookup = this.lookup.bind(this);
		this.lookupAsync = this.lookupAsync.bind(this);
	}

	set servers(servers) {
		this.clear();

		this._resolver.setServers(servers);
	}

	get servers() {
		return this._resolver.getServers();
	}

	lookup(hostname, options, callback) {
		if (typeof options === 'function') {
			callback = options;
			options = {};
		} else if (typeof options === 'number') {
			options = {
				family: options
			};
		}

		if (!callback) {
			throw new Error('Callback must be a function.');
		}

		// eslint-disable-next-line promise/prefer-await-to-then
		this.lookupAsync(hostname, options).then(result => {
			if (options.all) {
				callback(null, result);
			} else {
				callback(null, result.address, result.family, result.expires, result.ttl);
			}
		}, callback);
	}

	async lookupAsync(hostname, options = {}) {
		if (typeof options === 'number') {
			options = {
				family: options
			};
		}

		let cached = await this.query(hostname);

		if (options.family === 6) {
			const filtered = cached.filter(entry => entry.family === 6);

			if (options.hints & V4MAPPED) {
				if ((supportsALL && options.hints & ALL) || filtered.length === 0) {
					map4to6(cached);
				} else {
					cached = filtered;
				}
			} else {
				cached = filtered;
			}
		} else if (options.family === 4) {
			cached = cached.filter(entry => entry.family === 4);
		}

		if (options.hints & ADDRCONFIG) {
			const {_iface} = this;
			cached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);
		}

		if (cached.length === 0) {
			const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
			error.code = 'ENOTFOUND';
			error.hostname = hostname;

			throw error;
		}

		if (options.all) {
			return cached;
		}

		return cached[0];
	}

	async query(hostname) {
		let cached = await this._cache.get(hostname);

		if (!cached) {
			const pending = this._pending[hostname];

			if (pending) {
				cached = await pending;
			} else {
				const newPromise = this.queryAndCache(hostname);
				this._pending[hostname] = newPromise;

				try {
					cached = await newPromise;
				} finally {
					delete this._pending[hostname];
				}
			}
		}

		cached = cached.map(entry => {
			return {...entry};
		});

		return cached;
	}

	async _resolve(hostname) {
		const wrap = async promise => {
			try {
				return await promise;
			} catch (error) {
				if (error.code === 'ENODATA' || error.code === 'ENOTFOUND') {
					return [];
				}

				throw error;
			}
		};

		// ANY is unsafe as it doesn't trigger new queries in the underlying server.
		const [A, AAAA] = await Promise.all([
			this._resolve4(hostname, ttl),
			this._resolve6(hostname, ttl)
		].map(promise => wrap(promise)));

		let aTtl = 0;
		let aaaaTtl = 0;
		let cacheTtl = 0;

		const now = Date.now();

		for (const entry of A) {
			entry.family = 4;
			entry.expires = now + (entry.ttl * 1000);

			aTtl = Math.max(aTtl, entry.ttl);
		}

		for (const entry of AAAA) {
			entry.family = 6;
			entry.expires = now + (entry.ttl * 1000);

			aaaaTtl = Math.max(aaaaTtl, entry.ttl);
		}

		if (A.length > 0) {
			if (AAAA.length > 0) {
				cacheTtl = Math.min(aTtl, aaaaTtl);
			} else {
				cacheTtl = aTtl;
			}
		} else {
			cacheTtl = aaaaTtl;
		}

		return {
			entries: [
				...A,
				...AAAA
			],
			cacheTtl
		};
	}

	async _lookup(hostname) {
		try {
			const entries = await this._dnsLookup(hostname, {
				all: true
			});

			return {
				entries,
				cacheTtl: 0
			};
		} catch (_) {
			return {
				entries: [],
				cacheTtl: 0
			};
		}
	}

	async _set(hostname, data, cacheTtl) {
		if (this.maxTtl > 0 && cacheTtl > 0) {
			cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;
			data[kExpires] = Date.now() + cacheTtl;

			try {
				await this._cache.set(hostname, data, cacheTtl);
			} catch (error) {
				this.lookupAsync = async () => {
					const cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');
					cacheError.cause = error;

					throw cacheError;
				};
			}

			if (isIterable(this._cache)) {
				this._tick(cacheTtl);
			}
		}
	}

	async queryAndCache(hostname) {
		if (this._hostnamesToFallback.has(hostname)) {
			return this._dnsLookup(hostname, all);
		}

		let query = await this._resolve(hostname);

		if (query.entries.length === 0 && this._fallback) {
			query = await this._lookup(hostname);

			if (query.entries.length !== 0) {
				// Use `dns.lookup(...)` for that particular hostname
				this._hostnamesToFallback.add(hostname);
			}
		}

		const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
		await this._set(hostname, query.entries, cacheTtl);

		return query.entries;
	}

	_tick(ms) {
		const nextRemovalTime = this._nextRemovalTime;

		if (!nextRemovalTime || ms < nextRemovalTime) {
			clearTimeout(this._removalTimeout);

			this._nextRemovalTime = ms;

			this._removalTimeout = setTimeout(() => {
				this._nextRemovalTime = false;

				let nextExpiry = Infinity;

				const now = Date.now();

				for (const [hostname, entries] of this._cache) {
					const expires = entries[kExpires];

					if (now >= expires) {
						this._cache.delete(hostname);
					} else if (expires < nextExpiry) {
						nextExpiry = expires;
					}
				}

				if (nextExpiry !== Infinity) {
					this._tick(nextExpiry - now);
				}
			}, ms);

			/* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */
			if (this._removalTimeout.unref) {
				this._removalTimeout.unref();
			}
		}
	}

	install(agent) {
		verifyAgent(agent);

		if (kCacheableLookupCreateConnection in agent) {
			throw new Error('CacheableLookup has been already installed');
		}

		agent[kCacheableLookupCreateConnection] = agent.createConnection;
		agent[kCacheableLookupInstance] = this;

		agent.createConnection = (options, callback) => {
			if (!('lookup' in options)) {
				options.lookup = this.lookup;
			}

			return agent[kCacheableLookupCreateConnection](options, callback);
		};
	}

	uninstall(agent) {
		verifyAgent(agent);

		if (agent[kCacheableLookupCreateConnection]) {
			if (agent[kCacheableLookupInstance] !== this) {
				throw new Error('The agent is not owned by this CacheableLookup instance');
			}

			agent.createConnection = agent[kCacheableLookupCreateConnection];

			delete agent[kCacheableLookupCreateConnection];
			delete agent[kCacheableLookupInstance];
		}
	}

	updateInterfaceInfo() {
		const {_iface} = this;

		this._iface = getIfaceInfo();

		if ((_iface.has4 && !this._iface.has4) || (_iface.has6 && !this._iface.has6)) {
			this._cache.clear();
		}
	}

	clear(hostname) {
		if (hostname) {
			this._cache.delete(hostname);
			return;
		}

		this._cache.clear();
	}
}

source$1.exports = CacheableLookup;
source$1.exports.default = CacheableLookup;

var sourceExports$1 = source$1.exports;

// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
const DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';
const DATA_URL_DEFAULT_CHARSET = 'us-ascii';

const testParameter = (name, filters) => {
	return filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);
};

const normalizeDataURL = (urlString, {stripHash}) => {
	const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);

	if (!match) {
		throw new Error(`Invalid URL: ${urlString}`);
	}

	let {type, data, hash} = match.groups;
	const mediaType = type.split(';');
	hash = stripHash ? '' : hash;

	let isBase64 = false;
	if (mediaType[mediaType.length - 1] === 'base64') {
		mediaType.pop();
		isBase64 = true;
	}

	// Lowercase MIME type
	const mimeType = (mediaType.shift() || '').toLowerCase();
	const attributes = mediaType
		.map(attribute => {
			let [key, value = ''] = attribute.split('=').map(string => string.trim());

			// Lowercase `charset`
			if (key === 'charset') {
				value = value.toLowerCase();

				if (value === DATA_URL_DEFAULT_CHARSET) {
					return '';
				}
			}

			return `${key}${value ? `=${value}` : ''}`;
		})
		.filter(Boolean);

	const normalizedMediaType = [
		...attributes
	];

	if (isBase64) {
		normalizedMediaType.push('base64');
	}

	if (normalizedMediaType.length !== 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {
		normalizedMediaType.unshift(mimeType);
	}

	return `data:${normalizedMediaType.join(';')},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ''}`;
};

const normalizeUrl$1 = (urlString, options) => {
	options = {
		defaultProtocol: 'http:',
		normalizeProtocol: true,
		forceHttp: false,
		forceHttps: false,
		stripAuthentication: true,
		stripHash: false,
		stripTextFragment: true,
		stripWWW: true,
		removeQueryParameters: [/^utm_\w+/i],
		removeTrailingSlash: true,
		removeSingleSlash: true,
		removeDirectoryIndex: false,
		sortQueryParameters: true,
		...options
	};

	urlString = urlString.trim();

	// Data URL
	if (/^data:/i.test(urlString)) {
		return normalizeDataURL(urlString, options);
	}

	if (/^view-source:/i.test(urlString)) {
		throw new Error('`view-source:` is not supported as it is a non-standard protocol');
	}

	const hasRelativeProtocol = urlString.startsWith('//');
	const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);

	// Prepend protocol
	if (!isRelativeUrl) {
		urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
	}

	const urlObj = new URL(urlString);

	if (options.forceHttp && options.forceHttps) {
		throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
	}

	if (options.forceHttp && urlObj.protocol === 'https:') {
		urlObj.protocol = 'http:';
	}

	if (options.forceHttps && urlObj.protocol === 'http:') {
		urlObj.protocol = 'https:';
	}

	// Remove auth
	if (options.stripAuthentication) {
		urlObj.username = '';
		urlObj.password = '';
	}

	// Remove hash
	if (options.stripHash) {
		urlObj.hash = '';
	} else if (options.stripTextFragment) {
		urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, '');
	}

	// Remove duplicate slashes if not preceded by a protocol
	if (urlObj.pathname) {
		urlObj.pathname = urlObj.pathname.replace(/(?<!\b(?:[a-z][a-z\d+\-.]{1,50}:))\/{2,}/g, '/');
	}

	// Decode URI octets
	if (urlObj.pathname) {
		try {
			urlObj.pathname = decodeURI(urlObj.pathname);
		} catch (_) {}
	}

	// Remove directory index
	if (options.removeDirectoryIndex === true) {
		options.removeDirectoryIndex = [/^index\.[a-z]+$/];
	}

	if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
		let pathComponents = urlObj.pathname.split('/');
		const lastComponent = pathComponents[pathComponents.length - 1];

		if (testParameter(lastComponent, options.removeDirectoryIndex)) {
			pathComponents = pathComponents.slice(0, pathComponents.length - 1);
			urlObj.pathname = pathComponents.slice(1).join('/') + '/';
		}
	}

	if (urlObj.hostname) {
		// Remove trailing dot
		urlObj.hostname = urlObj.hostname.replace(/\.$/, '');

		// Remove `www.`
		if (options.stripWWW && /^www\.(?!www\.)(?:[a-z\-\d]{1,63})\.(?:[a-z.\-\d]{2,63})$/.test(urlObj.hostname)) {
			// Each label should be max 63 at length (min: 1).
			// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
			// Each TLD should be up to 63 characters long (min: 2).
			// It is technically possible to have a single character TLD, but none currently exist.
			urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
		}
	}

	// Remove query unwanted parameters
	if (Array.isArray(options.removeQueryParameters)) {
		for (const key of [...urlObj.searchParams.keys()]) {
			if (testParameter(key, options.removeQueryParameters)) {
				urlObj.searchParams.delete(key);
			}
		}
	}

	if (options.removeQueryParameters === true) {
		urlObj.search = '';
	}

	// Sort query parameters
	if (options.sortQueryParameters) {
		urlObj.searchParams.sort();
	}

	if (options.removeTrailingSlash) {
		urlObj.pathname = urlObj.pathname.replace(/\/$/, '');
	}

	const oldUrlString = urlString;

	// Take advantage of many of the Node `url` normalizations
	urlString = urlObj.toString();

	if (!options.removeSingleSlash && urlObj.pathname === '/' && !oldUrlString.endsWith('/') && urlObj.hash === '') {
		urlString = urlString.replace(/\/$/, '');
	}

	// Remove ending `/` unless removeSingleSlash is false
	if ((options.removeTrailingSlash || urlObj.pathname === '/') && urlObj.hash === '' && options.removeSingleSlash) {
		urlString = urlString.replace(/\/$/, '');
	}

	// Restore relative protocol, if applicable
	if (hasRelativeProtocol && !options.normalizeProtocol) {
		urlString = urlString.replace(/^http:\/\//, '//');
	}

	// Remove http/https
	if (options.stripProtocol) {
		urlString = urlString.replace(/^(?:https?:)?\/\//, '');
	}

	return urlString;
};

var normalizeUrl_1 = normalizeUrl$1;

var getStream$2 = {exports: {}};

var once$3 = {exports: {}};

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
var wrappy_1 = wrappy$1;
function wrappy$1 (fn, cb) {
  if (fn && cb) return wrappy$1(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb = args[args.length-1];
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }
    return ret
  }
}

var wrappy = wrappy_1;
once$3.exports = wrappy(once$2);
once$3.exports.strict = wrappy(onceStrict);

once$2.proto = once$2(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once$2(this)
    },
    configurable: true
  });

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  });
});

function once$2 (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  f.called = false;
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f
}

var onceExports = once$3.exports;

var once$1 = onceExports;

var noop$3 = function() {};

var isRequest$1 = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos$1 = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos$1(stream, null, opts);
	if (!opts) opts = {};

	callback = once$1(callback || noop$3);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest$1(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

var endOfStream = eos$1;

var _nodeResolve_empty = {};

var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: _nodeResolve_empty
});

var require$$2 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

var once = onceExports;
var eos = endOfStream;
var fs = require$$2; // we only need fs to get the ReadStream and WriteStream prototypes

var noop$2 = function () {};
var ancient = /^v?\.0/.test(process.version);

var isFn = function (fn) {
  return typeof fn === 'function'
};

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop$2) || stream instanceof (fs.WriteStream || noop$2)) && isFn(stream.close)
};

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
};

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback);

  var closed = false;
  stream.on('close', function () {
    closed = true;
  });

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true;
    callback();
  });

  var destroyed = false;
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true;

    if (isFS(stream)) return stream.close(noop$2) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'));
  }
};

var call = function (fn) {
  fn();
};

var pipe = function (from, to) {
  return from.pipe(to)
};

var pump$1 = function () {
  var streams = Array.prototype.slice.call(arguments);
  var callback = isFn(streams[streams.length - 1] || noop$2) && streams.pop() || noop$2;

  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return
      destroys.forEach(call);
      callback(error);
    })
  });

  return streams.reduce(pipe)
};

var pump_1 = pump$1;

const {PassThrough: PassThroughStream} = require$$0$2;

var bufferStream$1 = options => {
	options = {...options};

	const {array} = options;
	let {encoding} = options;
	const isBuffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || isBuffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (isBuffer) {
		encoding = null;
	}

	const stream = new PassThroughStream({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	let length = 0;
	const chunks = [];

	stream.on('data', chunk => {
		chunks.push(chunk);

		if (objectMode) {
			length = chunks.length;
		} else {
			length += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return chunks;
		}

		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
	};

	stream.getBufferedLength = () => length;

	return stream;
};

const {constants: BufferConstants} = require$$0$3;
const pump = pump_1;
const bufferStream = bufferStream$1;

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

async function getStream$1(inputStream, options) {
	if (!inputStream) {
		return Promise.reject(new Error('Expected a stream'));
	}

	options = {
		maxBuffer: Infinity,
		...options
	};

	const {maxBuffer} = options;

	let stream;
	await new Promise((resolve, reject) => {
		const rejectPromise = error => {
			// Don't retrieve an oversized buffer.
			if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
				error.bufferedData = stream.getBufferedValue();
			}

			reject(error);
		};

		stream = pump(inputStream, bufferStream(options), error => {
			if (error) {
				rejectPromise(error);
				return;
			}

			resolve();
		});

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	});

	return stream.getBufferedValue();
}

getStream$2.exports = getStream$1;
// TODO: Remove this for the next major release
getStream$2.exports.default = getStream$1;
getStream$2.exports.buffer = (stream, options) => getStream$1(stream, {...options, encoding: 'buffer'});
getStream$2.exports.array = (stream, options) => getStream$1(stream, {...options, array: true});
getStream$2.exports.MaxBufferError = MaxBufferError;

var getStreamExports = getStream$2.exports;

// rfc7231 6.1
const statusCodeCacheableByDefault = new Set([
    200,
    203,
    204,
    206,
    300,
    301,
    308,
    404,
    405,
    410,
    414,
    501,
]);

// This implementation does not understand partial responses (206)
const understoodStatuses = new Set([
    200,
    203,
    204,
    300,
    301,
    302,
    303,
    307,
    308,
    404,
    405,
    410,
    414,
    501,
]);

const errorStatusCodes = new Set([
    500,
    502,
    503, 
    504,
]);

const hopByHopHeaders = {
    date: true, // included, because we add Age update Date
    connection: true,
    'keep-alive': true,
    'proxy-authenticate': true,
    'proxy-authorization': true,
    te: true,
    trailer: true,
    'transfer-encoding': true,
    upgrade: true,
};

const excludedFromRevalidationUpdate = {
    // Since the old body is reused, it doesn't make sense to change properties of the body
    'content-length': true,
    'content-encoding': true,
    'transfer-encoding': true,
    'content-range': true,
};

function toNumberOrZero(s) {
    const n = parseInt(s, 10);
    return isFinite(n) ? n : 0;
}

// RFC 5861
function isErrorResponse(response) {
    // consider undefined response as faulty
    if(!response) {
        return true
    }
    return errorStatusCodes.has(response.status);
}

function parseCacheControl(header) {
    const cc = {};
    if (!header) return cc;

    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale
    const parts = header.trim().split(/,/);
    for (const part of parts) {
        const [k, v] = part.split(/=/, 2);
        cc[k.trim()] = v === undefined ? true : v.trim().replace(/^"|"$/g, '');
    }

    return cc;
}

function formatCacheControl(cc) {
    let parts = [];
    for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + '=' + v);
    }
    if (!parts.length) {
        return undefined;
    }
    return parts.join(', ');
}

var httpCacheSemantics = class CachePolicy {
    constructor(
        req,
        res,
        {
            shared,
            cacheHeuristic,
            immutableMinTimeToLive,
            ignoreCargoCult,
            _fromObject,
        } = {}
    ) {
        if (_fromObject) {
            this._fromObject(_fromObject);
            return;
        }

        if (!res || !res.headers) {
            throw Error('Response headers missing');
        }
        this._assertRequestHasHeaders(req);

        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic =
            undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE
        this._immutableMinTtl =
            undefined !== immutableMinTimeToLive
                ? immutableMinTimeToLive
                : 24 * 3600 * 1000;

        this._status = 'status' in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers['cache-control']);
        this._method = 'method' in req ? req.method : 'GET';
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used
        this._reqcc = parseCacheControl(req.headers['cache-control']);

        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
        // so there's no point stricly adhering to the blindly copy&pasted directives.
        if (
            ignoreCargoCult &&
            'pre-check' in this._rescc &&
            'post-check' in this._rescc
        ) {
            delete this._rescc['pre-check'];
            delete this._rescc['post-check'];
            delete this._rescc['no-cache'];
            delete this._rescc['no-store'];
            delete this._rescc['must-revalidate'];
            this._resHeaders = Object.assign({}, this._resHeaders, {
                'cache-control': formatCacheControl(this._rescc),
            });
            delete this._resHeaders.expires;
            delete this._resHeaders.pragma;
        }

        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
        // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).
        if (
            res.headers['cache-control'] == null &&
            /no-cache/.test(res.headers.pragma)
        ) {
            this._rescc['no-cache'] = true;
        }
    }

    now() {
        return Date.now();
    }

    storable() {
        // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
        return !!(
            !this._reqcc['no-store'] &&
            // A cache MUST NOT store a response to any request, unless:
            // The request method is understood by the cache and defined as being cacheable, and
            ('GET' === this._method ||
                'HEAD' === this._method ||
                ('POST' === this._method && this._hasExplicitExpiration())) &&
            // the response status code is understood by the cache, and
            understoodStatuses.has(this._status) &&
            // the "no-store" cache directive does not appear in request or response header fields, and
            !this._rescc['no-store'] &&
            // the "private" response directive does not appear in the response, if the cache is shared, and
            (!this._isShared || !this._rescc.private) &&
            // the Authorization header field does not appear in the request, if the cache is shared,
            (!this._isShared ||
                this._noAuthorization ||
                this._allowsStoringAuthenticated()) &&
            // the response either:
            // contains an Expires header field, or
            (this._resHeaders.expires ||
                // contains a max-age response directive, or
                // contains a s-maxage response directive and the cache is shared, or
                // contains a public response directive.
                this._rescc['max-age'] ||
                (this._isShared && this._rescc['s-maxage']) ||
                this._rescc.public ||
                // has a status code that is defined as cacheable by default
                statusCodeCacheableByDefault.has(this._status))
        );
    }

    _hasExplicitExpiration() {
        // 4.2.1 Calculating Freshness Lifetime
        return (
            (this._isShared && this._rescc['s-maxage']) ||
            this._rescc['max-age'] ||
            this._resHeaders.expires
        );
    }

    _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
            throw Error('Request headers missing');
        }
    }

    satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);

        // When presented with a request, a cache MUST NOT reuse a stored response, unless:
        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
        // unless the stored response is successfully validated (Section 4.3), and
        const requestCC = parseCacheControl(req.headers['cache-control']);
        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {
            return false;
        }

        if (requestCC['max-age'] && this.age() > requestCC['max-age']) {
            return false;
        }

        if (
            requestCC['min-fresh'] &&
            this.timeToLive() < 1000 * requestCC['min-fresh']
        ) {
            return false;
        }

        // the stored response is either:
        // fresh, or allowed to be served stale
        if (this.stale()) {
            const allowsStale =
                requestCC['max-stale'] &&
                !this._rescc['must-revalidate'] &&
                (true === requestCC['max-stale'] ||
                    requestCC['max-stale'] > this.age() - this.maxAge());
            if (!allowsStale) {
                return false;
            }
        }

        return this._requestMatches(req, false);
    }

    _requestMatches(req, allowHeadMethod) {
        // The presented effective request URI and that of the stored response match, and
        return (
            (!this._url || this._url === req.url) &&
            this._host === req.headers.host &&
            // the request method associated with the stored response allows it to be used for the presented request, and
            (!req.method ||
                this._method === req.method ||
                (allowHeadMethod && 'HEAD' === req.method)) &&
            // selecting header fields nominated by the stored response (if any) match those presented, and
            this._varyMatches(req)
        );
    }

    _allowsStoringAuthenticated() {
        //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
        return (
            this._rescc['must-revalidate'] ||
            this._rescc.public ||
            this._rescc['s-maxage']
        );
    }

    _varyMatches(req) {
        if (!this._resHeaders.vary) {
            return true;
        }

        // A Vary header field-value of "*" always fails to match
        if (this._resHeaders.vary === '*') {
            return false;
        }

        const fields = this._resHeaders.vary
            .trim()
            .toLowerCase()
            .split(/\s*,\s*/);
        for (const name of fields) {
            if (req.headers[name] !== this._reqHeaders[name]) return false;
        }
        return true;
    }

    _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
            if (hopByHopHeaders[name]) continue;
            headers[name] = inHeaders[name];
        }
        // 9.1.  Connection
        if (inHeaders.connection) {
            const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
            for (const name of tokens) {
                delete headers[name];
            }
        }
        if (headers.warning) {
            const warnings = headers.warning.split(/,/).filter(warning => {
                return !/^\s*1[0-9][0-9]/.test(warning);
            });
            if (!warnings.length) {
                delete headers.warning;
            } else {
                headers.warning = warnings.join(',').trim();
            }
        }
        return headers;
    }

    responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();

        // A cache SHOULD generate 113 warning if it heuristically chose a freshness
        // lifetime greater than 24 hours and the response's age is greater than 24 hours.
        if (
            age > 3600 * 24 &&
            !this._hasExplicitExpiration() &&
            this.maxAge() > 3600 * 24
        ) {
            headers.warning =
                (headers.warning ? `${headers.warning}, ` : '') +
                '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
    }

    /**
     * Value of the Date response header or current time if Date was invalid
     * @return timestamp
     */
    date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
            return serverDate;
        }
        return this._responseTime;
    }

    /**
     * Value of the Age header, in seconds, updated for the current time.
     * May be fractional.
     *
     * @return Number
     */
    age() {
        let age = this._ageValue();

        const residentTime = (this.now() - this._responseTime) / 1000;
        return age + residentTime;
    }

    _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
    }

    /**
     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
     *
     * For an up-to-date value, see `timeToLive()`.
     *
     * @return Number
     */
    maxAge() {
        if (!this.storable() || this._rescc['no-cache']) {
            return 0;
        }

        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
        // so this implementation requires explicit opt-in via public header
        if (
            this._isShared &&
            (this._resHeaders['set-cookie'] &&
                !this._rescc.public &&
                !this._rescc.immutable)
        ) {
            return 0;
        }

        if (this._resHeaders.vary === '*') {
            return 0;
        }

        if (this._isShared) {
            if (this._rescc['proxy-revalidate']) {
                return 0;
            }
            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.
            if (this._rescc['s-maxage']) {
                return toNumberOrZero(this._rescc['s-maxage']);
            }
        }

        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.
        if (this._rescc['max-age']) {
            return toNumberOrZero(this._rescc['max-age']);
        }

        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;

        const serverDate = this.date();
        if (this._resHeaders.expires) {
            const expires = Date.parse(this._resHeaders.expires);
            // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
            if (Number.isNaN(expires) || expires < serverDate) {
                return 0;
            }
            return Math.max(defaultMinTtl, (expires - serverDate) / 1000);
        }

        if (this._resHeaders['last-modified']) {
            const lastModified = Date.parse(this._resHeaders['last-modified']);
            if (isFinite(lastModified) && serverDate > lastModified) {
                return Math.max(
                    defaultMinTtl,
                    ((serverDate - lastModified) / 1000) * this._cacheHeuristic
                );
            }
        }

        return defaultMinTtl;
    }

    timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);
        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;
    }

    stale() {
        return this.maxAge() <= this.age();
    }

    _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();
    }

    useStaleWhileRevalidate() {
        return this.maxAge() + toNumberOrZero(this._rescc['stale-while-revalidate']) > this.age();
    }

    static fromObject(obj) {
        return new this(undefined, undefined, { _fromObject: obj });
    }

    _fromObject(obj) {
        if (this._responseTime) throw Error('Reinitialized');
        if (!obj || obj.v !== 1) throw Error('Invalid serialization');

        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl =
            obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
    }

    toObject() {
        return {
            v: 1,
            t: this._responseTime,
            sh: this._isShared,
            ch: this._cacheHeuristic,
            imm: this._immutableMinTtl,
            st: this._status,
            resh: this._resHeaders,
            rescc: this._rescc,
            m: this._method,
            u: this._url,
            h: this._host,
            a: this._noAuthorization,
            reqh: this._reqHeaders,
            reqcc: this._reqcc,
        };
    }

    /**
     * Headers for sending to the origin server to revalidate stale response.
     * Allows server to return 304 to allow reuse of the previous response.
     *
     * Hop by hop headers are always stripped.
     * Revalidation headers may be added or removed, depending on request.
     */
    revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);

        // This implementation does not understand range requests
        delete headers['if-range'];

        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
            // revalidation allowed via HEAD
            // not for the same resource, or wasn't allowed to be cached anyway
            delete headers['if-none-match'];
            delete headers['if-modified-since'];
            return headers;
        }

        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */
        if (this._resHeaders.etag) {
            headers['if-none-match'] = headers['if-none-match']
                ? `${headers['if-none-match']}, ${this._resHeaders.etag}`
                : this._resHeaders.etag;
        }

        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
        const forbidsWeakValidators =
            headers['accept-ranges'] ||
            headers['if-match'] ||
            headers['if-unmodified-since'] ||
            (this._method && this._method != 'GET');

        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
        Note: This implementation does not understand partial responses (206) */
        if (forbidsWeakValidators) {
            delete headers['if-modified-since'];

            if (headers['if-none-match']) {
                const etags = headers['if-none-match']
                    .split(/,/)
                    .filter(etag => {
                        return !/^\s*W\//.test(etag);
                    });
                if (!etags.length) {
                    delete headers['if-none-match'];
                } else {
                    headers['if-none-match'] = etags.join(',').trim();
                }
            }
        } else if (
            this._resHeaders['last-modified'] &&
            !headers['if-modified-since']
        ) {
            headers['if-modified-since'] = this._resHeaders['last-modified'];
        }

        return headers;
    }

    /**
     * Creates new CachePolicy with information combined from the previews response,
     * and the new revalidation response.
     *
     * Returns {policy, modified} where modified is a boolean indicating
     * whether the response body has been modified, and old cached body can't be used.
     *
     * @return {Object} {policy: CachePolicy, modified: Boolean}
     */
    revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if(this._useStaleIfError() && isErrorResponse(response)) {  // I consider the revalidation request unsuccessful
          return {
            modified: false,
            matches: false,
            policy: this,
          };
        }
        if (!response || !response.headers) {
            throw Error('Response headers missing');
        }

        // These aren't going to be supported exactly, since one CachePolicy object
        // doesn't know about all the other cached objects.
        let matches = false;
        if (response.status !== undefined && response.status != 304) {
            matches = false;
        } else if (
            response.headers.etag &&
            !/^\s*W\//.test(response.headers.etag)
        ) {
            // "All of the stored responses with the same strong validator are selected.
            // If none of the stored responses contain the same strong validator,
            // then the cache MUST NOT use the new response to update any stored responses."
            matches =
                this._resHeaders.etag &&
                this._resHeaders.etag.replace(/^\s*W\//, '') ===
                    response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
            // "If the new response contains a weak validator and that validator corresponds
            // to one of the cache's stored responses,
            // then the most recent of those matching stored responses is selected for update."
            matches =
                this._resHeaders.etag.replace(/^\s*W\//, '') ===
                response.headers.etag.replace(/^\s*W\//, '');
        } else if (this._resHeaders['last-modified']) {
            matches =
                this._resHeaders['last-modified'] ===
                response.headers['last-modified'];
        } else {
            // If the new response does not include any form of validator (such as in the case where
            // a client generates an If-Modified-Since request from a source other than the Last-Modified
            // response header field), and there is only one stored response, and that stored response also
            // lacks a validator, then that stored response is selected for update.
            if (
                !this._resHeaders.etag &&
                !this._resHeaders['last-modified'] &&
                !response.headers.etag &&
                !response.headers['last-modified']
            ) {
                matches = true;
            }
        }

        if (!matches) {
            return {
                policy: new this.constructor(request, response),
                // Client receiving 304 without body, even if it's invalid/mismatched has no option
                // but to reuse a cached body. We don't have a good way to tell clients to do
                // error recovery in such case.
                modified: response.status != 304,
                matches: false,
            };
        }

        // use other header fields provided in the 304 (Not Modified) response to replace all instances
        // of the corresponding header fields in the stored response.
        const headers = {};
        for (const k in this._resHeaders) {
            headers[k] =
                k in response.headers && !excludedFromRevalidationUpdate[k]
                    ? response.headers[k]
                    : this._resHeaders[k];
        }

        const newResponse = Object.assign({}, response, {
            status: this._status,
            method: this._method,
            headers,
        });
        return {
            policy: new this.constructor(request, newResponse, {
                shared: this._isShared,
                cacheHeuristic: this._cacheHeuristic,
                immutableMinTimeToLive: this._immutableMinTtl,
            }),
            modified: false,
            matches: true,
        };
    }
};

var lowercaseKeys$2 = object => {
	const result = {};

	for (const [key, value] of Object.entries(object)) {
		result[key.toLowerCase()] = value;
	}

	return result;
};

const Readable$1 = require$$0$2.Readable;
const lowercaseKeys$1 = lowercaseKeys$2;

let Response$1 = class Response extends Readable$1 {
	constructor(statusCode, headers, body, url) {
		if (typeof statusCode !== 'number') {
			throw new TypeError('Argument `statusCode` should be a number');
		}
		if (typeof headers !== 'object') {
			throw new TypeError('Argument `headers` should be an object');
		}
		if (!(body instanceof Buffer)) {
			throw new TypeError('Argument `body` should be a buffer');
		}
		if (typeof url !== 'string') {
			throw new TypeError('Argument `url` should be a string');
		}

		super();
		this.statusCode = statusCode;
		this.headers = lowercaseKeys$1(headers);
		this.body = body;
		this.url = url;
	}

	_read() {
		this.push(this.body);
		this.push(null);
	}
};

var src$3 = Response$1;

// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProps = [
	'destroy',
	'setTimeout',
	'socket',
	'headers',
	'trailers',
	'rawHeaders',
	'statusCode',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'rawTrailers',
	'statusMessage'
];

var mimicResponse$3 = (fromStream, toStream) => {
	const fromProps = new Set(Object.keys(fromStream).concat(knownProps));

	for (const prop of fromProps) {
		// Don't overwrite existing properties
		if (prop in toStream) {
			continue;
		}

		toStream[prop] = typeof fromStream[prop] === 'function' ? fromStream[prop].bind(fromStream) : fromStream[prop];
	}
};

const PassThrough$1 = require$$0$2.PassThrough;
const mimicResponse$2 = mimicResponse$3;

const cloneResponse$1 = response => {
	if (!(response && response.pipe)) {
		throw new TypeError('Parameter `response` must be a response stream.');
	}

	const clone = new PassThrough$1();
	mimicResponse$2(response, clone);

	return response.pipe(clone);
};

var src$2 = cloneResponse$1;

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var jsonBuffer = {};

//TODO: handle reviver/dehydrate function like normal
//and handle indentation, like normal.
//if anyone needs this... please send pull request.

jsonBuffer.stringify = function stringify (o) {
  if('undefined' == typeof o) return o

  if(o && Buffer.isBuffer(o))
    return JSON.stringify(':base64:' + o.toString('base64'))

  if(o && o.toJSON)
    o =  o.toJSON();

  if(o && 'object' === typeof o) {
    var s = '';
    var array = Array.isArray(o);
    s = array ? '[' : '{';
    var first = true;

    for(var k in o) {
      var ignore = 'function' == typeof o[k] || (!array && 'undefined' === typeof o[k]);
      if(Object.hasOwnProperty.call(o, k) && !ignore) {
        if(!first)
          s += ',';
        first = false;
        if (array) {
          if(o[k] == undefined)
            s += 'null';
          else
            s += stringify(o[k]);
        } else if (o[k] !== void(0)) {
          s += stringify(k) + ':' + stringify(o[k]);
        }
      }
    }

    s += array ? ']' : '}';

    return s
  } else if ('string' === typeof o) {
    return JSON.stringify(/^:/.test(o) ? ':' + o : o)
  } else if ('undefined' === typeof o) {
    return 'null';
  } else
    return JSON.stringify(o)
};

jsonBuffer.parse = function (s) {
  return JSON.parse(s, function (key, value) {
    if('string' === typeof value) {
      if(/^:base64:/.test(value))
        return Buffer.from(value.substring(8), 'base64')
      else
        return /^:/.test(value) ? value.substring(1) : value 
    }
    return value
  })
};

const EventEmitter$2 = require$$0$4;
const JSONB = jsonBuffer;

const loadStore = options => {
	const adapters = {
		redis: '@keyv/redis',
		rediss: '@keyv/redis',
		mongodb: '@keyv/mongo',
		mongo: '@keyv/mongo',
		sqlite: '@keyv/sqlite',
		postgresql: '@keyv/postgres',
		postgres: '@keyv/postgres',
		mysql: '@keyv/mysql',
		etcd: '@keyv/etcd',
		offline: '@keyv/offline',
		tiered: '@keyv/tiered',
	};
	if (options.adapter || options.uri) {
		const adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];
		return new (commonjsRequire(adapters[adapter]))(options);
	}

	return new Map();
};

const iterableAdapters = [
	'sqlite',
	'postgres',
	'mysql',
	'mongo',
	'redis',
	'tiered',
];

let Keyv$1 = class Keyv extends EventEmitter$2 {
	constructor(uri, {emitErrors = true, ...options} = {}) {
		super();
		this.opts = {
			namespace: 'keyv',
			serialize: JSONB.stringify,
			deserialize: JSONB.parse,
			...((typeof uri === 'string') ? {uri} : uri),
			...options,
		};

		if (!this.opts.store) {
			const adapterOptions = {...this.opts};
			this.opts.store = loadStore(adapterOptions);
		}

		if (this.opts.compression) {
			const compression = this.opts.compression;
			this.opts.serialize = compression.serialize.bind(compression);
			this.opts.deserialize = compression.deserialize.bind(compression);
		}

		if (typeof this.opts.store.on === 'function' && emitErrors) {
			this.opts.store.on('error', error => this.emit('error', error));
		}

		this.opts.store.namespace = this.opts.namespace;

		const generateIterator = iterator => async function * () {
			for await (const [key, raw] of typeof iterator === 'function'
				? iterator(this.opts.store.namespace)
				: iterator) {
				const data = await this.opts.deserialize(raw);
				if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {
					continue;
				}

				if (typeof data.expires === 'number' && Date.now() > data.expires) {
					this.delete(key);
					continue;
				}

				yield [this._getKeyUnprefix(key), data.value];
			}
		};

		// Attach iterators
		if (typeof this.opts.store[Symbol.iterator] === 'function' && this.opts.store instanceof Map) {
			this.iterator = generateIterator(this.opts.store);
		} else if (typeof this.opts.store.iterator === 'function' && this.opts.store.opts
			&& this._checkIterableAdaptar()) {
			this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
		}
	}

	_checkIterableAdaptar() {
		return iterableAdapters.includes(this.opts.store.opts.dialect)
			|| iterableAdapters.findIndex(element => this.opts.store.opts.url.includes(element)) >= 0;
	}

	_getKeyPrefix(key) {
		return `${this.opts.namespace}:${key}`;
	}

	_getKeyPrefixArray(keys) {
		return keys.map(key => `${this.opts.namespace}:${key}`);
	}

	_getKeyUnprefix(key) {
		return key
			.split(':')
			.splice(1)
			.join(':');
	}

	get(key, options) {
		const {store} = this.opts;
		const isArray = Array.isArray(key);
		const keyPrefixed = isArray ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
		if (isArray && store.getMany === undefined) {
			const promises = [];
			for (const key of keyPrefixed) {
				promises.push(Promise.resolve()
					.then(() => store.get(key))
					.then(data => (typeof data === 'string') ? this.opts.deserialize(data) : (this.opts.compression ? this.opts.deserialize(data) : data))
					.then(data => {
						if (data === undefined || data === null) {
							return undefined;
						}

						if (typeof data.expires === 'number' && Date.now() > data.expires) {
							return this.delete(key).then(() => undefined);
						}

						return (options && options.raw) ? data : data.value;
					}),
				);
			}

			return Promise.allSettled(promises)
				.then(values => {
					const data = [];
					for (const value of values) {
						data.push(value.value);
					}

					return data;
				});
		}

		return Promise.resolve()
			.then(() => isArray ? store.getMany(keyPrefixed) : store.get(keyPrefixed))
			.then(data => (typeof data === 'string') ? this.opts.deserialize(data) : (this.opts.compression ? this.opts.deserialize(data) : data))
			.then(data => {
				if (data === undefined || data === null) {
					return undefined;
				}

				if (isArray) {
					const result = [];

					for (let row of data) {
						if ((typeof row === 'string')) {
							row = this.opts.deserialize(row);
						}

						if (row === undefined || row === null) {
							result.push(undefined);
							continue;
						}

						if (typeof row.expires === 'number' && Date.now() > row.expires) {
							this.delete(key).then(() => undefined);
							result.push(undefined);
						} else {
							result.push((options && options.raw) ? row : row.value);
						}
					}

					return result;
				}

				if (typeof data.expires === 'number' && Date.now() > data.expires) {
					return this.delete(key).then(() => undefined);
				}

				return (options && options.raw) ? data : data.value;
			});
	}

	set(key, value, ttl) {
		const keyPrefixed = this._getKeyPrefix(key);
		if (typeof ttl === 'undefined') {
			ttl = this.opts.ttl;
		}

		if (ttl === 0) {
			ttl = undefined;
		}

		const {store} = this.opts;

		return Promise.resolve()
			.then(() => {
				const expires = (typeof ttl === 'number') ? (Date.now() + ttl) : null;
				if (typeof value === 'symbol') {
					this.emit('error', 'symbol cannot be serialized');
				}

				value = {value, expires};
				return this.opts.serialize(value);
			})
			.then(value => store.set(keyPrefixed, value, ttl))
			.then(() => true);
	}

	delete(key) {
		const {store} = this.opts;
		if (Array.isArray(key)) {
			const keyPrefixed = this._getKeyPrefixArray(key);
			if (store.deleteMany === undefined) {
				const promises = [];
				for (const key of keyPrefixed) {
					promises.push(store.delete(key));
				}

				return Promise.allSettled(promises)
					.then(values => values.every(x => x.value === true));
			}

			return Promise.resolve()
				.then(() => store.deleteMany(keyPrefixed));
		}

		const keyPrefixed = this._getKeyPrefix(key);
		return Promise.resolve()
			.then(() => store.delete(keyPrefixed));
	}

	clear() {
		const {store} = this.opts;
		return Promise.resolve()
			.then(() => store.clear());
	}

	has(key) {
		const keyPrefixed = this._getKeyPrefix(key);
		const {store} = this.opts;
		return Promise.resolve()
			.then(async () => {
				if (typeof store.has === 'function') {
					return store.has(keyPrefixed);
				}

				const value = await store.get(keyPrefixed);
				return value !== undefined;
			});
	}

	disconnect() {
		const {store} = this.opts;
		if (typeof store.disconnect === 'function') {
			return store.disconnect();
		}
	}
};

var src$1 = Keyv$1;

const EventEmitter$1 = require$$0$4;
const urlLib = require$$0$5;
const normalizeUrl = normalizeUrl_1;
const getStream = getStreamExports;
const CachePolicy = httpCacheSemantics;
const Response = src$3;
const lowercaseKeys = lowercaseKeys$2;
const cloneResponse = src$2;
const Keyv = src$1;

class CacheableRequest {
	constructor(request, cacheAdapter) {
		if (typeof request !== 'function') {
			throw new TypeError('Parameter `request` must be a function');
		}

		this.cache = new Keyv({
			uri: typeof cacheAdapter === 'string' && cacheAdapter,
			store: typeof cacheAdapter !== 'string' && cacheAdapter,
			namespace: 'cacheable-request'
		});

		return this.createCacheableRequest(request);
	}

	createCacheableRequest(request) {
		return (opts, cb) => {
			let url;
			if (typeof opts === 'string') {
				url = normalizeUrlObject(urlLib.parse(opts));
				opts = {};
			} else if (opts instanceof urlLib.URL) {
				url = normalizeUrlObject(urlLib.parse(opts.toString()));
				opts = {};
			} else {
				const [pathname, ...searchParts] = (opts.path || '').split('?');
				const search = searchParts.length > 0 ?
					`?${searchParts.join('?')}` :
					'';
				url = normalizeUrlObject({ ...opts, pathname, search });
			}

			opts = {
				headers: {},
				method: 'GET',
				cache: true,
				strictTtl: false,
				automaticFailover: false,
				...opts,
				...urlObjectToRequestOptions(url)
			};
			opts.headers = lowercaseKeys(opts.headers);

			const ee = new EventEmitter$1();
			const normalizedUrlString = normalizeUrl(
				urlLib.format(url),
				{
					stripWWW: false,
					removeTrailingSlash: false,
					stripAuthentication: false
				}
			);
			const key = `${opts.method}:${normalizedUrlString}`;
			let revalidate = false;
			let madeRequest = false;

			const makeRequest = opts => {
				madeRequest = true;
				let requestErrored = false;
				let requestErrorCallback;

				const requestErrorPromise = new Promise(resolve => {
					requestErrorCallback = () => {
						if (!requestErrored) {
							requestErrored = true;
							resolve();
						}
					};
				});

				const handler = response => {
					if (revalidate && !opts.forceRefresh) {
						response.status = response.statusCode;
						const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);
						if (!revalidatedPolicy.modified) {
							const headers = revalidatedPolicy.policy.responseHeaders();
							response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
							response.cachePolicy = revalidatedPolicy.policy;
							response.fromCache = true;
						}
					}

					if (!response.fromCache) {
						response.cachePolicy = new CachePolicy(opts, response, opts);
						response.fromCache = false;
					}

					let clonedResponse;
					if (opts.cache && response.cachePolicy.storable()) {
						clonedResponse = cloneResponse(response);

						(async () => {
							try {
								const bodyPromise = getStream.buffer(response);

								await Promise.race([
									requestErrorPromise,
									new Promise(resolve => response.once('end', resolve))
								]);

								if (requestErrored) {
									return;
								}

								const body = await bodyPromise;

								const value = {
									cachePolicy: response.cachePolicy.toObject(),
									url: response.url,
									statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
									body
								};

								let ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;
								if (opts.maxTtl) {
									ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;
								}

								await this.cache.set(key, value, ttl);
							} catch (error) {
								ee.emit('error', new CacheableRequest.CacheError(error));
							}
						})();
					} else if (opts.cache && revalidate) {
						(async () => {
							try {
								await this.cache.delete(key);
							} catch (error) {
								ee.emit('error', new CacheableRequest.CacheError(error));
							}
						})();
					}

					ee.emit('response', clonedResponse || response);
					if (typeof cb === 'function') {
						cb(clonedResponse || response);
					}
				};

				try {
					const req = request(opts, handler);
					req.once('error', requestErrorCallback);
					req.once('abort', requestErrorCallback);
					ee.emit('request', req);
				} catch (error) {
					ee.emit('error', new CacheableRequest.RequestError(error));
				}
			};

			(async () => {
				const get = async opts => {
					await Promise.resolve();

					const cacheEntry = opts.cache ? await this.cache.get(key) : undefined;
					if (typeof cacheEntry === 'undefined') {
						return makeRequest(opts);
					}

					const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
					if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {
						const headers = policy.responseHeaders();
						const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
						response.cachePolicy = policy;
						response.fromCache = true;

						ee.emit('response', response);
						if (typeof cb === 'function') {
							cb(response);
						}
					} else {
						revalidate = cacheEntry;
						opts.headers = policy.revalidationHeaders(opts);
						makeRequest(opts);
					}
				};

				const errorHandler = error => ee.emit('error', new CacheableRequest.CacheError(error));
				this.cache.once('error', errorHandler);
				ee.on('response', () => this.cache.removeListener('error', errorHandler));

				try {
					await get(opts);
				} catch (error) {
					if (opts.automaticFailover && !madeRequest) {
						makeRequest(opts);
					}

					ee.emit('error', new CacheableRequest.CacheError(error));
				}
			})();

			return ee;
		};
	}
}

function urlObjectToRequestOptions(url) {
	const options = { ...url };
	options.path = `${url.pathname || '/'}${url.search || ''}`;
	delete options.pathname;
	delete options.search;
	return options;
}

function normalizeUrlObject(url) {
	// If url was parsed by url.parse or new URL:
	// - hostname will be set
	// - host will be hostname[:port]
	// - port will be set if it was explicit in the parsed string
	// Otherwise, url was from request options:
	// - hostname or host may be set
	// - host shall not have port encoded
	return {
		protocol: url.protocol,
		auth: url.auth,
		hostname: url.hostname || url.host || 'localhost',
		port: url.port,
		pathname: url.pathname,
		search: url.search
	};
}

CacheableRequest.RequestError = class extends Error {
	constructor(error) {
		super(error.message);
		this.name = 'RequestError';
		Object.assign(this, error);
	}
};

CacheableRequest.CacheError = class extends Error {
	constructor(error) {
		super(error.message);
		this.name = 'CacheError';
		Object.assign(this, error);
	}
};

var src = CacheableRequest;

// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProperties = [
	'aborted',
	'complete',
	'headers',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'method',
	'rawHeaders',
	'rawTrailers',
	'setTimeout',
	'socket',
	'statusCode',
	'statusMessage',
	'trailers',
	'url'
];

var mimicResponse$1 = (fromStream, toStream) => {
	if (toStream._readableState.autoDestroy) {
		throw new Error('The second stream must have the `autoDestroy` option set to `false`');
	}

	const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));

	const properties = {};

	for (const property of fromProperties) {
		// Don't overwrite existing properties.
		if (property in toStream) {
			continue;
		}

		properties[property] = {
			get() {
				const value = fromStream[property];
				const isFunction = typeof value === 'function';

				return isFunction ? value.bind(fromStream) : value;
			},
			set(value) {
				fromStream[property] = value;
			},
			enumerable: true,
			configurable: false
		};
	}

	Object.defineProperties(toStream, properties);

	fromStream.once('aborted', () => {
		toStream.destroy();

		toStream.emit('aborted');
	});

	fromStream.once('close', () => {
		if (fromStream.complete) {
			if (toStream.readable) {
				toStream.once('end', () => {
					toStream.emit('close');
				});
			} else {
				toStream.emit('close');
			}
		} else {
			toStream.emit('close');
		}
	});

	return toStream;
};

const {Transform, PassThrough} = require$$0$2;
const zlib = require$$1$1;
const mimicResponse = mimicResponse$1;

var decompressResponse = response => {
	const contentEncoding = (response.headers['content-encoding'] || '').toLowerCase();

	if (!['gzip', 'deflate', 'br'].includes(contentEncoding)) {
		return response;
	}

	// TODO: Remove this when targeting Node.js 12.
	const isBrotli = contentEncoding === 'br';
	if (isBrotli && typeof zlib.createBrotliDecompress !== 'function') {
		response.destroy(new Error('Brotli is not supported on Node.js < 12'));
		return response;
	}

	let isEmpty = true;

	const checker = new Transform({
		transform(data, _encoding, callback) {
			isEmpty = false;

			callback(null, data);
		},

		flush(callback) {
			callback();
		}
	});

	const finalStream = new PassThrough({
		autoDestroy: false,
		destroy(error, callback) {
			response.destroy();

			callback(error);
		}
	});

	const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();

	decompressStream.once('error', error => {
		if (isEmpty && !response.readable) {
			finalStream.end();
			return;
		}

		finalStream.destroy(error);
	});

	mimicResponse(response, finalStream);
	response.pipe(checker).pipe(decompressStream).pipe(finalStream);

	return finalStream;
};

let QuickLRU$2 = class QuickLRU {
	constructor(options = {}) {
		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		this.maxSize = options.maxSize;
		this.onEviction = options.onEviction;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	}

	_set(key, value) {
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) {
			this._size = 0;

			if (typeof this.onEviction === 'function') {
				for (const [key, value] of this.oldCache.entries()) {
					this.onEviction(key, value);
				}
			}

			this.oldCache = this.cache;
			this.cache = new Map();
		}
	}

	get(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		}
	}

	set(key, value) {
		if (this.cache.has(key)) {
			this.cache.set(key, value);
		} else {
			this._set(key, value);
		}

		return this;
	}

	has(key) {
		return this.cache.has(key) || this.oldCache.has(key);
	}

	peek(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			return this.oldCache.get(key);
		}
	}

	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) {
			this._size--;
		}

		return this.oldCache.delete(key) || deleted;
	}

	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.cache) {
			yield item;
		}

		for (const item of this.oldCache) {
			const [key] = item;
			if (!this.cache.has(key)) {
				yield item;
			}
		}
	}

	get size() {
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) {
			if (!this.cache.has(key)) {
				oldCacheSize++;
			}
		}

		return Math.min(this._size + oldCacheSize, this.maxSize);
	}
};

var quickLru = QuickLRU$2;

const EventEmitter = require$$0$4;
const tls$1 = require$$1$2;
const http2$2 = require$$0$6;
const QuickLRU$1 = quickLru;

const kCurrentStreamsCount = Symbol('currentStreamsCount');
const kRequest = Symbol('request');
const kOriginSet = Symbol('cachedOriginSet');
const kGracefullyClosing = Symbol('gracefullyClosing');

const nameKeys = [
	// `http2.connect()` options
	'maxDeflateDynamicTableSize',
	'maxSessionMemory',
	'maxHeaderListPairs',
	'maxOutstandingPings',
	'maxReservedRemoteStreams',
	'maxSendHeaderBlockLength',
	'paddingStrategy',

	// `tls.connect()` options
	'localAddress',
	'path',
	'rejectUnauthorized',
	'minDHSize',

	// `tls.createSecureContext()` options
	'ca',
	'cert',
	'clientCertEngine',
	'ciphers',
	'key',
	'pfx',
	'servername',
	'minVersion',
	'maxVersion',
	'secureProtocol',
	'crl',
	'honorCipherOrder',
	'ecdhCurve',
	'dhparam',
	'secureOptions',
	'sessionIdContext'
];

const getSortedIndex = (array, value, compare) => {
	let low = 0;
	let high = array.length;

	while (low < high) {
		const mid = (low + high) >>> 1;

		/* istanbul ignore next */
		if (compare(array[mid], value)) {
			// This never gets called because we use descending sort. Better to have this anyway.
			low = mid + 1;
		} else {
			high = mid;
		}
	}

	return low;
};

const compareSessions = (a, b) => {
	return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
};

// See https://tools.ietf.org/html/rfc8336
const closeCoveredSessions = (where, session) => {
	// Clients SHOULD NOT emit new requests on any connection whose Origin
	// Set is a proper subset of another connection's Origin Set, and they
	// SHOULD close it once all outstanding requests are satisfied.
	for (const coveredSession of where) {
		if (
			// The set is a proper subset when its length is less than the other set.
			coveredSession[kOriginSet].length < session[kOriginSet].length &&

			// And the other set includes all elements of the subset.
			coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&

			// Makes sure that the session can handle all requests from the covered session.
			coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams
		) {
			// This allows pending requests to finish and prevents making new requests.
			gracefullyClose(coveredSession);
		}
	}
};

// This is basically inverted `closeCoveredSessions(...)`.
const closeSessionIfCovered = (where, coveredSession) => {
	for (const session of where) {
		if (
			coveredSession[kOriginSet].length < session[kOriginSet].length &&
			coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&
			coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams
		) {
			gracefullyClose(coveredSession);
		}
	}
};

const getSessions = ({agent, isFree}) => {
	const result = {};

	// eslint-disable-next-line guard-for-in
	for (const normalizedOptions in agent.sessions) {
		const sessions = agent.sessions[normalizedOptions];

		const filtered = sessions.filter(session => {
			const result = session[Agent$1.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;

			return isFree ? result : !result;
		});

		if (filtered.length !== 0) {
			result[normalizedOptions] = filtered;
		}
	}

	return result;
};

const gracefullyClose = session => {
	session[kGracefullyClosing] = true;

	if (session[kCurrentStreamsCount] === 0) {
		session.close();
	}
};

let Agent$1 = class Agent extends EventEmitter {
	constructor({timeout = 60000, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100} = {}) {
		super();

		// A session is considered busy when its current streams count
		// is equal to or greater than the `maxConcurrentStreams` value.

		// A session is considered free when its current streams count
		// is less than the `maxConcurrentStreams` value.

		// SESSIONS[NORMALIZED_OPTIONS] = [];
		this.sessions = {};

		// The queue for creating new sessions. It looks like this:
		// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION
		//
		// The entry function has `listeners`, `completed` and `destroyed` properties.
		// `listeners` is an array of objects containing `resolve` and `reject` functions.
		// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.
		// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.
		this.queue = {};

		// Each session will use this timeout value.
		this.timeout = timeout;

		// Max sessions in total
		this.maxSessions = maxSessions;

		// Max free sessions in total
		// TODO: decreasing `maxFreeSessions` should close some sessions
		this.maxFreeSessions = maxFreeSessions;

		this._freeSessionsCount = 0;
		this._sessionsCount = 0;

		// We don't support push streams by default.
		this.settings = {
			enablePush: false
		};

		// Reusing TLS sessions increases performance.
		this.tlsSessionCache = new QuickLRU$1({maxSize: maxCachedTlsSessions});
	}

	static normalizeOrigin(url, servername) {
		if (typeof url === 'string') {
			url = new URL(url);
		}

		if (servername && url.hostname !== servername) {
			url.hostname = servername;
		}

		return url.origin;
	}

	normalizeOptions(options) {
		let normalized = '';

		if (options) {
			for (const key of nameKeys) {
				if (options[key]) {
					normalized += `:${options[key]}`;
				}
			}
		}

		return normalized;
	}

	_tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
		if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {
			return;
		}

		const item = this.queue[normalizedOptions][normalizedOrigin];

		// The entry function can be run only once.
		// BUG: The session may be never created when:
		// - the first condition is false AND
		// - this function is never called with the same arguments in the future.
		if (this._sessionsCount < this.maxSessions && !item.completed) {
			item.completed = true;

			item();
		}
	}

	getSession(origin, options, listeners) {
		return new Promise((resolve, reject) => {
			if (Array.isArray(listeners)) {
				listeners = [...listeners];

				// Resolve the current promise ASAP, we're just moving the listeners.
				// They will be executed at a different time.
				resolve();
			} else {
				listeners = [{resolve, reject}];
			}

			const normalizedOptions = this.normalizeOptions(options);
			const normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);

			if (normalizedOrigin === undefined) {
				for (const {reject} of listeners) {
					reject(new TypeError('The `origin` argument needs to be a string or an URL object'));
				}

				return;
			}

			if (normalizedOptions in this.sessions) {
				const sessions = this.sessions[normalizedOptions];

				let maxConcurrentStreams = -1;
				let currentStreamsCount = -1;
				let optimalSession;

				// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.
				// Additionally, we are looking for session which has biggest current pending streams count.
				for (const session of sessions) {
					const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;

					if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
						break;
					}

					if (session[kOriginSet].includes(normalizedOrigin)) {
						const sessionCurrentStreamsCount = session[kCurrentStreamsCount];

						if (
							sessionCurrentStreamsCount >= sessionMaxConcurrentStreams ||
							session[kGracefullyClosing] ||
							// Unfortunately the `close` event isn't called immediately,
							// so `session.destroyed` is `true`, but `session.closed` is `false`.
							session.destroyed
						) {
							continue;
						}

						// We only need set this once.
						if (!optimalSession) {
							maxConcurrentStreams = sessionMaxConcurrentStreams;
						}

						// We're looking for the session which has biggest current pending stream count,
						// in order to minimalize the amount of active sessions.
						if (sessionCurrentStreamsCount > currentStreamsCount) {
							optimalSession = session;
							currentStreamsCount = sessionCurrentStreamsCount;
						}
					}
				}

				if (optimalSession) {
					/* istanbul ignore next: safety check */
					if (listeners.length !== 1) {
						for (const {reject} of listeners) {
							const error = new Error(
								`Expected the length of listeners to be 1, got ${listeners.length}.\n` +
								'Please report this to https://github.com/szmarczak/http2-wrapper/'
							);

							reject(error);
						}

						return;
					}

					listeners[0].resolve(optimalSession);
					return;
				}
			}

			if (normalizedOptions in this.queue) {
				if (normalizedOrigin in this.queue[normalizedOptions]) {
					// There's already an item in the queue, just attach ourselves to it.
					this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);

					// This shouldn't be executed here.
					// See the comment inside _tryToCreateNewSession.
					this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
					return;
				}
			} else {
				this.queue[normalizedOptions] = {};
			}

			// The entry must be removed from the queue IMMEDIATELY when:
			// 1. the session connects successfully,
			// 2. an error occurs.
			const removeFromQueue = () => {
				// Our entry can be replaced. We cannot remove the new one.
				if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
					delete this.queue[normalizedOptions][normalizedOrigin];

					if (Object.keys(this.queue[normalizedOptions]).length === 0) {
						delete this.queue[normalizedOptions];
					}
				}
			};

			// The main logic is here
			const entry = () => {
				const name = `${normalizedOrigin}:${normalizedOptions}`;
				let receivedSettings = false;

				try {
					const session = http2$2.connect(origin, {
						createConnection: this.createConnection,
						settings: this.settings,
						session: this.tlsSessionCache.get(name),
						...options
					});
					session[kCurrentStreamsCount] = 0;
					session[kGracefullyClosing] = false;

					const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
					let wasFree = true;

					session.socket.once('session', tlsSession => {
						this.tlsSessionCache.set(name, tlsSession);
					});

					session.once('error', error => {
						// Listeners are empty when the session successfully connected.
						for (const {reject} of listeners) {
							reject(error);
						}

						// The connection got broken, purge the cache.
						this.tlsSessionCache.delete(name);
					});

					session.setTimeout(this.timeout, () => {
						// Terminates all streams owned by this session.
						// TODO: Maybe the streams should have a "Session timed out" error?
						session.destroy();
					});

					session.once('close', () => {
						if (receivedSettings) {
							// 1. If it wasn't free then no need to decrease because
							//    it has been decreased already in session.request().
							// 2. `stream.once('close')` won't increment the count
							//    because the session is already closed.
							if (wasFree) {
								this._freeSessionsCount--;
							}

							this._sessionsCount--;

							// This cannot be moved to the stream logic,
							// because there may be a session that hadn't made a single request.
							const where = this.sessions[normalizedOptions];
							where.splice(where.indexOf(session), 1);

							if (where.length === 0) {
								delete this.sessions[normalizedOptions];
							}
						} else {
							// Broken connection
							const error = new Error('Session closed without receiving a SETTINGS frame');
							error.code = 'HTTP2WRAPPER_NOSETTINGS';

							for (const {reject} of listeners) {
								reject(error);
							}

							removeFromQueue();
						}

						// There may be another session awaiting.
						this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
					});

					// Iterates over the queue and processes listeners.
					const processListeners = () => {
						if (!(normalizedOptions in this.queue) || !isFree()) {
							return;
						}

						for (const origin of session[kOriginSet]) {
							if (origin in this.queue[normalizedOptions]) {
								const {listeners} = this.queue[normalizedOptions][origin];

								// Prevents session overloading.
								while (listeners.length !== 0 && isFree()) {
									// We assume `resolve(...)` calls `request(...)` *directly*,
									// otherwise the session will get overloaded.
									listeners.shift().resolve(session);
								}

								const where = this.queue[normalizedOptions];
								if (where[origin].listeners.length === 0) {
									delete where[origin];

									if (Object.keys(where).length === 0) {
										delete this.queue[normalizedOptions];
										break;
									}
								}

								// We're no longer free, no point in continuing.
								if (!isFree()) {
									break;
								}
							}
						}
					};

					// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.
					session.on('origin', () => {
						session[kOriginSet] = session.originSet;

						if (!isFree()) {
							// The session is full.
							return;
						}

						processListeners();

						// Close covered sessions (if possible).
						closeCoveredSessions(this.sessions[normalizedOptions], session);
					});

					session.once('remoteSettings', () => {
						// Fix Node.js bug preventing the process from exiting
						session.ref();
						session.unref();

						this._sessionsCount++;

						// The Agent could have been destroyed already.
						if (entry.destroyed) {
							const error = new Error('Agent has been destroyed');

							for (const listener of listeners) {
								listener.reject(error);
							}

							session.destroy();
							return;
						}

						session[kOriginSet] = session.originSet;

						{
							const where = this.sessions;

							if (normalizedOptions in where) {
								const sessions = where[normalizedOptions];
								sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
							} else {
								where[normalizedOptions] = [session];
							}
						}

						this._freeSessionsCount += 1;
						receivedSettings = true;

						this.emit('session', session);

						processListeners();
						removeFromQueue();

						// TODO: Close last recently used (or least used?) session
						if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {
							session.close();
						}

						// Check if we haven't managed to execute all listeners.
						if (listeners.length !== 0) {
							// Request for a new session with predefined listeners.
							this.getSession(normalizedOrigin, options, listeners);
							listeners.length = 0;
						}

						// `session.remoteSettings.maxConcurrentStreams` might get increased
						session.on('remoteSettings', () => {
							processListeners();

							// In case the Origin Set changes
							closeCoveredSessions(this.sessions[normalizedOptions], session);
						});
					});

					// Shim `session.request()` in order to catch all streams
					session[kRequest] = session.request;
					session.request = (headers, streamOptions) => {
						if (session[kGracefullyClosing]) {
							throw new Error('The session is gracefully closing. No new streams are allowed.');
						}

						const stream = session[kRequest](headers, streamOptions);

						// The process won't exit until the session is closed or all requests are gone.
						session.ref();

						++session[kCurrentStreamsCount];

						if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {
							this._freeSessionsCount--;
						}

						stream.once('close', () => {
							wasFree = isFree();

							--session[kCurrentStreamsCount];

							if (!session.destroyed && !session.closed) {
								closeSessionIfCovered(this.sessions[normalizedOptions], session);

								if (isFree() && !session.closed) {
									if (!wasFree) {
										this._freeSessionsCount++;

										wasFree = true;
									}

									const isEmpty = session[kCurrentStreamsCount] === 0;

									if (isEmpty) {
										session.unref();
									}

									if (
										isEmpty &&
										(
											this._freeSessionsCount > this.maxFreeSessions ||
											session[kGracefullyClosing]
										)
									) {
										session.close();
									} else {
										closeCoveredSessions(this.sessions[normalizedOptions], session);
										processListeners();
									}
								}
							}
						});

						return stream;
					};
				} catch (error) {
					for (const listener of listeners) {
						listener.reject(error);
					}

					removeFromQueue();
				}
			};

			entry.listeners = listeners;
			entry.completed = false;
			entry.destroyed = false;

			this.queue[normalizedOptions][normalizedOrigin] = entry;
			this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
		});
	}

	request(origin, options, headers, streamOptions) {
		return new Promise((resolve, reject) => {
			this.getSession(origin, options, [{
				reject,
				resolve: session => {
					try {
						resolve(session.request(headers, streamOptions));
					} catch (error) {
						reject(error);
					}
				}
			}]);
		});
	}

	createConnection(origin, options) {
		return Agent.connect(origin, options);
	}

	static connect(origin, options) {
		options.ALPNProtocols = ['h2'];

		const port = origin.port || 443;
		const host = origin.hostname || origin.host;

		if (typeof options.servername === 'undefined') {
			options.servername = host;
		}

		return tls$1.connect(port, host, options);
	}

	closeFreeSessions() {
		for (const sessions of Object.values(this.sessions)) {
			for (const session of sessions) {
				if (session[kCurrentStreamsCount] === 0) {
					session.close();
				}
			}
		}
	}

	destroy(reason) {
		for (const sessions of Object.values(this.sessions)) {
			for (const session of sessions) {
				session.destroy(reason);
			}
		}

		for (const entriesOfAuthority of Object.values(this.queue)) {
			for (const entry of Object.values(entriesOfAuthority)) {
				entry.destroyed = true;
			}
		}

		// New requests should NOT attach to destroyed sessions
		this.queue = {};
	}

	get freeSessions() {
		return getSessions({agent: this, isFree: true});
	}

	get busySessions() {
		return getSessions({agent: this, isFree: false});
	}
};

Agent$1.kCurrentStreamsCount = kCurrentStreamsCount;
Agent$1.kGracefullyClosing = kGracefullyClosing;

var agent$1 = {
	Agent: Agent$1,
	globalAgent: new Agent$1()
};

const {Readable} = require$$0$2;

let IncomingMessage$2 = class IncomingMessage extends Readable {
	constructor(socket, highWaterMark) {
		super({
			highWaterMark,
			autoDestroy: false
		});

		this.statusCode = null;
		this.statusMessage = '';
		this.httpVersion = '2.0';
		this.httpVersionMajor = 2;
		this.httpVersionMinor = 0;
		this.headers = {};
		this.trailers = {};
		this.req = null;

		this.aborted = false;
		this.complete = false;
		this.upgrade = null;

		this.rawHeaders = [];
		this.rawTrailers = [];

		this.socket = socket;
		this.connection = socket;

		this._dumped = false;
	}

	_destroy(error) {
		this.req._request.destroy(error);
	}

	setTimeout(ms, callback) {
		this.req.setTimeout(ms, callback);
		return this;
	}

	_dump() {
		if (!this._dumped) {
			this._dumped = true;

			this.removeAllListeners('data');
			this.resume();
		}
	}

	_read() {
		if (this.req) {
			this.req._request.resume();
		}
	}
};

var incomingMessage = IncomingMessage$2;

/* istanbul ignore file: https://github.com/nodejs/node/blob/a91293d4d9ab403046ab5eb022332e4e3d249bd3/lib/internal/url.js#L1257 */

var urlToOptions$3 = url => {
	const options = {
		protocol: url.protocol,
		hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
		host: url.host,
		hash: url.hash,
		search: url.search,
		pathname: url.pathname,
		href: url.href,
		path: `${url.pathname || ''}${url.search || ''}`
	};

	if (typeof url.port === 'string' && url.port.length !== 0) {
		options.port = Number(url.port);
	}

	if (url.username || url.password) {
		options.auth = `${url.username || ''}:${url.password || ''}`;
	}

	return options;
};

var proxyEvents$2 = (from, to, events) => {
	for (const event of events) {
		from.on(event, (...args) => to.emit(event, ...args));
	}
};

var isRequestPseudoHeader$1 = header => {
	switch (header) {
		case ':method':
		case ':scheme':
		case ':authority':
		case ':path':
			return true;
		default:
			return false;
	}
};

var errors = {exports: {}};

(function (module) {
	/* istanbul ignore file: https://github.com/nodejs/node/blob/master/lib/internal/errors.js */

	const makeError = (Base, key, getMessage) => {
		module.exports[key] = class NodeError extends Base {
			constructor(...args) {
				super(typeof getMessage === 'string' ? getMessage : getMessage(args));
				this.name = `${super.name} [${key}]`;
				this.code = key;
			}
		};
	};

	makeError(TypeError, 'ERR_INVALID_ARG_TYPE', args => {
		const type = args[0].includes('.') ? 'property' : 'argument';

		let valid = args[1];
		const isManyTypes = Array.isArray(valid);

		if (isManyTypes) {
			valid = `${valid.slice(0, -1).join(', ')} or ${valid.slice(-1)}`;
		}

		return `The "${args[0]}" ${type} must be ${isManyTypes ? 'one of' : 'of'} type ${valid}. Received ${typeof args[2]}`;
	});

	makeError(TypeError, 'ERR_INVALID_PROTOCOL', args => {
		return `Protocol "${args[0]}" not supported. Expected "${args[1]}"`;
	});

	makeError(Error, 'ERR_HTTP_HEADERS_SENT', args => {
		return `Cannot ${args[0]} headers after they are sent to the client`;
	});

	makeError(TypeError, 'ERR_INVALID_HTTP_TOKEN', args => {
		return `${args[0]} must be a valid HTTP token [${args[1]}]`;
	});

	makeError(TypeError, 'ERR_HTTP_INVALID_HEADER_VALUE', args => {
		return `Invalid value "${args[0]} for header "${args[1]}"`;
	});

	makeError(TypeError, 'ERR_INVALID_CHAR', args => {
		return `Invalid character in ${args[0]} [${args[1]}]`;
	}); 
} (errors));

var errorsExports = errors.exports;

const http2$1 = require$$0$6;
const {Writable} = require$$0$2;
const {Agent, globalAgent} = agent$1;
const IncomingMessage$1 = incomingMessage;
const urlToOptions$2 = urlToOptions$3;
const proxyEvents$1 = proxyEvents$2;
const isRequestPseudoHeader = isRequestPseudoHeader$1;
const {
	ERR_INVALID_ARG_TYPE,
	ERR_INVALID_PROTOCOL,
	ERR_HTTP_HEADERS_SENT,
	ERR_INVALID_HTTP_TOKEN,
	ERR_HTTP_INVALID_HEADER_VALUE,
	ERR_INVALID_CHAR
} = errorsExports;

const {
	HTTP2_HEADER_STATUS,
	HTTP2_HEADER_METHOD,
	HTTP2_HEADER_PATH,
	HTTP2_METHOD_CONNECT
} = http2$1.constants;

const kHeaders = Symbol('headers');
const kOrigin = Symbol('origin');
const kSession = Symbol('session');
const kOptions = Symbol('options');
const kFlushedHeaders = Symbol('flushedHeaders');
const kJobs = Symbol('jobs');

const isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
const isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;

let ClientRequest$1 = class ClientRequest extends Writable {
	constructor(input, options, callback) {
		super({
			autoDestroy: false
		});

		const hasInput = typeof input === 'string' || input instanceof URL;
		if (hasInput) {
			input = urlToOptions$2(input instanceof URL ? input : new URL(input));
		}

		if (typeof options === 'function' || options === undefined) {
			// (options, callback)
			callback = options;
			options = hasInput ? input : {...input};
		} else {
			// (input, options, callback)
			options = {...input, ...options};
		}

		if (options.h2session) {
			this[kSession] = options.h2session;
		} else if (options.agent === false) {
			this.agent = new Agent({maxFreeSessions: 0});
		} else if (typeof options.agent === 'undefined' || options.agent === null) {
			if (typeof options.createConnection === 'function') {
				// This is a workaround - we don't have to create the session on our own.
				this.agent = new Agent({maxFreeSessions: 0});
				this.agent.createConnection = options.createConnection;
			} else {
				this.agent = globalAgent;
			}
		} else if (typeof options.agent.request === 'function') {
			this.agent = options.agent;
		} else {
			throw new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);
		}

		if (options.protocol && options.protocol !== 'https:') {
			throw new ERR_INVALID_PROTOCOL(options.protocol, 'https:');
		}

		const port = options.port || options.defaultPort || (this.agent && this.agent.defaultPort) || 443;
		const host = options.hostname || options.host || 'localhost';

		// Don't enforce the origin via options. It may be changed in an Agent.
		delete options.hostname;
		delete options.host;
		delete options.port;

		const {timeout} = options;
		options.timeout = undefined;

		this[kHeaders] = Object.create(null);
		this[kJobs] = [];

		this.socket = null;
		this.connection = null;

		this.method = options.method || 'GET';
		this.path = options.path;

		this.res = null;
		this.aborted = false;
		this.reusedSocket = false;

		if (options.headers) {
			for (const [header, value] of Object.entries(options.headers)) {
				this.setHeader(header, value);
			}
		}

		if (options.auth && !('authorization' in this[kHeaders])) {
			this[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');
		}

		options.session = options.tlsSession;
		options.path = options.socketPath;

		this[kOptions] = options;

		// Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.
		if (port === 443) {
			this[kOrigin] = `https://${host}`;

			if (!(':authority' in this[kHeaders])) {
				this[kHeaders][':authority'] = host;
			}
		} else {
			this[kOrigin] = `https://${host}:${port}`;

			if (!(':authority' in this[kHeaders])) {
				this[kHeaders][':authority'] = `${host}:${port}`;
			}
		}

		if (timeout) {
			this.setTimeout(timeout);
		}

		if (callback) {
			this.once('response', callback);
		}

		this[kFlushedHeaders] = false;
	}

	get method() {
		return this[kHeaders][HTTP2_HEADER_METHOD];
	}

	set method(value) {
		if (value) {
			this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
		}
	}

	get path() {
		return this[kHeaders][HTTP2_HEADER_PATH];
	}

	set path(value) {
		if (value) {
			this[kHeaders][HTTP2_HEADER_PATH] = value;
		}
	}

	get _mustNotHaveABody() {
		return this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';
	}

	_write(chunk, encoding, callback) {
		// https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156
		if (this._mustNotHaveABody) {
			callback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));
			/* istanbul ignore next: Node.js 12 throws directly */
			return;
		}

		this.flushHeaders();

		const callWrite = () => this._request.write(chunk, encoding, callback);
		if (this._request) {
			callWrite();
		} else {
			this[kJobs].push(callWrite);
		}
	}

	_final(callback) {
		if (this.destroyed) {
			return;
		}

		this.flushHeaders();

		const callEnd = () => {
			// For GET, HEAD and DELETE
			if (this._mustNotHaveABody) {
				callback();
				return;
			}

			this._request.end(callback);
		};

		if (this._request) {
			callEnd();
		} else {
			this[kJobs].push(callEnd);
		}
	}

	abort() {
		if (this.res && this.res.complete) {
			return;
		}

		if (!this.aborted) {
			process.nextTick(() => this.emit('abort'));
		}

		this.aborted = true;

		this.destroy();
	}

	_destroy(error, callback) {
		if (this.res) {
			this.res._dump();
		}

		if (this._request) {
			this._request.destroy();
		}

		callback(error);
	}

	async flushHeaders() {
		if (this[kFlushedHeaders] || this.destroyed) {
			return;
		}

		this[kFlushedHeaders] = true;

		const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;

		// The real magic is here
		const onStream = stream => {
			this._request = stream;

			if (this.destroyed) {
				stream.destroy();
				return;
			}

			// Forwards `timeout`, `continue`, `close` and `error` events to this instance.
			if (!isConnectMethod) {
				proxyEvents$1(stream, this, ['timeout', 'continue', 'close', 'error']);
			}

			// Wait for the `finish` event. We don't want to emit the `response` event
			// before `request.end()` is called.
			const waitForEnd = fn => {
				return (...args) => {
					if (!this.writable && !this.destroyed) {
						fn(...args);
					} else {
						this.once('finish', () => {
							fn(...args);
						});
					}
				};
			};

			// This event tells we are ready to listen for the data.
			stream.once('response', waitForEnd((headers, flags, rawHeaders) => {
				// If we were to emit raw request stream, it would be as fast as the native approach.
				// Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).
				const response = new IncomingMessage$1(this.socket, stream.readableHighWaterMark);
				this.res = response;

				response.req = this;
				response.statusCode = headers[HTTP2_HEADER_STATUS];
				response.headers = headers;
				response.rawHeaders = rawHeaders;

				response.once('end', () => {
					if (this.aborted) {
						response.aborted = true;
						response.emit('aborted');
					} else {
						response.complete = true;

						// Has no effect, just be consistent with the Node.js behavior
						response.socket = null;
						response.connection = null;
					}
				});

				if (isConnectMethod) {
					response.upgrade = true;

					// The HTTP1 API says the socket is detached here,
					// but we can't do that so we pass the original HTTP2 request.
					if (this.emit('connect', response, stream, Buffer.alloc(0))) {
						this.emit('close');
					} else {
						// No listeners attached, destroy the original request.
						stream.destroy();
					}
				} else {
					// Forwards data
					stream.on('data', chunk => {
						if (!response._dumped && !response.push(chunk)) {
							stream.pause();
						}
					});

					stream.once('end', () => {
						response.push(null);
					});

					if (!this.emit('response', response)) {
						// No listeners attached, dump the response.
						response._dump();
					}
				}
			}));

			// Emits `information` event
			stream.once('headers', waitForEnd(
				headers => this.emit('information', {statusCode: headers[HTTP2_HEADER_STATUS]})
			));

			stream.once('trailers', waitForEnd((trailers, flags, rawTrailers) => {
				const {res} = this;

				// Assigns trailers to the response object.
				res.trailers = trailers;
				res.rawTrailers = rawTrailers;
			}));

			const {socket} = stream.session;
			this.socket = socket;
			this.connection = socket;

			for (const job of this[kJobs]) {
				job();
			}

			this.emit('socket', this.socket);
		};

		// Makes a HTTP2 request
		if (this[kSession]) {
			try {
				onStream(this[kSession].request(this[kHeaders]));
			} catch (error) {
				this.emit('error', error);
			}
		} else {
			this.reusedSocket = true;

			try {
				onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));
			} catch (error) {
				this.emit('error', error);
			}
		}
	}

	getHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		return this[kHeaders][name.toLowerCase()];
	}

	get headersSent() {
		return this[kFlushedHeaders];
	}

	removeHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		if (this.headersSent) {
			throw new ERR_HTTP_HEADERS_SENT('remove');
		}

		delete this[kHeaders][name.toLowerCase()];
	}

	setHeader(name, value) {
		if (this.headersSent) {
			throw new ERR_HTTP_HEADERS_SENT('set');
		}

		if (typeof name !== 'string' || (!isValidHttpToken.test(name) && !isRequestPseudoHeader(name))) {
			throw new ERR_INVALID_HTTP_TOKEN('Header name', name);
		}

		if (typeof value === 'undefined') {
			throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
		}

		if (isInvalidHeaderValue.test(value)) {
			throw new ERR_INVALID_CHAR('header content', name);
		}

		this[kHeaders][name.toLowerCase()] = value;
	}

	setNoDelay() {
		// HTTP2 sockets cannot be malformed, do nothing.
	}

	setSocketKeepAlive() {
		// HTTP2 sockets cannot be malformed, do nothing.
	}

	setTimeout(ms, callback) {
		const applyTimeout = () => this._request.setTimeout(ms, callback);

		if (this._request) {
			applyTimeout();
		} else {
			this[kJobs].push(applyTimeout);
		}

		return this;
	}

	get maxHeadersCount() {
		if (!this.destroyed && this._request) {
			return this._request.session.localSettings.maxHeaderListSize;
		}

		return undefined;
	}

	set maxHeadersCount(_value) {
		// Updating HTTP2 settings would affect all requests, do nothing.
	}
};

var clientRequest = ClientRequest$1;

var auto$1 = {exports: {}};

const tls = require$$1$2;

var resolveAlpn = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
	let timeout = false;

	let socket;

	const callback = async () => {
		await socketPromise;

		socket.off('timeout', onTimeout);
		socket.off('error', reject);

		if (options.resolveSocket) {
			resolve({alpnProtocol: socket.alpnProtocol, socket, timeout});

			if (timeout) {
				await Promise.resolve();
				socket.emit('timeout');
			}
		} else {
			socket.destroy();
			resolve({alpnProtocol: socket.alpnProtocol, timeout});
		}
	};

	const onTimeout = async () => {
		timeout = true;
		callback();
	};

	const socketPromise = (async () => {
		try {
			socket = await connect(options, callback);

			socket.on('error', reject);
			socket.once('timeout', onTimeout);
		} catch (error) {
			reject(error);
		}
	})();
});

const net$1 = require$$0$7;
/* istanbul ignore file: https://github.com/nodejs/node/blob/v13.0.1/lib/_http_agent.js */

var calculateServerName$1 = options => {
	let servername = options.host;
	const hostHeader = options.headers && options.headers.host;

	if (hostHeader) {
		if (hostHeader.startsWith('[')) {
			const index = hostHeader.indexOf(']');
			if (index === -1) {
				servername = hostHeader;
			} else {
				servername = hostHeader.slice(1, -1);
			}
		} else {
			servername = hostHeader.split(':', 1)[0];
		}
	}

	if (net$1.isIP(servername)) {
		return '';
	}

	return servername;
};

const http = require$$4;
const https = require$$1$3;
const resolveALPN = resolveAlpn;
const QuickLRU = quickLru;
const Http2ClientRequest = clientRequest;
const calculateServerName = calculateServerName$1;
const urlToOptions$1 = urlToOptions$3;

const cache = new QuickLRU({maxSize: 100});
const queue = new Map();

const installSocket = (agent, socket, options) => {
	socket._httpMessage = {shouldKeepAlive: true};

	const onFree = () => {
		agent.emit('free', socket, options);
	};

	socket.on('free', onFree);

	const onClose = () => {
		agent.removeSocket(socket, options);
	};

	socket.on('close', onClose);

	const onRemove = () => {
		agent.removeSocket(socket, options);
		socket.off('close', onClose);
		socket.off('free', onFree);
		socket.off('agentRemove', onRemove);
	};

	socket.on('agentRemove', onRemove);

	agent.emit('free', socket, options);
};

const resolveProtocol = async options => {
	const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;

	if (!cache.has(name)) {
		if (queue.has(name)) {
			const result = await queue.get(name);
			return result.alpnProtocol;
		}

		const {path, agent} = options;
		options.path = options.socketPath;

		const resultPromise = resolveALPN(options);
		queue.set(name, resultPromise);

		try {
			const {socket, alpnProtocol} = await resultPromise;
			cache.set(name, alpnProtocol);

			options.path = path;

			if (alpnProtocol === 'h2') {
				// https://github.com/nodejs/node/issues/33343
				socket.destroy();
			} else {
				const {globalAgent} = https;
				const defaultCreateConnection = https.Agent.prototype.createConnection;

				if (agent) {
					if (agent.createConnection === defaultCreateConnection) {
						installSocket(agent, socket, options);
					} else {
						socket.destroy();
					}
				} else if (globalAgent.createConnection === defaultCreateConnection) {
					installSocket(globalAgent, socket, options);
				} else {
					socket.destroy();
				}
			}

			queue.delete(name);

			return alpnProtocol;
		} catch (error) {
			queue.delete(name);

			throw error;
		}
	}

	return cache.get(name);
};

auto$1.exports = async (input, options, callback) => {
	if (typeof input === 'string' || input instanceof URL) {
		input = urlToOptions$1(new URL(input));
	}

	if (typeof options === 'function') {
		callback = options;
		options = undefined;
	}

	options = {
		ALPNProtocols: ['h2', 'http/1.1'],
		...input,
		...options,
		resolveSocket: true
	};

	if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
		throw new Error('The `ALPNProtocols` option must be an Array with at least one entry');
	}

	options.protocol = options.protocol || 'https:';
	const isHttps = options.protocol === 'https:';

	options.host = options.hostname || options.host || 'localhost';
	options.session = options.tlsSession;
	options.servername = options.servername || calculateServerName(options);
	options.port = options.port || (isHttps ? 443 : 80);
	options._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;

	const agents = options.agent;

	if (agents) {
		if (agents.addRequest) {
			throw new Error('The `options.agent` object can contain only `http`, `https` or `http2` properties');
		}

		options.agent = agents[isHttps ? 'https' : 'http'];
	}

	if (isHttps) {
		const protocol = await resolveProtocol(options);

		if (protocol === 'h2') {
			if (agents) {
				options.agent = agents.http2;
			}

			return new Http2ClientRequest(options, callback);
		}
	}

	return http.request(options, callback);
};

auto$1.exports.protocolCache = cache;

var autoExports = auto$1.exports;

const http2 = require$$0$6;
const agent = agent$1;
const ClientRequest = clientRequest;
const IncomingMessage = incomingMessage;
const auto = autoExports;

const request = (url, options, callback) => {
	return new ClientRequest(url, options, callback);
};

const get = (url, options, callback) => {
	// eslint-disable-next-line unicorn/prevent-abbreviations
	const req = new ClientRequest(url, options, callback);
	req.end();

	return req;
};

var source = {
	...http2,
	ClientRequest,
	IncomingMessage,
	...agent,
	request,
	get,
	auto
};

var getBodySize = {};

var isFormData = {};

Object.defineProperty(isFormData, "__esModule", { value: true });
const is_1$4 = distExports;
isFormData.default = (body) => is_1$4.default.nodeStream(body) && is_1$4.default.function_(body.getBoundary);

Object.defineProperty(getBodySize, "__esModule", { value: true });
const fs_1$1 = require$$2$2;
const util_1 = require$$1;
const is_1$3 = distExports;
const is_form_data_1 = isFormData;
const statAsync = util_1.promisify(fs_1$1.stat);
getBodySize.default = async (body, headers) => {
    if (headers && 'content-length' in headers) {
        return Number(headers['content-length']);
    }
    if (!body) {
        return 0;
    }
    if (is_1$3.default.string(body)) {
        return Buffer.byteLength(body);
    }
    if (is_1$3.default.buffer(body)) {
        return body.length;
    }
    if (is_form_data_1.default(body)) {
        return util_1.promisify(body.getLength.bind(body))();
    }
    if (body instanceof fs_1$1.ReadStream) {
        const { size } = await statAsync(body.path);
        if (size === 0) {
            return undefined;
        }
        return size;
    }
    return undefined;
};

var proxyEvents = {};

var hasRequiredProxyEvents;

function requireProxyEvents () {
	if (hasRequiredProxyEvents) return proxyEvents;
	hasRequiredProxyEvents = 1;
	Object.defineProperty(proxyEvents, "__esModule", { value: true });
	function default_1(from, to, events) {
	    const fns = {};
	    for (const event of events) {
	        fns[event] = (...args) => {
	            to.emit(event, ...args);
	        };
	        from.on(event, fns[event]);
	    }
	    return () => {
	        for (const event of events) {
	            from.off(event, fns[event]);
	        }
	    };
	}
	proxyEvents.default = default_1;
	return proxyEvents;
}

var timedOut = {};

var unhandle = {};

Object.defineProperty(unhandle, "__esModule", { value: true });
// When attaching listeners, it's very easy to forget about them.
// Especially if you do error handling and set timeouts.
// So instead of checking if it's proper to throw an error on every timeout ever,
// use this simple tool which will remove all listeners you have attached.
unhandle.default = () => {
    const handlers = [];
    return {
        once(origin, event, fn) {
            origin.once(event, fn);
            handlers.push({ origin, event, fn });
        },
        unhandleAll() {
            for (const handler of handlers) {
                const { origin, event, fn } = handler;
                origin.removeListener(event, fn);
            }
            handlers.length = 0;
        }
    };
};

Object.defineProperty(timedOut, "__esModule", { value: true });
timedOut.TimeoutError = void 0;
const net = require$$0$7;
const unhandle_1 = unhandle;
const reentry = Symbol('reentry');
const noop$1 = () => { };
class TimeoutError extends Error {
    constructor(threshold, event) {
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        this.event = event;
        this.name = 'TimeoutError';
        this.code = 'ETIMEDOUT';
    }
}
timedOut.TimeoutError = TimeoutError;
timedOut.default = (request, delays, options) => {
    if (reentry in request) {
        return noop$1;
    }
    request[reentry] = true;
    const cancelers = [];
    const { once, unhandleAll } = unhandle_1.default();
    const addTimeout = (delay, callback, event) => {
        var _a;
        const timeout = setTimeout(callback, delay, delay, event);
        (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);
        const cancel = () => {
            clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
    };
    const { host, hostname } = options;
    const timeoutHandler = (delay, event) => {
        request.destroy(new TimeoutError(delay, event));
    };
    const cancelTimeouts = () => {
        for (const cancel of cancelers) {
            cancel();
        }
        unhandleAll();
    };
    request.once('error', error => {
        cancelTimeouts();
        // Save original behavior
        /* istanbul ignore next */
        if (request.listenerCount('error') === 0) {
            throw error;
        }
    });
    request.once('close', cancelTimeouts);
    once(request, 'response', (response) => {
        once(response, 'end', cancelTimeouts);
    });
    if (typeof delays.request !== 'undefined') {
        addTimeout(delays.request, timeoutHandler, 'request');
    }
    if (typeof delays.socket !== 'undefined') {
        const socketTimeoutHandler = () => {
            timeoutHandler(delays.socket, 'socket');
        };
        request.setTimeout(delays.socket, socketTimeoutHandler);
        // `request.setTimeout(0)` causes a memory leak.
        // We can just remove the listener and forget about the timer - it's unreffed.
        // See https://github.com/sindresorhus/got/issues/690
        cancelers.push(() => {
            request.removeListener('timeout', socketTimeoutHandler);
        });
    }
    once(request, 'socket', (socket) => {
        var _a;
        const { socketPath } = request;
        /* istanbul ignore next: hard to test */
        if (socket.connecting) {
            const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : '') !== 0);
            if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {
                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');
                once(socket, 'lookup', cancelTimeout);
            }
            if (typeof delays.connect !== 'undefined') {
                const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');
                if (hasPath) {
                    once(socket, 'connect', timeConnect());
                }
                else {
                    once(socket, 'lookup', (error) => {
                        if (error === null) {
                            once(socket, 'connect', timeConnect());
                        }
                    });
                }
            }
            if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {
                once(socket, 'connect', () => {
                    const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');
                    once(socket, 'secureConnect', cancelTimeout);
                });
            }
        }
        if (typeof delays.send !== 'undefined') {
            const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');
            /* istanbul ignore next: hard to test */
            if (socket.connecting) {
                once(socket, 'connect', () => {
                    once(request, 'upload-complete', timeRequest());
                });
            }
            else {
                once(request, 'upload-complete', timeRequest());
            }
        }
    });
    if (typeof delays.response !== 'undefined') {
        once(request, 'upload-complete', () => {
            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');
            once(request, 'response', cancelTimeout);
        });
    }
    return cancelTimeouts;
};

var urlToOptions = {};

Object.defineProperty(urlToOptions, "__esModule", { value: true });
const is_1$2 = distExports;
urlToOptions.default = (url) => {
    // Cast to URL
    url = url;
    const options = {
        protocol: url.protocol,
        hostname: is_1$2.default.string(url.hostname) && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ''}${url.search || ''}`
    };
    if (is_1$2.default.string(url.port) && url.port.length > 0) {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${url.username || ''}:${url.password || ''}`;
    }
    return options;
};

var optionsToUrl = {};

Object.defineProperty(optionsToUrl, "__esModule", { value: true });
/* istanbul ignore file: deprecated */
const url_1 = require$$0$5;
const keys = [
    'protocol',
    'host',
    'hostname',
    'port',
    'pathname',
    'search'
];
optionsToUrl.default = (origin, options) => {
    var _a, _b;
    if (options.path) {
        if (options.pathname) {
            throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');
        }
        if (options.search) {
            throw new TypeError('Parameters `path` and `search` are mutually exclusive.');
        }
        if (options.searchParams) {
            throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');
        }
    }
    if (options.search && options.searchParams) {
        throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');
    }
    if (!origin) {
        if (!options.protocol) {
            throw new TypeError('No URL protocol specified');
        }
        origin = `${options.protocol}//${(_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : ''}`;
    }
    const url = new url_1.URL(origin);
    if (options.path) {
        const searchIndex = options.path.indexOf('?');
        if (searchIndex === -1) {
            options.pathname = options.path;
        }
        else {
            options.pathname = options.path.slice(0, searchIndex);
            options.search = options.path.slice(searchIndex + 1);
        }
        delete options.path;
    }
    for (const key of keys) {
        if (options[key]) {
            url[key] = options[key].toString();
        }
    }
    return url;
};

var weakableMap = {};

Object.defineProperty(weakableMap, "__esModule", { value: true });
class WeakableMap {
    constructor() {
        this.weakMap = new WeakMap();
        this.map = new Map();
    }
    set(key, value) {
        if (typeof key === 'object') {
            this.weakMap.set(key, value);
        }
        else {
            this.map.set(key, value);
        }
    }
    get(key) {
        if (typeof key === 'object') {
            return this.weakMap.get(key);
        }
        return this.map.get(key);
    }
    has(key) {
        if (typeof key === 'object') {
            return this.weakMap.has(key);
        }
        return this.map.has(key);
    }
}
weakableMap.default = WeakableMap;

var getBuffer = {};

var hasRequiredGetBuffer;

function requireGetBuffer () {
	if (hasRequiredGetBuffer) return getBuffer;
	hasRequiredGetBuffer = 1;
	Object.defineProperty(getBuffer, "__esModule", { value: true });
	// TODO: Update https://github.com/sindresorhus/get-stream
	const getBuffer$1 = async (stream) => {
	    const chunks = [];
	    let length = 0;
	    for await (const chunk of stream) {
	        chunks.push(chunk);
	        length += Buffer.byteLength(chunk);
	    }
	    if (Buffer.isBuffer(chunks[0])) {
	        return Buffer.concat(chunks, length);
	    }
	    return Buffer.from(chunks.join(''));
	};
	getBuffer.default = getBuffer$1;
	return getBuffer;
}

var dnsIpVersion = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.dnsLookupIpVersionToFamily = exports.isDnsLookupIpVersion = void 0;
	const conversionTable = {
	    auto: 0,
	    ipv4: 4,
	    ipv6: 6
	};
	exports.isDnsLookupIpVersion = (value) => {
	    return value in conversionTable;
	};
	exports.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {
	    if (exports.isDnsLookupIpVersion(dnsLookupIpVersion)) {
	        return conversionTable[dnsLookupIpVersion];
	    }
	    throw new Error('Invalid DNS lookup IP version');
	}; 
} (dnsIpVersion));

var isResponseOk = {};

var hasRequiredIsResponseOk;

function requireIsResponseOk () {
	if (hasRequiredIsResponseOk) return isResponseOk;
	hasRequiredIsResponseOk = 1;
	Object.defineProperty(isResponseOk, "__esModule", { value: true });
	isResponseOk.isResponseOk = void 0;
	isResponseOk.isResponseOk = (response) => {
	    const { statusCode } = response;
	    const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
	    return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;
	};
	return isResponseOk;
}

var deprecationWarning = {};

Object.defineProperty(deprecationWarning, "__esModule", { value: true });
const alreadyWarned = new Set();
deprecationWarning.default = (message) => {
    if (alreadyWarned.has(message)) {
        return;
    }
    alreadyWarned.add(message);
    // @ts-expect-error Missing types.
    process.emitWarning(`Got: ${message}`, {
        type: 'DeprecationWarning'
    });
};

var normalizeArguments$1 = {};

Object.defineProperty(normalizeArguments$1, "__esModule", { value: true });
const is_1$1 = distExports;
const normalizeArguments = (options, defaults) => {
    if (is_1$1.default.null_(options.encoding)) {
        throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');
    }
    is_1$1.assert.any([is_1$1.default.string, is_1$1.default.undefined], options.encoding);
    is_1$1.assert.any([is_1$1.default.boolean, is_1$1.default.undefined], options.resolveBodyOnly);
    is_1$1.assert.any([is_1$1.default.boolean, is_1$1.default.undefined], options.methodRewriting);
    is_1$1.assert.any([is_1$1.default.boolean, is_1$1.default.undefined], options.isStream);
    is_1$1.assert.any([is_1$1.default.string, is_1$1.default.undefined], options.responseType);
    // `options.responseType`
    if (options.responseType === undefined) {
        options.responseType = 'text';
    }
    // `options.retry`
    const { retry } = options;
    if (defaults) {
        options.retry = { ...defaults.retry };
    }
    else {
        options.retry = {
            calculateDelay: retryObject => retryObject.computedValue,
            limit: 0,
            methods: [],
            statusCodes: [],
            errorCodes: [],
            maxRetryAfter: undefined
        };
    }
    if (is_1$1.default.object(retry)) {
        options.retry = {
            ...options.retry,
            ...retry
        };
        options.retry.methods = [...new Set(options.retry.methods.map(method => method.toUpperCase()))];
        options.retry.statusCodes = [...new Set(options.retry.statusCodes)];
        options.retry.errorCodes = [...new Set(options.retry.errorCodes)];
    }
    else if (is_1$1.default.number(retry)) {
        options.retry.limit = retry;
    }
    if (is_1$1.default.undefined(options.retry.maxRetryAfter)) {
        options.retry.maxRetryAfter = Math.min(
        // TypeScript is not smart enough to handle `.filter(x => is.number(x))`.
        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
        ...[options.timeout.request, options.timeout.connect].filter(is_1$1.default.number));
    }
    // `options.pagination`
    if (is_1$1.default.object(options.pagination)) {
        if (defaults) {
            options.pagination = {
                ...defaults.pagination,
                ...options.pagination
            };
        }
        const { pagination } = options;
        if (!is_1$1.default.function_(pagination.transform)) {
            throw new Error('`options.pagination.transform` must be implemented');
        }
        if (!is_1$1.default.function_(pagination.shouldContinue)) {
            throw new Error('`options.pagination.shouldContinue` must be implemented');
        }
        if (!is_1$1.default.function_(pagination.filter)) {
            throw new TypeError('`options.pagination.filter` must be implemented');
        }
        if (!is_1$1.default.function_(pagination.paginate)) {
            throw new Error('`options.pagination.paginate` must be implemented');
        }
    }
    // JSON mode
    if (options.responseType === 'json' && options.headers.accept === undefined) {
        options.headers.accept = 'application/json';
    }
    return options;
};
normalizeArguments$1.default = normalizeArguments;

var calculateRetryDelay$1 = {};

Object.defineProperty(calculateRetryDelay$1, "__esModule", { value: true });
calculateRetryDelay$1.retryAfterStatusCodes = void 0;
calculateRetryDelay$1.retryAfterStatusCodes = new Set([413, 429, 503]);
const calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter }) => {
    if (attemptCount > retryOptions.limit) {
        return 0;
    }
    const hasMethod = retryOptions.methods.includes(error.options.method);
    const hasErrorCode = retryOptions.errorCodes.includes(error.code);
    const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
    if (!hasMethod || (!hasErrorCode && !hasStatusCode)) {
        return 0;
    }
    if (error.response) {
        if (retryAfter) {
            if (retryOptions.maxRetryAfter === undefined || retryAfter > retryOptions.maxRetryAfter) {
                return 0;
            }
            return retryAfter;
        }
        if (error.response.statusCode === 413) {
            return 0;
        }
    }
    const noise = Math.random() * 100;
    return ((2 ** (attemptCount - 1)) * 1000) + noise;
};
calculateRetryDelay$1.default = calculateRetryDelay;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.UnsupportedProtocolError = exports.ReadError = exports.TimeoutError = exports.UploadError = exports.CacheError = exports.HTTPError = exports.MaxRedirectsError = exports.RequestError = exports.setNonEnumerableProperties = exports.knownHookEvents = exports.withoutBody = exports.kIsNormalizedAlready = void 0;
	const util_1 = require$$1;
	const stream_1 = require$$0$2;
	const fs_1 = require$$2$2;
	const url_1 = require$$0$5;
	const http = require$$4;
	const http_1 = require$$4;
	const https = require$$1$3;
	const http_timer_1 = sourceExports$2;
	const cacheable_lookup_1 = sourceExports$1;
	const CacheableRequest = src;
	const decompressResponse$1 = decompressResponse;
	// @ts-expect-error Missing types
	const http2wrapper = source;
	const lowercaseKeys = lowercaseKeys$2;
	const is_1 = distExports;
	const get_body_size_1 = getBodySize;
	const is_form_data_1 = isFormData;
	const proxy_events_1 = requireProxyEvents();
	const timed_out_1 = timedOut;
	const url_to_options_1 = urlToOptions;
	const options_to_url_1 = optionsToUrl;
	const weakable_map_1 = weakableMap;
	const get_buffer_1 = requireGetBuffer();
	const dns_ip_version_1 = dnsIpVersion;
	const is_response_ok_1 = requireIsResponseOk();
	const deprecation_warning_1 = deprecationWarning;
	const normalize_arguments_1 = normalizeArguments$1;
	const calculate_retry_delay_1 = calculateRetryDelay$1;
	let globalDnsCache;
	const kRequest = Symbol('request');
	const kResponse = Symbol('response');
	const kResponseSize = Symbol('responseSize');
	const kDownloadedSize = Symbol('downloadedSize');
	const kBodySize = Symbol('bodySize');
	const kUploadedSize = Symbol('uploadedSize');
	const kServerResponsesPiped = Symbol('serverResponsesPiped');
	const kUnproxyEvents = Symbol('unproxyEvents');
	const kIsFromCache = Symbol('isFromCache');
	const kCancelTimeouts = Symbol('cancelTimeouts');
	const kStartedReading = Symbol('startedReading');
	const kStopReading = Symbol('stopReading');
	const kTriggerRead = Symbol('triggerRead');
	const kBody = Symbol('body');
	const kJobs = Symbol('jobs');
	const kOriginalResponse = Symbol('originalResponse');
	const kRetryTimeout = Symbol('retryTimeout');
	exports.kIsNormalizedAlready = Symbol('isNormalizedAlready');
	const supportsBrotli = is_1.default.string(process.versions.brotli);
	exports.withoutBody = new Set(['GET', 'HEAD']);
	exports.knownHookEvents = [
	    'init',
	    'beforeRequest',
	    'beforeRedirect',
	    'beforeError',
	    'beforeRetry',
	    // Promise-Only
	    'afterResponse'
	];
	function validateSearchParameters(searchParameters) {
	    // eslint-disable-next-line guard-for-in
	    for (const key in searchParameters) {
	        const value = searchParameters[key];
	        if (!is_1.default.string(value) && !is_1.default.number(value) && !is_1.default.boolean(value) && !is_1.default.null_(value) && !is_1.default.undefined(value)) {
	            throw new TypeError(`The \`searchParams\` value '${String(value)}' must be a string, number, boolean or null`);
	        }
	    }
	}
	function isClientRequest(clientRequest) {
	    return is_1.default.object(clientRequest) && !('statusCode' in clientRequest);
	}
	const cacheableStore = new weakable_map_1.default();
	const waitForOpenFile = async (file) => new Promise((resolve, reject) => {
	    const onError = (error) => {
	        reject(error);
	    };
	    // Node.js 12 has incomplete types
	    if (!file.pending) {
	        resolve();
	    }
	    file.once('error', onError);
	    file.once('ready', () => {
	        file.off('error', onError);
	        resolve();
	    });
	});
	const redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
	const nonEnumerableProperties = [
	    'context',
	    'body',
	    'json',
	    'form'
	];
	exports.setNonEnumerableProperties = (sources, to) => {
	    // Non enumerable properties shall not be merged
	    const properties = {};
	    for (const source of sources) {
	        if (!source) {
	            continue;
	        }
	        for (const name of nonEnumerableProperties) {
	            if (!(name in source)) {
	                continue;
	            }
	            properties[name] = {
	                writable: true,
	                configurable: true,
	                enumerable: false,
	                // @ts-expect-error TS doesn't see the check above
	                value: source[name]
	            };
	        }
	    }
	    Object.defineProperties(to, properties);
	};
	/**
	An error to be thrown when a request fails.
	Contains a `code` property with error class code, like `ECONNREFUSED`.
	*/
	class RequestError extends Error {
	    constructor(message, error, self) {
	        var _a, _b;
	        super(message);
	        Error.captureStackTrace(this, this.constructor);
	        this.name = 'RequestError';
	        this.code = (_a = error.code) !== null && _a !== void 0 ? _a : 'ERR_GOT_REQUEST_ERROR';
	        if (self instanceof Request) {
	            Object.defineProperty(this, 'request', {
	                enumerable: false,
	                value: self
	            });
	            Object.defineProperty(this, 'response', {
	                enumerable: false,
	                value: self[kResponse]
	            });
	            Object.defineProperty(this, 'options', {
	                // This fails because of TS 3.7.2 useDefineForClassFields
	                // Ref: https://github.com/microsoft/TypeScript/issues/34972
	                enumerable: false,
	                value: self.options
	            });
	        }
	        else {
	            Object.defineProperty(this, 'options', {
	                // This fails because of TS 3.7.2 useDefineForClassFields
	                // Ref: https://github.com/microsoft/TypeScript/issues/34972
	                enumerable: false,
	                value: self
	            });
	        }
	        this.timings = (_b = this.request) === null || _b === void 0 ? void 0 : _b.timings;
	        // Recover the original stacktrace
	        if (is_1.default.string(error.stack) && is_1.default.string(this.stack)) {
	            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
	            const thisStackTrace = this.stack.slice(indexOfMessage).split('\n').reverse();
	            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\n').reverse();
	            // Remove duplicated traces
	            while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {
	                thisStackTrace.shift();
	            }
	            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join('\n')}${errorStackTrace.reverse().join('\n')}`;
	        }
	    }
	}
	exports.RequestError = RequestError;
	/**
	An error to be thrown when the server redirects you more than ten times.
	Includes a `response` property.
	*/
	class MaxRedirectsError extends RequestError {
	    constructor(request) {
	        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
	        this.name = 'MaxRedirectsError';
	        this.code = 'ERR_TOO_MANY_REDIRECTS';
	    }
	}
	exports.MaxRedirectsError = MaxRedirectsError;
	/**
	An error to be thrown when the server response code is not 2xx nor 3xx if `options.followRedirect` is `true`, but always except for 304.
	Includes a `response` property.
	*/
	class HTTPError extends RequestError {
	    constructor(response) {
	        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
	        this.name = 'HTTPError';
	        this.code = 'ERR_NON_2XX_3XX_RESPONSE';
	    }
	}
	exports.HTTPError = HTTPError;
	/**
	An error to be thrown when a cache method fails.
	For example, if the database goes down or there's a filesystem error.
	*/
	class CacheError extends RequestError {
	    constructor(error, request) {
	        super(error.message, error, request);
	        this.name = 'CacheError';
	        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_CACHE_ACCESS' : this.code;
	    }
	}
	exports.CacheError = CacheError;
	/**
	An error to be thrown when the request body is a stream and an error occurs while reading from that stream.
	*/
	class UploadError extends RequestError {
	    constructor(error, request) {
	        super(error.message, error, request);
	        this.name = 'UploadError';
	        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_UPLOAD' : this.code;
	    }
	}
	exports.UploadError = UploadError;
	/**
	An error to be thrown when the request is aborted due to a timeout.
	Includes an `event` and `timings` property.
	*/
	class TimeoutError extends RequestError {
	    constructor(error, timings, request) {
	        super(error.message, error, request);
	        this.name = 'TimeoutError';
	        this.event = error.event;
	        this.timings = timings;
	    }
	}
	exports.TimeoutError = TimeoutError;
	/**
	An error to be thrown when reading from response stream fails.
	*/
	class ReadError extends RequestError {
	    constructor(error, request) {
	        super(error.message, error, request);
	        this.name = 'ReadError';
	        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_READING_RESPONSE_STREAM' : this.code;
	    }
	}
	exports.ReadError = ReadError;
	/**
	An error to be thrown when given an unsupported protocol.
	*/
	class UnsupportedProtocolError extends RequestError {
	    constructor(options) {
	        super(`Unsupported protocol "${options.url.protocol}"`, {}, options);
	        this.name = 'UnsupportedProtocolError';
	        this.code = 'ERR_UNSUPPORTED_PROTOCOL';
	    }
	}
	exports.UnsupportedProtocolError = UnsupportedProtocolError;
	const proxiedRequestEvents = [
	    'socket',
	    'connect',
	    'continue',
	    'information',
	    'upgrade',
	    'timeout'
	];
	class Request extends stream_1.Duplex {
	    constructor(url, options = {}, defaults) {
	        super({
	            // This must be false, to enable throwing after destroy
	            // It is used for retry logic in Promise API
	            autoDestroy: false,
	            // It needs to be zero because we're just proxying the data to another stream
	            highWaterMark: 0
	        });
	        this[kDownloadedSize] = 0;
	        this[kUploadedSize] = 0;
	        this.requestInitialized = false;
	        this[kServerResponsesPiped] = new Set();
	        this.redirects = [];
	        this[kStopReading] = false;
	        this[kTriggerRead] = false;
	        this[kJobs] = [];
	        this.retryCount = 0;
	        // TODO: Remove this when targeting Node.js >= 12
	        this._progressCallbacks = [];
	        const unlockWrite = () => this._unlockWrite();
	        const lockWrite = () => this._lockWrite();
	        this.on('pipe', (source) => {
	            source.prependListener('data', unlockWrite);
	            source.on('data', lockWrite);
	            source.prependListener('end', unlockWrite);
	            source.on('end', lockWrite);
	        });
	        this.on('unpipe', (source) => {
	            source.off('data', unlockWrite);
	            source.off('data', lockWrite);
	            source.off('end', unlockWrite);
	            source.off('end', lockWrite);
	        });
	        this.on('pipe', source => {
	            if (source instanceof http_1.IncomingMessage) {
	                this.options.headers = {
	                    ...source.headers,
	                    ...this.options.headers
	                };
	            }
	        });
	        const { json, body, form } = options;
	        if (json || body || form) {
	            this._lockWrite();
	        }
	        if (exports.kIsNormalizedAlready in options) {
	            this.options = options;
	        }
	        else {
	            try {
	                // @ts-expect-error Common TypeScript bug saying that `this.constructor` is not accessible
	                this.options = this.constructor.normalizeArguments(url, options, defaults);
	            }
	            catch (error) {
	                // TODO: Move this to `_destroy()`
	                if (is_1.default.nodeStream(options.body)) {
	                    options.body.destroy();
	                }
	                this.destroy(error);
	                return;
	            }
	        }
	        (async () => {
	            var _a;
	            try {
	                if (this.options.body instanceof fs_1.ReadStream) {
	                    await waitForOpenFile(this.options.body);
	                }
	                const { url: normalizedURL } = this.options;
	                if (!normalizedURL) {
	                    throw new TypeError('Missing `url` property');
	                }
	                this.requestUrl = normalizedURL.toString();
	                decodeURI(this.requestUrl);
	                await this._finalizeBody();
	                await this._makeRequest();
	                if (this.destroyed) {
	                    (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroy();
	                    return;
	                }
	                // Queued writes etc.
	                for (const job of this[kJobs]) {
	                    job();
	                }
	                // Prevent memory leak
	                this[kJobs].length = 0;
	                this.requestInitialized = true;
	            }
	            catch (error) {
	                if (error instanceof RequestError) {
	                    this._beforeError(error);
	                    return;
	                }
	                // This is a workaround for https://github.com/nodejs/node/issues/33335
	                if (!this.destroyed) {
	                    this.destroy(error);
	                }
	            }
	        })();
	    }
	    static normalizeArguments(url, options, defaults) {
	        var _a, _b, _c, _d, _e;
	        const rawOptions = options;
	        if (is_1.default.object(url) && !is_1.default.urlInstance(url)) {
	            options = { ...defaults, ...url, ...options };
	        }
	        else {
	            if (url && options && options.url !== undefined) {
	                throw new TypeError('The `url` option is mutually exclusive with the `input` argument');
	            }
	            options = { ...defaults, ...options };
	            if (url !== undefined) {
	                options.url = url;
	            }
	            if (is_1.default.urlInstance(options.url)) {
	                options.url = new url_1.URL(options.url.toString());
	            }
	        }
	        // TODO: Deprecate URL options in Got 12.
	        // Support extend-specific options
	        if (options.cache === false) {
	            options.cache = undefined;
	        }
	        if (options.dnsCache === false) {
	            options.dnsCache = undefined;
	        }
	        // Nice type assertions
	        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.method);
	        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.headers);
	        is_1.assert.any([is_1.default.string, is_1.default.urlInstance, is_1.default.undefined], options.prefixUrl);
	        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cookieJar);
	        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.searchParams);
	        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.cache);
	        is_1.assert.any([is_1.default.object, is_1.default.number, is_1.default.undefined], options.timeout);
	        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.context);
	        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.hooks);
	        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.decompress);
	        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.ignoreInvalidCookies);
	        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.followRedirect);
	        is_1.assert.any([is_1.default.number, is_1.default.undefined], options.maxRedirects);
	        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.throwHttpErrors);
	        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.http2);
	        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.allowGetBody);
	        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.localAddress);
	        is_1.assert.any([dns_ip_version_1.isDnsLookupIpVersion, is_1.default.undefined], options.dnsLookupIpVersion);
	        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.https);
	        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.rejectUnauthorized);
	        if (options.https) {
	            is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.https.rejectUnauthorized);
	            is_1.assert.any([is_1.default.function_, is_1.default.undefined], options.https.checkServerIdentity);
	            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificateAuthority);
	            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.key);
	            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificate);
	            is_1.assert.any([is_1.default.string, is_1.default.undefined], options.https.passphrase);
	            is_1.assert.any([is_1.default.string, is_1.default.buffer, is_1.default.array, is_1.default.undefined], options.https.pfx);
	        }
	        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cacheOptions);
	        // `options.method`
	        if (is_1.default.string(options.method)) {
	            options.method = options.method.toUpperCase();
	        }
	        else {
	            options.method = 'GET';
	        }
	        // `options.headers`
	        if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {
	            options.headers = { ...options.headers };
	        }
	        else {
	            options.headers = lowercaseKeys({ ...(defaults === null || defaults === void 0 ? void 0 : defaults.headers), ...options.headers });
	        }
	        // Disallow legacy `url.Url`
	        if ('slashes' in options) {
	            throw new TypeError('The legacy `url.Url` has been deprecated. Use `URL` instead.');
	        }
	        // `options.auth`
	        if ('auth' in options) {
	            throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');
	        }
	        // `options.searchParams`
	        if ('searchParams' in options) {
	            if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {
	                let searchParameters;
	                if (is_1.default.string(options.searchParams) || (options.searchParams instanceof url_1.URLSearchParams)) {
	                    searchParameters = new url_1.URLSearchParams(options.searchParams);
	                }
	                else {
	                    validateSearchParameters(options.searchParams);
	                    searchParameters = new url_1.URLSearchParams();
	                    // eslint-disable-next-line guard-for-in
	                    for (const key in options.searchParams) {
	                        const value = options.searchParams[key];
	                        if (value === null) {
	                            searchParameters.append(key, '');
	                        }
	                        else if (value !== undefined) {
	                            searchParameters.append(key, value);
	                        }
	                    }
	                }
	                // `normalizeArguments()` is also used to merge options
	                (_a = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => {
	                    // Only use default if one isn't already defined
	                    if (!searchParameters.has(key)) {
	                        searchParameters.append(key, value);
	                    }
	                });
	                options.searchParams = searchParameters;
	            }
	        }
	        // `options.username` & `options.password`
	        options.username = (_b = options.username) !== null && _b !== void 0 ? _b : '';
	        options.password = (_c = options.password) !== null && _c !== void 0 ? _c : '';
	        // `options.prefixUrl` & `options.url`
	        if (is_1.default.undefined(options.prefixUrl)) {
	            options.prefixUrl = (_d = defaults === null || defaults === void 0 ? void 0 : defaults.prefixUrl) !== null && _d !== void 0 ? _d : '';
	        }
	        else {
	            options.prefixUrl = options.prefixUrl.toString();
	            if (options.prefixUrl !== '' && !options.prefixUrl.endsWith('/')) {
	                options.prefixUrl += '/';
	            }
	        }
	        if (is_1.default.string(options.url)) {
	            if (options.url.startsWith('/')) {
	                throw new Error('`input` must not start with a slash when using `prefixUrl`');
	            }
	            options.url = options_to_url_1.default(options.prefixUrl + options.url, options);
	        }
	        else if ((is_1.default.undefined(options.url) && options.prefixUrl !== '') || options.protocol) {
	            options.url = options_to_url_1.default(options.prefixUrl, options);
	        }
	        if (options.url) {
	            if ('port' in options) {
	                delete options.port;
	            }
	            // Make it possible to change `options.prefixUrl`
	            let { prefixUrl } = options;
	            Object.defineProperty(options, 'prefixUrl', {
	                set: (value) => {
	                    const url = options.url;
	                    if (!url.href.startsWith(value)) {
	                        throw new Error(`Cannot change \`prefixUrl\` from ${prefixUrl} to ${value}: ${url.href}`);
	                    }
	                    options.url = new url_1.URL(value + url.href.slice(prefixUrl.length));
	                    prefixUrl = value;
	                },
	                get: () => prefixUrl
	            });
	            // Support UNIX sockets
	            let { protocol } = options.url;
	            if (protocol === 'unix:') {
	                protocol = 'http:';
	                options.url = new url_1.URL(`http://unix${options.url.pathname}${options.url.search}`);
	            }
	            // Set search params
	            if (options.searchParams) {
	                // eslint-disable-next-line @typescript-eslint/no-base-to-string
	                options.url.search = options.searchParams.toString();
	            }
	            // Protocol check
	            if (protocol !== 'http:' && protocol !== 'https:') {
	                throw new UnsupportedProtocolError(options);
	            }
	            // Update `username`
	            if (options.username === '') {
	                options.username = options.url.username;
	            }
	            else {
	                options.url.username = options.username;
	            }
	            // Update `password`
	            if (options.password === '') {
	                options.password = options.url.password;
	            }
	            else {
	                options.url.password = options.password;
	            }
	        }
	        // `options.cookieJar`
	        const { cookieJar } = options;
	        if (cookieJar) {
	            let { setCookie, getCookieString } = cookieJar;
	            is_1.assert.function_(setCookie);
	            is_1.assert.function_(getCookieString);
	            /* istanbul ignore next: Horrible `tough-cookie` v3 check */
	            if (setCookie.length === 4 && getCookieString.length === 0) {
	                setCookie = util_1.promisify(setCookie.bind(options.cookieJar));
	                getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));
	                options.cookieJar = {
	                    setCookie,
	                    getCookieString: getCookieString
	                };
	            }
	        }
	        // `options.cache`
	        const { cache } = options;
	        if (cache) {
	            if (!cacheableStore.has(cache)) {
	                cacheableStore.set(cache, new CacheableRequest(((requestOptions, handler) => {
	                    const result = requestOptions[kRequest](requestOptions, handler);
	                    // TODO: remove this when `cacheable-request` supports async request functions.
	                    if (is_1.default.promise(result)) {
	                        // @ts-expect-error
	                        // We only need to implement the error handler in order to support HTTP2 caching.
	                        // The result will be a promise anyway.
	                        result.once = (event, handler) => {
	                            if (event === 'error') {
	                                result.catch(handler);
	                            }
	                            else if (event === 'abort') {
	                                // The empty catch is needed here in case when
	                                // it rejects before it's `await`ed in `_makeRequest`.
	                                (async () => {
	                                    try {
	                                        const request = (await result);
	                                        request.once('abort', handler);
	                                    }
	                                    catch (_a) { }
	                                })();
	                            }
	                            else {
	                                /* istanbul ignore next: safety check */
	                                throw new Error(`Unknown HTTP2 promise event: ${event}`);
	                            }
	                            return result;
	                        };
	                    }
	                    return result;
	                }), cache));
	            }
	        }
	        // `options.cacheOptions`
	        options.cacheOptions = { ...options.cacheOptions };
	        // `options.dnsCache`
	        if (options.dnsCache === true) {
	            if (!globalDnsCache) {
	                globalDnsCache = new cacheable_lookup_1.default();
	            }
	            options.dnsCache = globalDnsCache;
	        }
	        else if (!is_1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {
	            throw new TypeError(`Parameter \`dnsCache\` must be a CacheableLookup instance or a boolean, got ${is_1.default(options.dnsCache)}`);
	        }
	        // `options.timeout`
	        if (is_1.default.number(options.timeout)) {
	            options.timeout = { request: options.timeout };
	        }
	        else if (defaults && options.timeout !== defaults.timeout) {
	            options.timeout = {
	                ...defaults.timeout,
	                ...options.timeout
	            };
	        }
	        else {
	            options.timeout = { ...options.timeout };
	        }
	        // `options.context`
	        if (!options.context) {
	            options.context = {};
	        }
	        // `options.hooks`
	        const areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);
	        options.hooks = { ...options.hooks };
	        for (const event of exports.knownHookEvents) {
	            if (event in options.hooks) {
	                if (is_1.default.array(options.hooks[event])) {
	                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
	                    options.hooks[event] = [...options.hooks[event]];
	                }
	                else {
	                    throw new TypeError(`Parameter \`${event}\` must be an Array, got ${is_1.default(options.hooks[event])}`);
	                }
	            }
	            else {
	                options.hooks[event] = [];
	            }
	        }
	        if (defaults && !areHooksDefault) {
	            for (const event of exports.knownHookEvents) {
	                const defaultHooks = defaults.hooks[event];
	                if (defaultHooks.length > 0) {
	                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
	                    options.hooks[event] = [
	                        ...defaults.hooks[event],
	                        ...options.hooks[event]
	                    ];
	                }
	            }
	        }
	        // DNS options
	        if ('family' in options) {
	            deprecation_warning_1.default('"options.family" was never documented, please use "options.dnsLookupIpVersion"');
	        }
	        // HTTPS options
	        if (defaults === null || defaults === void 0 ? void 0 : defaults.https) {
	            options.https = { ...defaults.https, ...options.https };
	        }
	        if ('rejectUnauthorized' in options) {
	            deprecation_warning_1.default('"options.rejectUnauthorized" is now deprecated, please use "options.https.rejectUnauthorized"');
	        }
	        if ('checkServerIdentity' in options) {
	            deprecation_warning_1.default('"options.checkServerIdentity" was never documented, please use "options.https.checkServerIdentity"');
	        }
	        if ('ca' in options) {
	            deprecation_warning_1.default('"options.ca" was never documented, please use "options.https.certificateAuthority"');
	        }
	        if ('key' in options) {
	            deprecation_warning_1.default('"options.key" was never documented, please use "options.https.key"');
	        }
	        if ('cert' in options) {
	            deprecation_warning_1.default('"options.cert" was never documented, please use "options.https.certificate"');
	        }
	        if ('passphrase' in options) {
	            deprecation_warning_1.default('"options.passphrase" was never documented, please use "options.https.passphrase"');
	        }
	        if ('pfx' in options) {
	            deprecation_warning_1.default('"options.pfx" was never documented, please use "options.https.pfx"');
	        }
	        // Other options
	        if ('followRedirects' in options) {
	            throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
	        }
	        if (options.agent) {
	            for (const key in options.agent) {
	                if (key !== 'http' && key !== 'https' && key !== 'http2') {
	                    throw new TypeError(`Expected the \`options.agent\` properties to be \`http\`, \`https\` or \`http2\`, got \`${key}\``);
	                }
	            }
	        }
	        options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;
	        // Set non-enumerable properties
	        exports.setNonEnumerableProperties([defaults, rawOptions], options);
	        return normalize_arguments_1.default(options, defaults);
	    }
	    _lockWrite() {
	        const onLockedWrite = () => {
	            throw new TypeError('The payload has been already provided');
	        };
	        this.write = onLockedWrite;
	        this.end = onLockedWrite;
	    }
	    _unlockWrite() {
	        this.write = super.write;
	        this.end = super.end;
	    }
	    async _finalizeBody() {
	        const { options } = this;
	        const { headers } = options;
	        const isForm = !is_1.default.undefined(options.form);
	        const isJSON = !is_1.default.undefined(options.json);
	        const isBody = !is_1.default.undefined(options.body);
	        const hasPayload = isForm || isJSON || isBody;
	        const cannotHaveBody = exports.withoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);
	        this._cannotHaveBody = cannotHaveBody;
	        if (hasPayload) {
	            if (cannotHaveBody) {
	                throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
	            }
	            if ([isBody, isForm, isJSON].filter(isTrue => isTrue).length > 1) {
	                throw new TypeError('The `body`, `json` and `form` options are mutually exclusive');
	            }
	            if (isBody &&
	                !(options.body instanceof stream_1.Readable) &&
	                !is_1.default.string(options.body) &&
	                !is_1.default.buffer(options.body) &&
	                !is_form_data_1.default(options.body)) {
	                throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');
	            }
	            if (isForm && !is_1.default.object(options.form)) {
	                throw new TypeError('The `form` option must be an Object');
	            }
	            {
	                // Serialize body
	                const noContentType = !is_1.default.string(headers['content-type']);
	                if (isBody) {
	                    // Special case for https://github.com/form-data/form-data
	                    if (is_form_data_1.default(options.body) && noContentType) {
	                        headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
	                    }
	                    this[kBody] = options.body;
	                }
	                else if (isForm) {
	                    if (noContentType) {
	                        headers['content-type'] = 'application/x-www-form-urlencoded';
	                    }
	                    this[kBody] = (new url_1.URLSearchParams(options.form)).toString();
	                }
	                else {
	                    if (noContentType) {
	                        headers['content-type'] = 'application/json';
	                    }
	                    this[kBody] = options.stringifyJson(options.json);
	                }
	                const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);
	                // See https://tools.ietf.org/html/rfc7230#section-3.3.2
	                // A user agent SHOULD send a Content-Length in a request message when
	                // no Transfer-Encoding is sent and the request method defines a meaning
	                // for an enclosed payload body.  For example, a Content-Length header
	                // field is normally sent in a POST request even when the value is 0
	                // (indicating an empty payload body).  A user agent SHOULD NOT send a
	                // Content-Length header field when the request message does not contain
	                // a payload body and the method semantics do not anticipate such a
	                // body.
	                if (is_1.default.undefined(headers['content-length']) && is_1.default.undefined(headers['transfer-encoding'])) {
	                    if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {
	                        headers['content-length'] = String(uploadBodySize);
	                    }
	                }
	            }
	        }
	        else if (cannotHaveBody) {
	            this._lockWrite();
	        }
	        else {
	            this._unlockWrite();
	        }
	        this[kBodySize] = Number(headers['content-length']) || undefined;
	    }
	    async _onResponseBase(response) {
	        const { options } = this;
	        const { url } = options;
	        this[kOriginalResponse] = response;
	        if (options.decompress) {
	            response = decompressResponse$1(response);
	        }
	        const statusCode = response.statusCode;
	        const typedResponse = response;
	        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];
	        typedResponse.url = options.url.toString();
	        typedResponse.requestUrl = this.requestUrl;
	        typedResponse.redirectUrls = this.redirects;
	        typedResponse.request = this;
	        typedResponse.isFromCache = response.fromCache || false;
	        typedResponse.ip = this.ip;
	        typedResponse.retryCount = this.retryCount;
	        this[kIsFromCache] = typedResponse.isFromCache;
	        this[kResponseSize] = Number(response.headers['content-length']) || undefined;
	        this[kResponse] = response;
	        response.once('end', () => {
	            this[kResponseSize] = this[kDownloadedSize];
	            this.emit('downloadProgress', this.downloadProgress);
	        });
	        response.once('error', (error) => {
	            // Force clean-up, because some packages don't do this.
	            // TODO: Fix decompress-response
	            response.destroy();
	            this._beforeError(new ReadError(error, this));
	        });
	        response.once('aborted', () => {
	            this._beforeError(new ReadError({
	                name: 'Error',
	                message: 'The server aborted pending request',
	                code: 'ECONNRESET'
	            }, this));
	        });
	        this.emit('downloadProgress', this.downloadProgress);
	        const rawCookies = response.headers['set-cookie'];
	        if (is_1.default.object(options.cookieJar) && rawCookies) {
	            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
	            if (options.ignoreInvalidCookies) {
	                promises = promises.map(async (p) => p.catch(() => { }));
	            }
	            try {
	                await Promise.all(promises);
	            }
	            catch (error) {
	                this._beforeError(error);
	                return;
	            }
	        }
	        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
	            // We're being redirected, we don't care about the response.
	            // It'd be best to abort the request, but we can't because
	            // we would have to sacrifice the TCP connection. We don't want that.
	            response.resume();
	            if (this[kRequest]) {
	                this[kCancelTimeouts]();
	                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
	                delete this[kRequest];
	                this[kUnproxyEvents]();
	            }
	            const shouldBeGet = statusCode === 303 && options.method !== 'GET' && options.method !== 'HEAD';
	            if (shouldBeGet || !options.methodRewriting) {
	                // Server responded with "see other", indicating that the resource exists at another location,
	                // and the client should request it from that location via GET or HEAD.
	                options.method = 'GET';
	                if ('body' in options) {
	                    delete options.body;
	                }
	                if ('json' in options) {
	                    delete options.json;
	                }
	                if ('form' in options) {
	                    delete options.form;
	                }
	                this[kBody] = undefined;
	                delete options.headers['content-length'];
	            }
	            if (this.redirects.length >= options.maxRedirects) {
	                this._beforeError(new MaxRedirectsError(this));
	                return;
	            }
	            try {
	                // Do not remove. See https://github.com/sindresorhus/got/pull/214
	                const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();
	                // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604
	                const redirectUrl = new url_1.URL(redirectBuffer, url);
	                const redirectString = redirectUrl.toString();
	                decodeURI(redirectString);
	                // eslint-disable-next-line no-inner-declarations
	                function isUnixSocketURL(url) {
	                    return url.protocol === 'unix:' || url.hostname === 'unix';
	                }
	                if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {
	                    this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));
	                    return;
	                }
	                // Redirecting to a different site, clear sensitive data.
	                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
	                    if ('host' in options.headers) {
	                        delete options.headers.host;
	                    }
	                    if ('cookie' in options.headers) {
	                        delete options.headers.cookie;
	                    }
	                    if ('authorization' in options.headers) {
	                        delete options.headers.authorization;
	                    }
	                    if (options.username || options.password) {
	                        options.username = '';
	                        options.password = '';
	                    }
	                }
	                else {
	                    redirectUrl.username = options.username;
	                    redirectUrl.password = options.password;
	                }
	                this.redirects.push(redirectString);
	                options.url = redirectUrl;
	                for (const hook of options.hooks.beforeRedirect) {
	                    // eslint-disable-next-line no-await-in-loop
	                    await hook(options, typedResponse);
	                }
	                this.emit('redirect', typedResponse, options);
	                await this._makeRequest();
	            }
	            catch (error) {
	                this._beforeError(error);
	                return;
	            }
	            return;
	        }
	        if (options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse)) {
	            this._beforeError(new HTTPError(typedResponse));
	            return;
	        }
	        response.on('readable', () => {
	            if (this[kTriggerRead]) {
	                this._read();
	            }
	        });
	        this.on('resume', () => {
	            response.resume();
	        });
	        this.on('pause', () => {
	            response.pause();
	        });
	        response.once('end', () => {
	            this.push(null);
	        });
	        this.emit('response', response);
	        for (const destination of this[kServerResponsesPiped]) {
	            if (destination.headersSent) {
	                continue;
	            }
	            // eslint-disable-next-line guard-for-in
	            for (const key in response.headers) {
	                const isAllowed = options.decompress ? key !== 'content-encoding' : true;
	                const value = response.headers[key];
	                if (isAllowed) {
	                    destination.setHeader(key, value);
	                }
	            }
	            destination.statusCode = statusCode;
	        }
	    }
	    async _onResponse(response) {
	        try {
	            await this._onResponseBase(response);
	        }
	        catch (error) {
	            /* istanbul ignore next: better safe than sorry */
	            this._beforeError(error);
	        }
	    }
	    _onRequest(request) {
	        const { options } = this;
	        const { timeout, url } = options;
	        http_timer_1.default(request);
	        this[kCancelTimeouts] = timed_out_1.default(request, timeout, url);
	        const responseEventName = options.cache ? 'cacheableResponse' : 'response';
	        request.once(responseEventName, (response) => {
	            void this._onResponse(response);
	        });
	        request.once('error', (error) => {
	            var _a;
	            // Force clean-up, because some packages (e.g. nock) don't do this.
	            request.destroy();
	            // Node.js <= 12.18.2 mistakenly emits the response `end` first.
	            (_a = request.res) === null || _a === void 0 ? void 0 : _a.removeAllListeners('end');
	            error = error instanceof timed_out_1.TimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);
	            this._beforeError(error);
	        });
	        this[kUnproxyEvents] = proxy_events_1.default(request, this, proxiedRequestEvents);
	        this[kRequest] = request;
	        this.emit('uploadProgress', this.uploadProgress);
	        // Send body
	        const body = this[kBody];
	        const currentRequest = this.redirects.length === 0 ? this : request;
	        if (is_1.default.nodeStream(body)) {
	            body.pipe(currentRequest);
	            body.once('error', (error) => {
	                this._beforeError(new UploadError(error, this));
	            });
	        }
	        else {
	            this._unlockWrite();
	            if (!is_1.default.undefined(body)) {
	                this._writeRequest(body, undefined, () => { });
	                currentRequest.end();
	                this._lockWrite();
	            }
	            else if (this._cannotHaveBody || this._noPipe) {
	                currentRequest.end();
	                this._lockWrite();
	            }
	        }
	        this.emit('request', request);
	    }
	    async _createCacheableRequest(url, options) {
	        return new Promise((resolve, reject) => {
	            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed
	            Object.assign(options, url_to_options_1.default(url));
	            // `http-cache-semantics` checks this
	            // TODO: Fix this ignore.
	            // @ts-expect-error
	            delete options.url;
	            let request;
	            // This is ugly
	            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
	                // TODO: Fix `cacheable-response`
	                response._readableState.autoDestroy = false;
	                if (request) {
	                    (await request).emit('cacheableResponse', response);
	                }
	                resolve(response);
	            });
	            // Restore options
	            options.url = url;
	            cacheRequest.once('error', reject);
	            cacheRequest.once('request', async (requestOrPromise) => {
	                request = requestOrPromise;
	                resolve(request);
	            });
	        });
	    }
	    async _makeRequest() {
	        var _a, _b, _c, _d, _e;
	        const { options } = this;
	        const { headers } = options;
	        for (const key in headers) {
	            if (is_1.default.undefined(headers[key])) {
	                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
	                delete headers[key];
	            }
	            else if (is_1.default.null_(headers[key])) {
	                throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
	            }
	        }
	        if (options.decompress && is_1.default.undefined(headers['accept-encoding'])) {
	            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';
	        }
	        // Set cookies
	        if (options.cookieJar) {
	            const cookieString = await options.cookieJar.getCookieString(options.url.toString());
	            if (is_1.default.nonEmptyString(cookieString)) {
	                options.headers.cookie = cookieString;
	            }
	        }
	        for (const hook of options.hooks.beforeRequest) {
	            // eslint-disable-next-line no-await-in-loop
	            const result = await hook(options);
	            if (!is_1.default.undefined(result)) {
	                // @ts-expect-error Skip the type mismatch to support abstract responses
	                options.request = () => result;
	                break;
	            }
	        }
	        if (options.body && this[kBody] !== options.body) {
	            this[kBody] = options.body;
	        }
	        const { agent, request, timeout, url } = options;
	        if (options.dnsCache && !('lookup' in options)) {
	            options.lookup = options.dnsCache.lookup;
	        }
	        // UNIX sockets
	        if (url.hostname === 'unix') {
	            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
	            if (matches === null || matches === void 0 ? void 0 : matches.groups) {
	                const { socketPath, path } = matches.groups;
	                Object.assign(options, {
	                    socketPath,
	                    path,
	                    host: ''
	                });
	            }
	        }
	        const isHttps = url.protocol === 'https:';
	        // Fallback function
	        let fallbackFn;
	        if (options.http2) {
	            fallbackFn = http2wrapper.auto;
	        }
	        else {
	            fallbackFn = isHttps ? https.request : http.request;
	        }
	        const realFn = (_a = options.request) !== null && _a !== void 0 ? _a : fallbackFn;
	        // Cache support
	        const fn = options.cache ? this._createCacheableRequest : realFn;
	        // Pass an agent directly when HTTP2 is disabled
	        if (agent && !options.http2) {
	            options.agent = agent[isHttps ? 'https' : 'http'];
	        }
	        // Prepare plain HTTP request options
	        options[kRequest] = realFn;
	        delete options.request;
	        // TODO: Fix this ignore.
	        // @ts-expect-error
	        delete options.timeout;
	        const requestOptions = options;
	        requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;
	        requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;
	        requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;
	        requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;
	        // If `dnsLookupIpVersion` is not present do not override `family`
	        if (options.dnsLookupIpVersion !== undefined) {
	            try {
	                requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);
	            }
	            catch (_f) {
	                throw new Error('Invalid `dnsLookupIpVersion` option value');
	            }
	        }
	        // HTTPS options remapping
	        if (options.https) {
	            if ('rejectUnauthorized' in options.https) {
	                requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;
	            }
	            if (options.https.checkServerIdentity) {
	                requestOptions.checkServerIdentity = options.https.checkServerIdentity;
	            }
	            if (options.https.certificateAuthority) {
	                requestOptions.ca = options.https.certificateAuthority;
	            }
	            if (options.https.certificate) {
	                requestOptions.cert = options.https.certificate;
	            }
	            if (options.https.key) {
	                requestOptions.key = options.https.key;
	            }
	            if (options.https.passphrase) {
	                requestOptions.passphrase = options.https.passphrase;
	            }
	            if (options.https.pfx) {
	                requestOptions.pfx = options.https.pfx;
	            }
	        }
	        try {
	            let requestOrResponse = await fn(url, requestOptions);
	            if (is_1.default.undefined(requestOrResponse)) {
	                requestOrResponse = fallbackFn(url, requestOptions);
	            }
	            // Restore options
	            options.request = request;
	            options.timeout = timeout;
	            options.agent = agent;
	            // HTTPS options restore
	            if (options.https) {
	                if ('rejectUnauthorized' in options.https) {
	                    delete requestOptions.rejectUnauthorized;
	                }
	                if (options.https.checkServerIdentity) {
	                    // @ts-expect-error - This one will be removed when we remove the alias.
	                    delete requestOptions.checkServerIdentity;
	                }
	                if (options.https.certificateAuthority) {
	                    delete requestOptions.ca;
	                }
	                if (options.https.certificate) {
	                    delete requestOptions.cert;
	                }
	                if (options.https.key) {
	                    delete requestOptions.key;
	                }
	                if (options.https.passphrase) {
	                    delete requestOptions.passphrase;
	                }
	                if (options.https.pfx) {
	                    delete requestOptions.pfx;
	                }
	            }
	            if (isClientRequest(requestOrResponse)) {
	                this._onRequest(requestOrResponse);
	                // Emit the response after the stream has been ended
	            }
	            else if (this.writable) {
	                this.once('finish', () => {
	                    void this._onResponse(requestOrResponse);
	                });
	                this._unlockWrite();
	                this.end();
	                this._lockWrite();
	            }
	            else {
	                void this._onResponse(requestOrResponse);
	            }
	        }
	        catch (error) {
	            if (error instanceof CacheableRequest.CacheError) {
	                throw new CacheError(error, this);
	            }
	            throw new RequestError(error.message, error, this);
	        }
	    }
	    async _error(error) {
	        try {
	            for (const hook of this.options.hooks.beforeError) {
	                // eslint-disable-next-line no-await-in-loop
	                error = await hook(error);
	            }
	        }
	        catch (error_) {
	            error = new RequestError(error_.message, error_, this);
	        }
	        this.destroy(error);
	    }
	    _beforeError(error) {
	        if (this[kStopReading]) {
	            return;
	        }
	        const { options } = this;
	        const retryCount = this.retryCount + 1;
	        this[kStopReading] = true;
	        if (!(error instanceof RequestError)) {
	            error = new RequestError(error.message, error, this);
	        }
	        const typedError = error;
	        const { response } = typedError;
	        void (async () => {
	            if (response && !response.body) {
	                response.setEncoding(this._readableState.encoding);
	                try {
	                    response.rawBody = await get_buffer_1.default(response);
	                    response.body = response.rawBody.toString();
	                }
	                catch (_a) { }
	            }
	            if (this.listenerCount('retry') !== 0) {
	                let backoff;
	                try {
	                    let retryAfter;
	                    if (response && 'retry-after' in response.headers) {
	                        retryAfter = Number(response.headers['retry-after']);
	                        if (Number.isNaN(retryAfter)) {
	                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();
	                            if (retryAfter <= 0) {
	                                retryAfter = 1;
	                            }
	                        }
	                        else {
	                            retryAfter *= 1000;
	                        }
	                    }
	                    backoff = await options.retry.calculateDelay({
	                        attemptCount: retryCount,
	                        retryOptions: options.retry,
	                        error: typedError,
	                        retryAfter,
	                        computedValue: calculate_retry_delay_1.default({
	                            attemptCount: retryCount,
	                            retryOptions: options.retry,
	                            error: typedError,
	                            retryAfter,
	                            computedValue: 0
	                        })
	                    });
	                }
	                catch (error_) {
	                    void this._error(new RequestError(error_.message, error_, this));
	                    return;
	                }
	                if (backoff) {
	                    const retry = async () => {
	                        try {
	                            for (const hook of this.options.hooks.beforeRetry) {
	                                // eslint-disable-next-line no-await-in-loop
	                                await hook(this.options, typedError, retryCount);
	                            }
	                        }
	                        catch (error_) {
	                            void this._error(new RequestError(error_.message, error, this));
	                            return;
	                        }
	                        // Something forced us to abort the retry
	                        if (this.destroyed) {
	                            return;
	                        }
	                        this.destroy();
	                        this.emit('retry', retryCount, error);
	                    };
	                    this[kRetryTimeout] = setTimeout(retry, backoff);
	                    return;
	                }
	            }
	            void this._error(typedError);
	        })();
	    }
	    _read() {
	        this[kTriggerRead] = true;
	        const response = this[kResponse];
	        if (response && !this[kStopReading]) {
	            // We cannot put this in the `if` above
	            // because `.read()` also triggers the `end` event
	            if (response.readableLength) {
	                this[kTriggerRead] = false;
	            }
	            let data;
	            while ((data = response.read()) !== null) {
	                this[kDownloadedSize] += data.length;
	                this[kStartedReading] = true;
	                const progress = this.downloadProgress;
	                if (progress.percent < 1) {
	                    this.emit('downloadProgress', progress);
	                }
	                this.push(data);
	            }
	        }
	    }
	    // Node.js 12 has incorrect types, so the encoding must be a string
	    _write(chunk, encoding, callback) {
	        const write = () => {
	            this._writeRequest(chunk, encoding, callback);
	        };
	        if (this.requestInitialized) {
	            write();
	        }
	        else {
	            this[kJobs].push(write);
	        }
	    }
	    _writeRequest(chunk, encoding, callback) {
	        if (this[kRequest].destroyed) {
	            // Probably the `ClientRequest` instance will throw
	            return;
	        }
	        this._progressCallbacks.push(() => {
	            this[kUploadedSize] += Buffer.byteLength(chunk, encoding);
	            const progress = this.uploadProgress;
	            if (progress.percent < 1) {
	                this.emit('uploadProgress', progress);
	            }
	        });
	        // TODO: What happens if it's from cache? Then this[kRequest] won't be defined.
	        this[kRequest].write(chunk, encoding, (error) => {
	            if (!error && this._progressCallbacks.length > 0) {
	                this._progressCallbacks.shift()();
	            }
	            callback(error);
	        });
	    }
	    _final(callback) {
	        const endRequest = () => {
	            // FIX: Node.js 10 calls the write callback AFTER the end callback!
	            while (this._progressCallbacks.length !== 0) {
	                this._progressCallbacks.shift()();
	            }
	            // We need to check if `this[kRequest]` is present,
	            // because it isn't when we use cache.
	            if (!(kRequest in this)) {
	                callback();
	                return;
	            }
	            if (this[kRequest].destroyed) {
	                callback();
	                return;
	            }
	            this[kRequest].end((error) => {
	                if (!error) {
	                    this[kBodySize] = this[kUploadedSize];
	                    this.emit('uploadProgress', this.uploadProgress);
	                    this[kRequest].emit('upload-complete');
	                }
	                callback(error);
	            });
	        };
	        if (this.requestInitialized) {
	            endRequest();
	        }
	        else {
	            this[kJobs].push(endRequest);
	        }
	    }
	    _destroy(error, callback) {
	        var _a;
	        this[kStopReading] = true;
	        // Prevent further retries
	        clearTimeout(this[kRetryTimeout]);
	        if (kRequest in this) {
	            this[kCancelTimeouts]();
	            // TODO: Remove the next `if` when these get fixed:
	            // - https://github.com/nodejs/node/issues/32851
	            if (!((_a = this[kResponse]) === null || _a === void 0 ? void 0 : _a.complete)) {
	                this[kRequest].destroy();
	            }
	        }
	        if (error !== null && !is_1.default.undefined(error) && !(error instanceof RequestError)) {
	            error = new RequestError(error.message, error, this);
	        }
	        callback(error);
	    }
	    get _isAboutToError() {
	        return this[kStopReading];
	    }
	    /**
	    The remote IP address.
	    */
	    get ip() {
	        var _a;
	        return (_a = this.socket) === null || _a === void 0 ? void 0 : _a.remoteAddress;
	    }
	    /**
	    Indicates whether the request has been aborted or not.
	    */
	    get aborted() {
	        var _a, _b, _c;
	        return ((_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);
	    }
	    get socket() {
	        var _a, _b;
	        return (_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket) !== null && _b !== void 0 ? _b : undefined;
	    }
	    /**
	    Progress event for downloading (receiving a response).
	    */
	    get downloadProgress() {
	        let percent;
	        if (this[kResponseSize]) {
	            percent = this[kDownloadedSize] / this[kResponseSize];
	        }
	        else if (this[kResponseSize] === this[kDownloadedSize]) {
	            percent = 1;
	        }
	        else {
	            percent = 0;
	        }
	        return {
	            percent,
	            transferred: this[kDownloadedSize],
	            total: this[kResponseSize]
	        };
	    }
	    /**
	    Progress event for uploading (sending a request).
	    */
	    get uploadProgress() {
	        let percent;
	        if (this[kBodySize]) {
	            percent = this[kUploadedSize] / this[kBodySize];
	        }
	        else if (this[kBodySize] === this[kUploadedSize]) {
	            percent = 1;
	        }
	        else {
	            percent = 0;
	        }
	        return {
	            percent,
	            transferred: this[kUploadedSize],
	            total: this[kBodySize]
	        };
	    }
	    /**
	    The object contains the following properties:

	    - `start` - Time when the request started.
	    - `socket` - Time when a socket was assigned to the request.
	    - `lookup` - Time when the DNS lookup finished.
	    - `connect` - Time when the socket successfully connected.
	    - `secureConnect` - Time when the socket securely connected.
	    - `upload` - Time when the request finished uploading.
	    - `response` - Time when the request fired `response` event.
	    - `end` - Time when the response fired `end` event.
	    - `error` - Time when the request fired `error` event.
	    - `abort` - Time when the request fired `abort` event.
	    - `phases`
	        - `wait` - `timings.socket - timings.start`
	        - `dns` - `timings.lookup - timings.socket`
	        - `tcp` - `timings.connect - timings.lookup`
	        - `tls` - `timings.secureConnect - timings.connect`
	        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
	        - `firstByte` - `timings.response - timings.upload`
	        - `download` - `timings.end - timings.response`
	        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`

	    If something has not been measured yet, it will be `undefined`.

	    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
	    */
	    get timings() {
	        var _a;
	        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.timings;
	    }
	    /**
	    Whether the response was retrieved from the cache.
	    */
	    get isFromCache() {
	        return this[kIsFromCache];
	    }
	    pipe(destination, options) {
	        if (this[kStartedReading]) {
	            throw new Error('Failed to pipe. The response has been emitted already.');
	        }
	        if (destination instanceof http_1.ServerResponse) {
	            this[kServerResponsesPiped].add(destination);
	        }
	        return super.pipe(destination, options);
	    }
	    unpipe(destination) {
	        if (destination instanceof http_1.ServerResponse) {
	            this[kServerResponsesPiped].delete(destination);
	        }
	        super.unpipe(destination);
	        return this;
	    }
	}
	exports.default = Request; 
} (core));

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types$1;
	hasRequiredTypes$1 = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CancelError = exports.ParseError = void 0;
		const core_1 = core;
		/**
		An error to be thrown when server response code is 2xx, and parsing body fails.
		Includes a `response` property.
		*/
		class ParseError extends core_1.RequestError {
		    constructor(error, response) {
		        const { options } = response.request;
		        super(`${error.message} in "${options.url.toString()}"`, error, response.request);
		        this.name = 'ParseError';
		        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_BODY_PARSE_FAILURE' : this.code;
		    }
		}
		exports.ParseError = ParseError;
		/**
		An error to be thrown when the request is aborted with `.cancel()`.
		*/
		class CancelError extends core_1.RequestError {
		    constructor(request) {
		        super('Promise was canceled', {}, request);
		        this.name = 'CancelError';
		        this.code = 'ERR_CANCELED';
		    }
		    get isCanceled() {
		        return true;
		    }
		}
		exports.CancelError = CancelError;
		__exportStar(core, exports); 
	} (types$1));
	return types$1;
}

var parseBody = {};

var hasRequiredParseBody;

function requireParseBody () {
	if (hasRequiredParseBody) return parseBody;
	hasRequiredParseBody = 1;
	Object.defineProperty(parseBody, "__esModule", { value: true });
	const types_1 = requireTypes$1();
	const parseBody$1 = (response, responseType, parseJson, encoding) => {
	    const { rawBody } = response;
	    try {
	        if (responseType === 'text') {
	            return rawBody.toString(encoding);
	        }
	        if (responseType === 'json') {
	            return rawBody.length === 0 ? '' : parseJson(rawBody.toString());
	        }
	        if (responseType === 'buffer') {
	            return rawBody;
	        }
	        throw new types_1.ParseError({
	            message: `Unknown body type '${responseType}'`,
	            name: 'Error'
	        }, response);
	    }
	    catch (error) {
	        throw new types_1.ParseError(error, response);
	    }
	};
	parseBody.default = parseBody$1;
	return parseBody;
}

var hasRequiredAsPromise;

function requireAsPromise () {
	if (hasRequiredAsPromise) return asPromise;
	hasRequiredAsPromise = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		const events_1 = require$$0$4;
		const is_1 = distExports;
		const PCancelable = requirePCancelable();
		const types_1 = requireTypes$1();
		const parse_body_1 = requireParseBody();
		const core_1 = core;
		const proxy_events_1 = requireProxyEvents();
		const get_buffer_1 = requireGetBuffer();
		const is_response_ok_1 = requireIsResponseOk();
		const proxiedRequestEvents = [
		    'request',
		    'response',
		    'redirect',
		    'uploadProgress',
		    'downloadProgress'
		];
		function asPromise(normalizedOptions) {
		    let globalRequest;
		    let globalResponse;
		    const emitter = new events_1.EventEmitter();
		    const promise = new PCancelable((resolve, reject, onCancel) => {
		        const makeRequest = (retryCount) => {
		            const request = new core_1.default(undefined, normalizedOptions);
		            request.retryCount = retryCount;
		            request._noPipe = true;
		            onCancel(() => request.destroy());
		            onCancel.shouldReject = false;
		            onCancel(() => reject(new types_1.CancelError(request)));
		            globalRequest = request;
		            request.once('response', async (response) => {
		                var _a;
		                response.retryCount = retryCount;
		                if (response.request.aborted) {
		                    // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error
		                    return;
		                }
		                // Download body
		                let rawBody;
		                try {
		                    rawBody = await get_buffer_1.default(request);
		                    response.rawBody = rawBody;
		                }
		                catch (_b) {
		                    // The same error is caught below.
		                    // See request.once('error')
		                    return;
		                }
		                if (request._isAboutToError) {
		                    return;
		                }
		                // Parse body
		                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();
		                const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);
		                const { options } = request;
		                if (isCompressed && !options.decompress) {
		                    response.body = rawBody;
		                }
		                else {
		                    try {
		                        response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);
		                    }
		                    catch (error) {
		                        // Fallback to `utf8`
		                        response.body = rawBody.toString();
		                        if (is_response_ok_1.isResponseOk(response)) {
		                            request._beforeError(error);
		                            return;
		                        }
		                    }
		                }
		                try {
		                    for (const [index, hook] of options.hooks.afterResponse.entries()) {
		                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise
		                        // eslint-disable-next-line no-await-in-loop
		                        response = await hook(response, async (updatedOptions) => {
		                            const typedOptions = core_1.default.normalizeArguments(undefined, {
		                                ...updatedOptions,
		                                retry: {
		                                    calculateDelay: () => 0
		                                },
		                                throwHttpErrors: false,
		                                resolveBodyOnly: false
		                            }, options);
		                            // Remove any further hooks for that request, because we'll call them anyway.
		                            // The loop continues. We don't want duplicates (asPromise recursion).
		                            typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);
		                            for (const hook of typedOptions.hooks.beforeRetry) {
		                                // eslint-disable-next-line no-await-in-loop
		                                await hook(typedOptions);
		                            }
		                            const promise = asPromise(typedOptions);
		                            onCancel(() => {
		                                promise.catch(() => { });
		                                promise.cancel();
		                            });
		                            return promise;
		                        });
		                    }
		                }
		                catch (error) {
		                    request._beforeError(new types_1.RequestError(error.message, error, request));
		                    return;
		                }
		                globalResponse = response;
		                if (!is_response_ok_1.isResponseOk(response)) {
		                    request._beforeError(new types_1.HTTPError(response));
		                    return;
		                }
		                request.destroy();
		                resolve(request.options.resolveBodyOnly ? response.body : response);
		            });
		            const onError = (error) => {
		                if (promise.isCanceled) {
		                    return;
		                }
		                const { options } = request;
		                if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {
		                    const { response } = error;
		                    resolve(request.options.resolveBodyOnly ? response.body : response);
		                    return;
		                }
		                reject(error);
		            };
		            request.once('error', onError);
		            const previousBody = request.options.body;
		            request.once('retry', (newRetryCount, error) => {
		                var _a, _b;
		                if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {
		                    onError(error);
		                    return;
		                }
		                makeRequest(newRetryCount);
		            });
		            proxy_events_1.default(request, emitter, proxiedRequestEvents);
		        };
		        makeRequest(0);
		    });
		    promise.on = (event, fn) => {
		        emitter.on(event, fn);
		        return promise;
		    };
		    const shortcut = (responseType) => {
		        const newPromise = (async () => {
		            // Wait until downloading has ended
		            await promise;
		            const { options } = globalResponse.request;
		            return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);
		        })();
		        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
		        return newPromise;
		    };
		    promise.json = () => {
		        const { headers } = globalRequest.options;
		        if (!globalRequest.writableFinished && headers.accept === undefined) {
		            headers.accept = 'application/json';
		        }
		        return shortcut('json');
		    };
		    promise.buffer = () => shortcut('buffer');
		    promise.text = () => shortcut('text');
		    return promise;
		}
		exports.default = asPromise;
		__exportStar(requireTypes$1(), exports); 
	} (asPromise));
	return asPromise;
}

var createRejection$1 = {};

Object.defineProperty(createRejection$1, "__esModule", { value: true });
const types_1 = requireTypes$1();
function createRejection(error, ...beforeErrorGroups) {
    const promise = (async () => {
        if (error instanceof types_1.RequestError) {
            try {
                for (const hooks of beforeErrorGroups) {
                    if (hooks) {
                        for (const hook of hooks) {
                            // eslint-disable-next-line no-await-in-loop
                            error = await hook(error);
                        }
                    }
                }
            }
            catch (error_) {
                error = error_;
            }
        }
        throw error;
    })();
    const returnPromise = () => promise;
    promise.json = returnPromise;
    promise.text = returnPromise;
    promise.buffer = returnPromise;
    promise.on = returnPromise;
    return promise;
}
createRejection$1.default = createRejection;

var deepFreeze$1 = {};

Object.defineProperty(deepFreeze$1, "__esModule", { value: true });
const is_1 = distExports;
function deepFreeze(object) {
    for (const value of Object.values(object)) {
        if (is_1.default.plainObject(value) || is_1.default.array(value)) {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
}
deepFreeze$1.default = deepFreeze;

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	Object.defineProperty(types, "__esModule", { value: true });
	return types;
}

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.defaultHandler = void 0;
	const is_1 = distExports;
	const as_promise_1 = requireAsPromise();
	const create_rejection_1 = createRejection$1;
	const core_1 = core;
	const deep_freeze_1 = deepFreeze$1;
	const errors = {
	    RequestError: as_promise_1.RequestError,
	    CacheError: as_promise_1.CacheError,
	    ReadError: as_promise_1.ReadError,
	    HTTPError: as_promise_1.HTTPError,
	    MaxRedirectsError: as_promise_1.MaxRedirectsError,
	    TimeoutError: as_promise_1.TimeoutError,
	    ParseError: as_promise_1.ParseError,
	    CancelError: as_promise_1.CancelError,
	    UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,
	    UploadError: as_promise_1.UploadError
	};
	// The `delay` package weighs 10KB (!)
	const delay = async (ms) => new Promise(resolve => {
	    setTimeout(resolve, ms);
	});
	const { normalizeArguments } = core_1.default;
	const mergeOptions = (...sources) => {
	    let mergedOptions;
	    for (const source of sources) {
	        mergedOptions = normalizeArguments(undefined, source, mergedOptions);
	    }
	    return mergedOptions;
	};
	const getPromiseOrStream = (options) => options.isStream ? new core_1.default(undefined, options) : as_promise_1.default(options);
	const isGotInstance = (value) => ('defaults' in value && 'options' in value.defaults);
	const aliases = [
	    'get',
	    'post',
	    'put',
	    'patch',
	    'head',
	    'delete'
	];
	exports.defaultHandler = (options, next) => next(options);
	const callInitHooks = (hooks, options) => {
	    if (hooks) {
	        for (const hook of hooks) {
	            hook(options);
	        }
	    }
	};
	const create = (defaults) => {
	    // Proxy properties from next handlers
	    defaults._rawHandlers = defaults.handlers;
	    defaults.handlers = defaults.handlers.map(fn => ((options, next) => {
	        // This will be assigned by assigning result
	        let root;
	        const result = fn(options, newOptions => {
	            root = next(newOptions);
	            return root;
	        });
	        if (result !== root && !options.isStream && root) {
	            const typedResult = result;
	            const { then: promiseThen, catch: promiseCatch, finally: promiseFianlly } = typedResult;
	            Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root));
	            Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root));
	            // These should point to the new promise
	            // eslint-disable-next-line promise/prefer-await-to-then
	            typedResult.then = promiseThen;
	            typedResult.catch = promiseCatch;
	            typedResult.finally = promiseFianlly;
	        }
	        return result;
	    }));
	    // Got interface
	    const got = ((url, options = {}, _defaults) => {
	        var _a, _b;
	        let iteration = 0;
	        const iterateHandlers = (newOptions) => {
	            return defaults.handlers[iteration++](newOptions, iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);
	        };
	        // TODO: Remove this in Got 12.
	        if (is_1.default.plainObject(url)) {
	            const mergedOptions = {
	                ...url,
	                ...options
	            };
	            core_1.setNonEnumerableProperties([url, options], mergedOptions);
	            options = mergedOptions;
	            url = undefined;
	        }
	        try {
	            // Call `init` hooks
	            let initHookError;
	            try {
	                callInitHooks(defaults.options.hooks.init, options);
	                callInitHooks((_a = options.hooks) === null || _a === void 0 ? void 0 : _a.init, options);
	            }
	            catch (error) {
	                initHookError = error;
	            }
	            // Normalize options & call handlers
	            const normalizedOptions = normalizeArguments(url, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults.options);
	            normalizedOptions[core_1.kIsNormalizedAlready] = true;
	            if (initHookError) {
	                throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);
	            }
	            return iterateHandlers(normalizedOptions);
	        }
	        catch (error) {
	            if (options.isStream) {
	                throw error;
	            }
	            else {
	                return create_rejection_1.default(error, defaults.options.hooks.beforeError, (_b = options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);
	            }
	        }
	    });
	    got.extend = (...instancesOrOptions) => {
	        const optionsArray = [defaults.options];
	        let handlers = [...defaults._rawHandlers];
	        let isMutableDefaults;
	        for (const value of instancesOrOptions) {
	            if (isGotInstance(value)) {
	                optionsArray.push(value.defaults.options);
	                handlers.push(...value.defaults._rawHandlers);
	                isMutableDefaults = value.defaults.mutableDefaults;
	            }
	            else {
	                optionsArray.push(value);
	                if ('handlers' in value) {
	                    handlers.push(...value.handlers);
	                }
	                isMutableDefaults = value.mutableDefaults;
	            }
	        }
	        handlers = handlers.filter(handler => handler !== exports.defaultHandler);
	        if (handlers.length === 0) {
	            handlers.push(exports.defaultHandler);
	        }
	        return create({
	            options: mergeOptions(...optionsArray),
	            handlers,
	            mutableDefaults: Boolean(isMutableDefaults)
	        });
	    };
	    // Pagination
	    const paginateEach = (async function* (url, options) {
	        // TODO: Remove this `@ts-expect-error` when upgrading to TypeScript 4.
	        // Error: Argument of type 'Merge<Options, PaginationOptions<T, R>> | undefined' is not assignable to parameter of type 'Options | undefined'.
	        // @ts-expect-error
	        let normalizedOptions = normalizeArguments(url, options, defaults.options);
	        normalizedOptions.resolveBodyOnly = false;
	        const pagination = normalizedOptions.pagination;
	        if (!is_1.default.object(pagination)) {
	            throw new TypeError('`options.pagination` must be implemented');
	        }
	        const all = [];
	        let { countLimit } = pagination;
	        let numberOfRequests = 0;
	        while (numberOfRequests < pagination.requestLimit) {
	            if (numberOfRequests !== 0) {
	                // eslint-disable-next-line no-await-in-loop
	                await delay(pagination.backoff);
	            }
	            // @ts-expect-error FIXME!
	            // TODO: Throw when result is not an instance of Response
	            // eslint-disable-next-line no-await-in-loop
	            const result = (await got(undefined, undefined, normalizedOptions));
	            // eslint-disable-next-line no-await-in-loop
	            const parsed = await pagination.transform(result);
	            const current = [];
	            for (const item of parsed) {
	                if (pagination.filter(item, all, current)) {
	                    if (!pagination.shouldContinue(item, all, current)) {
	                        return;
	                    }
	                    yield item;
	                    if (pagination.stackAllItems) {
	                        all.push(item);
	                    }
	                    current.push(item);
	                    if (--countLimit <= 0) {
	                        return;
	                    }
	                }
	            }
	            const optionsToMerge = pagination.paginate(result, all, current);
	            if (optionsToMerge === false) {
	                return;
	            }
	            if (optionsToMerge === result.request.options) {
	                normalizedOptions = result.request.options;
	            }
	            else if (optionsToMerge !== undefined) {
	                normalizedOptions = normalizeArguments(undefined, optionsToMerge, normalizedOptions);
	            }
	            numberOfRequests++;
	        }
	    });
	    got.paginate = paginateEach;
	    got.paginate.all = (async (url, options) => {
	        const results = [];
	        for await (const item of paginateEach(url, options)) {
	            results.push(item);
	        }
	        return results;
	    });
	    // For those who like very descriptive names
	    got.paginate.each = paginateEach;
	    // Stream API
	    got.stream = ((url, options) => got(url, { ...options, isStream: true }));
	    // Shortcuts
	    for (const method of aliases) {
	        got[method] = ((url, options) => got(url, { ...options, method }));
	        got.stream[method] = ((url, options) => {
	            return got(url, { ...options, method, isStream: true });
	        });
	    }
	    Object.assign(got, errors);
	    Object.defineProperty(got, 'defaults', {
	        value: defaults.mutableDefaults ? defaults : deep_freeze_1.default(defaults),
	        writable: defaults.mutableDefaults,
	        configurable: defaults.mutableDefaults,
	        enumerable: true
	    });
	    got.mergeOptions = mergeOptions;
	    return got;
	};
	exports.default = create;
	__exportStar(requireTypes(), exports); 
} (create));

(function (module, exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	const url_1 = require$$0$5;
	const create_1 = create;
	const defaults = {
	    options: {
	        method: 'GET',
	        retry: {
	            limit: 2,
	            methods: [
	                'GET',
	                'PUT',
	                'HEAD',
	                'DELETE',
	                'OPTIONS',
	                'TRACE'
	            ],
	            statusCodes: [
	                408,
	                413,
	                429,
	                500,
	                502,
	                503,
	                504,
	                521,
	                522,
	                524
	            ],
	            errorCodes: [
	                'ETIMEDOUT',
	                'ECONNRESET',
	                'EADDRINUSE',
	                'ECONNREFUSED',
	                'EPIPE',
	                'ENOTFOUND',
	                'ENETUNREACH',
	                'EAI_AGAIN'
	            ],
	            maxRetryAfter: undefined,
	            calculateDelay: ({ computedValue }) => computedValue
	        },
	        timeout: {},
	        headers: {
	            'user-agent': 'got (https://github.com/sindresorhus/got)'
	        },
	        hooks: {
	            init: [],
	            beforeRequest: [],
	            beforeRedirect: [],
	            beforeRetry: [],
	            beforeError: [],
	            afterResponse: []
	        },
	        cache: undefined,
	        dnsCache: undefined,
	        decompress: true,
	        throwHttpErrors: true,
	        followRedirect: true,
	        isStream: false,
	        responseType: 'text',
	        resolveBodyOnly: false,
	        maxRedirects: 10,
	        prefixUrl: '',
	        methodRewriting: true,
	        ignoreInvalidCookies: false,
	        context: {},
	        // TODO: Set this to `true` when Got 12 gets released
	        http2: false,
	        allowGetBody: false,
	        https: undefined,
	        pagination: {
	            transform: (response) => {
	                if (response.request.options.responseType === 'json') {
	                    return response.body;
	                }
	                return JSON.parse(response.body);
	            },
	            paginate: response => {
	                if (!Reflect.has(response.headers, 'link')) {
	                    return false;
	                }
	                const items = response.headers.link.split(',');
	                let next;
	                for (const item of items) {
	                    const parsed = item.split(';');
	                    if (parsed[1].includes('next')) {
	                        next = parsed[0].trimStart().trim();
	                        next = next.slice(1, -1);
	                        break;
	                    }
	                }
	                if (next) {
	                    const options = {
	                        url: new url_1.URL(next)
	                    };
	                    return options;
	                }
	                return false;
	            },
	            filter: () => true,
	            shouldContinue: () => true,
	            countLimit: Infinity,
	            backoff: 0,
	            requestLimit: 10000,
	            stackAllItems: true
	        },
	        parseJson: (text) => JSON.parse(text),
	        stringifyJson: (object) => JSON.stringify(object),
	        cacheOptions: {}
	    },
	    handlers: [create_1.defaultHandler],
	    mutableDefaults: false
	};
	const got = create_1.default(defaults);
	exports.default = got;
	// For CommonJS default export support
	module.exports = got;
	module.exports.default = got;
	module.exports.__esModule = true; // Workaround for TS issue: https://github.com/sindresorhus/got/pull/1267
	__exportStar(create, exports);
	__exportStar(requireAsPromise(), exports); 
} (source$4, source$4.exports));

var sourceExports = source$4.exports;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.handleError = exports.isBlockfrostErrorResponse = exports.BlockfrostClientError = exports.BlockfrostServerError = exports.SignatureVerificationError = void 0;
	const got_1 = sourceExports;
	class SignatureVerificationError extends Error {
	    constructor(message, detail) {
	        super(message);
	        this.name = 'SignatureVerificationError';
	        this.message = message;
	        this.detail = detail;
	        Object.setPrototypeOf(this, SignatureVerificationError.prototype);
	    }
	}
	exports.SignatureVerificationError = SignatureVerificationError;
	class BlockfrostServerError extends Error {
	    constructor(error) {
	        super(error.message);
	        this.name = 'BlockfrostServerError';
	        this.status_code = error.status_code;
	        this.message = error.message;
	        this.error = error.error;
	        this.url = error.url;
	        this.body = error.body;
	        Object.setPrototypeOf(this, BlockfrostServerError.prototype);
	    }
	}
	exports.BlockfrostServerError = BlockfrostServerError;
	class BlockfrostClientError extends Error {
	    constructor(error) {
	        super(error.message);
	        this.name = 'BlockfrostClientError';
	        this.code = error.code;
	        this.message = error.message;
	        this.url = error.url;
	        Object.setPrototypeOf(this, BlockfrostClientError.prototype);
	    }
	}
	exports.BlockfrostClientError = BlockfrostClientError;
	const hasProp = (
	// eslint-disable-next-line @typescript-eslint/ban-types
	data, prop) => {
	    return prop in data;
	};
	const isBlockfrostErrorResponse = (data) => {
	    // type guard for narrowing response body to an error object that should be returned by Blockfrost API
	    return (typeof data === 'object' &&
	        data !== null &&
	        hasProp(data, 'status_code') &&
	        hasProp(data, 'message') &&
	        hasProp(data, 'error'));
	};
	exports.isBlockfrostErrorResponse = isBlockfrostErrorResponse;
	const handleError = (error) => {
	    var _a, _b, _c;
	    if (error instanceof got_1.HTTPError) {
	        let errorInstance;
	        const url = error.request.requestUrl;
	        const responseBody = error.response.body;
	        if ((0, exports.isBlockfrostErrorResponse)(responseBody)) {
	            errorInstance = new BlockfrostServerError({ ...responseBody, url });
	        }
	        else {
	            // response.body may contain html output (eg. errors returned by nginx)
	            const { statusCode } = error.response;
	            const statusText = (_a = error.response.statusMessage) !== null && _a !== void 0 ? _a : error.message;
	            errorInstance = new BlockfrostServerError({
	                status_code: statusCode,
	                message: `${statusCode}: ${statusText}`,
	                error: statusText,
	                url,
	                // Sometimes original body can be helpful so let's forward it
	                // Eg. communicating directly with Cardano Submit API which returns 400 with the error from cardano-node in the body of the request)
	                body: error.response.body ? error.response.body : undefined,
	            });
	        }
	        // remove undefined body prop so it doesn't pollute string representation of the error
	        if (errorInstance.body === undefined) {
	            delete errorInstance.body;
	        }
	        return errorInstance;
	    }
	    // system errors such as -3008 ENOTFOUND and various got errors like ReadError, CacheError, MaxRedirectsError, TimeoutError,...
	    // https://github.com/sindresorhus/got/blob/main/documentation/8-errors.md
	    return new BlockfrostClientError({
	        code: (_b = error.code) !== null && _b !== void 0 ? _b : 'ERR_GOT_REQUEST_ERROR',
	        message: error.message,
	        url: (_c = error.request) === null || _c === void 0 ? void 0 : _c.requestUrl,
	    });
	};
	exports.handleError = handleError; 
} (errors$1));

Object.defineProperty(accounts$1, "__esModule", { value: true });
accounts$1.accountsAddressesTotal = accounts$1.accountsAddressesAssetsAll = accounts$1.accountsAddressesAssets = accounts$1.accountsAddressesAll = accounts$1.accountsAddresses = accounts$1.accountsRegistrationsAll = accounts$1.accountsRegistrations = accounts$1.accountsDelegationsAll = accounts$1.accountsDelegations = accounts$1.accountsMirsAll = accounts$1.accountsMirs = accounts$1.accountsWithdrawalsAll = accounts$1.accountsWithdrawals = accounts$1.accountsHistoryAll = accounts$1.accountsHistory = accounts$1.accountsRewardsAll = accounts$1.accountsRewards = accounts$1.accounts = void 0;
const utils_1$c = utils;
const errors_1$g = errors$1;
async function accounts(stakeAddress) {
    return new Promise((resolve, reject) => {
        this.instance(`accounts/${stakeAddress}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$g.handleError)(err)));
    });
}
accounts$1.accounts = accounts;
async function accountsRewards(stakeAddress, pagination) {
    const paginationOptions = (0, utils_1$c.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`accounts/${stakeAddress}/rewards`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$g.handleError)(err)));
    });
}
accounts$1.accountsRewards = accountsRewards;
async function accountsRewardsAll(stakeAddress, allMethodOptions) {
    return (0, utils_1$c.paginateMethod)(pagination => this.accountsRewards(stakeAddress, pagination), allMethodOptions);
}
accounts$1.accountsRewardsAll = accountsRewardsAll;
async function accountsHistory(stakeAddress, pagination) {
    const paginationOptions = (0, utils_1$c.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`accounts/${stakeAddress}/history`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$g.handleError)(err)));
    });
}
accounts$1.accountsHistory = accountsHistory;
async function accountsHistoryAll(stakeAddress, allMethodOptions) {
    return (0, utils_1$c.paginateMethod)(pagination => this.accountsHistory(stakeAddress, pagination), allMethodOptions);
}
accounts$1.accountsHistoryAll = accountsHistoryAll;
async function accountsWithdrawals(stakeAddress, pagination) {
    const paginationOptions = (0, utils_1$c.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`accounts/${stakeAddress}/withdrawals`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$g.handleError)(err)));
    });
}
accounts$1.accountsWithdrawals = accountsWithdrawals;
async function accountsWithdrawalsAll(stakeAddress, allMethodOptions) {
    return (0, utils_1$c.paginateMethod)(pagination => this.accountsWithdrawals(stakeAddress, pagination), allMethodOptions);
}
accounts$1.accountsWithdrawalsAll = accountsWithdrawalsAll;
async function accountsMirs(stakeAddress, pagination) {
    const paginationOptions = (0, utils_1$c.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`accounts/${stakeAddress}/mirs`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$g.handleError)(err)));
    });
}
accounts$1.accountsMirs = accountsMirs;
async function accountsMirsAll(stakeAddress, allMethodOptions) {
    return (0, utils_1$c.paginateMethod)(pagination => this.accountsMirs(stakeAddress, pagination), allMethodOptions);
}
accounts$1.accountsMirsAll = accountsMirsAll;
async function accountsDelegations(stakeAddress, pagination) {
    const paginationOptions = (0, utils_1$c.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`accounts/${stakeAddress}/delegations`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$g.handleError)(err)));
    });
}
accounts$1.accountsDelegations = accountsDelegations;
async function accountsDelegationsAll(stakeAddress, allMethodOptions) {
    return (0, utils_1$c.paginateMethod)(pagination => this.accountsDelegations(stakeAddress, pagination), allMethodOptions);
}
accounts$1.accountsDelegationsAll = accountsDelegationsAll;
async function accountsRegistrations(stakeAddress, pagination) {
    const paginationOptions = (0, utils_1$c.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`accounts/${stakeAddress}/registrations`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$g.handleError)(err)));
    });
}
accounts$1.accountsRegistrations = accountsRegistrations;
async function accountsRegistrationsAll(stakeAddress, allMethodOptions) {
    return (0, utils_1$c.paginateMethod)(pagination => this.accountsRegistrations(stakeAddress, pagination), allMethodOptions);
}
accounts$1.accountsRegistrationsAll = accountsRegistrationsAll;
async function accountsAddresses(stakeAddress, pagination) {
    const paginationOptions = (0, utils_1$c.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`accounts/${stakeAddress}/addresses`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$g.handleError)(err)));
    });
}
accounts$1.accountsAddresses = accountsAddresses;
async function accountsAddressesAll(stakeAddress, allMethodOptions) {
    return (0, utils_1$c.paginateMethod)(pagination => this.accountsAddresses(stakeAddress, pagination), allMethodOptions);
}
accounts$1.accountsAddressesAll = accountsAddressesAll;
async function accountsAddressesAssets(stakeAddress, pagination) {
    const paginationOptions = (0, utils_1$c.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`accounts/${stakeAddress}/addresses/assets`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$g.handleError)(err)));
    });
}
accounts$1.accountsAddressesAssets = accountsAddressesAssets;
async function accountsAddressesAssetsAll(stakeAddress, allMethodOptions) {
    return (0, utils_1$c.paginateMethod)(pagination => this.accountsAddressesAssets(stakeAddress, pagination), allMethodOptions);
}
accounts$1.accountsAddressesAssetsAll = accountsAddressesAssetsAll;
async function accountsAddressesTotal(stakeAddress) {
    return new Promise((resolve, reject) => {
        this.instance(`accounts/${stakeAddress}/addresses/total`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$g.handleError)(err)));
    });
}
accounts$1.accountsAddressesTotal = accountsAddressesTotal;

var addresses$1 = {};

Object.defineProperty(addresses$1, "__esModule", { value: true });
addresses$1.addressesUtxosAssetAll = addresses$1.addressesUtxosAsset = addresses$1.addressesUtxosAll = addresses$1.addressesUtxos = addresses$1.addressesTransactionsAll = addresses$1.addressesTransactions = addresses$1.addressesExtended = addresses$1.addressesTotal = addresses$1.addresses = void 0;
const utils_1$b = utils;
const errors_1$f = errors$1;
async function addresses(address) {
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$f.handleError)(err)));
    });
}
addresses$1.addresses = addresses;
async function addressesTotal(address) {
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}/total`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$f.handleError)(err)));
    });
}
addresses$1.addressesTotal = addressesTotal;
async function addressesExtended(address) {
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}/extended`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$f.handleError)(err)));
    });
}
addresses$1.addressesExtended = addressesExtended;
async function addressesTransactions(address, pagination, additionalOptions) {
    const additionalParams = (0, utils_1$b.getAdditionalParams)(additionalOptions);
    const paginationOptions = (0, utils_1$b.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}/transactions`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
                from: additionalParams.from,
                to: additionalParams.to,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            if (err && err.response && err.response.statusCode === 404) {
                resolve([]);
            }
            reject((0, errors_1$f.handleError)(err));
        });
    });
}
addresses$1.addressesTransactions = addressesTransactions;
async function addressesTransactionsAll(address, allMethodOptions, additionalOptions) {
    return (0, utils_1$b.paginateMethod)((pagination, additionalOptions) => this.addressesTransactions(address, pagination, additionalOptions), allMethodOptions, additionalOptions);
}
addresses$1.addressesTransactionsAll = addressesTransactionsAll;
async function addressesUtxos(address, pagination) {
    const paginationOptions = (0, utils_1$b.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}/utxos`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$f.handleError)(err)));
    });
}
addresses$1.addressesUtxos = addressesUtxos;
async function addressesUtxosAll(address, allMethodOptions) {
    return (0, utils_1$b.paginateMethod)(pagination => this.addressesUtxos(address, pagination), allMethodOptions);
}
addresses$1.addressesUtxosAll = addressesUtxosAll;
async function addressesUtxosAsset(address, asset, pagination) {
    // TODO: test is missing since we can't guarantee that list of address's utxos won't change in the future
    const paginationOptions = (0, utils_1$b.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}/utxos/${asset}`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$f.handleError)(err)));
    });
}
addresses$1.addressesUtxosAsset = addressesUtxosAsset;
async function addressesUtxosAssetAll(address, asset, allMethodOptions) {
    return (0, utils_1$b.paginateMethod)(pagination => this.addressesUtxosAsset(address, asset, pagination), allMethodOptions);
}
addresses$1.addressesUtxosAssetAll = addressesUtxosAssetAll;

var assets$1 = {};

Object.defineProperty(assets$1, "__esModule", { value: true });
assets$1.assetsPolicyByIdAll = assets$1.assetsPolicyById = assets$1.assetsAddresses = assets$1.assetsTransactions = assets$1.assetsHistoryAll = assets$1.assetsHistory = assets$1.assetsById = assets$1.assets = void 0;
const utils_1$a = utils;
const errors_1$e = errors$1;
async function assets(pagination) {
    const paginationOptions = (0, utils_1$a.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`assets`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$e.handleError)(err)));
    });
}
assets$1.assets = assets;
async function assetsById(asset) {
    return new Promise((resolve, reject) => {
        this.instance(`assets/${asset}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$e.handleError)(err)));
    });
}
assets$1.assetsById = assetsById;
async function assetsHistory(asset, pagination) {
    const paginationOptions = (0, utils_1$a.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`assets/${asset}/history`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$e.handleError)(err)));
    });
}
assets$1.assetsHistory = assetsHistory;
async function assetsHistoryAll(asset, allMethodOptions) {
    return (0, utils_1$a.paginateMethod)(pagination => this.assetsHistory(asset, pagination), allMethodOptions);
}
assets$1.assetsHistoryAll = assetsHistoryAll;
async function assetsTransactions(asset, pagination) {
    const paginationOptions = (0, utils_1$a.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`assets/${asset}/transactions`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$e.handleError)(err)));
    });
}
assets$1.assetsTransactions = assetsTransactions;
async function assetsAddresses(asset, pagination) {
    const paginationOptions = (0, utils_1$a.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`assets/${asset}/addresses`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$e.handleError)(err)));
    });
}
assets$1.assetsAddresses = assetsAddresses;
async function assetsPolicyById(policy, pagination) {
    const paginationOptions = (0, utils_1$a.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`assets/policy/${policy}`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$e.handleError)(err)));
    });
}
assets$1.assetsPolicyById = assetsPolicyById;
async function assetsPolicyByIdAll(policy, allMethodOptions) {
    return (0, utils_1$a.paginateMethod)(pagination => this.assetsPolicyById(policy, pagination), allMethodOptions);
}
assets$1.assetsPolicyByIdAll = assetsPolicyByIdAll;

var blocks$1 = {};

Object.defineProperty(blocks$1, "__esModule", { value: true });
blocks$1.blocksAddressesAll = blocks$1.blocksAddresses = blocks$1.blocksTxsAll = blocks$1.blocksTxs = blocks$1.blocksPrevious = blocks$1.blocksNext = blocks$1.blocksLatestTxsAll = blocks$1.blocksLatestTxs = blocks$1.blocksLatest = blocks$1.blocks = void 0;
const utils_1$9 = utils;
const errors_1$d = errors$1;
async function blocks(hashOrNumber) {
    return new Promise((resolve, reject) => {
        this.instance(`blocks/${hashOrNumber}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$d.handleError)(err));
        });
    });
}
blocks$1.blocks = blocks;
async function blocksLatest() {
    return new Promise((resolve, reject) => {
        this.instance(`blocks/latest`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$d.handleError)(err));
        });
    });
}
blocks$1.blocksLatest = blocksLatest;
async function blocksLatestTxs(pagination) {
    const paginationOptions = (0, utils_1$9.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`blocks/latest/txs`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            return reject((0, errors_1$d.handleError)(err));
        });
    });
}
blocks$1.blocksLatestTxs = blocksLatestTxs;
async function blocksLatestTxsAll(allMethodOptions) {
    return (0, utils_1$9.paginateMethod)(pagination => this.blocksLatestTxs(pagination), allMethodOptions);
}
blocks$1.blocksLatestTxsAll = blocksLatestTxsAll;
async function blocksNext(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1$9.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`blocks/${hashOrNumber}/next`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$d.handleError)(err));
        });
    });
}
blocks$1.blocksNext = blocksNext;
async function blocksPrevious(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1$9.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`blocks/${hashOrNumber}/previous`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$d.handleError)(err));
        });
    });
}
blocks$1.blocksPrevious = blocksPrevious;
async function blocksTxs(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1$9.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`blocks/${hashOrNumber}/txs`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$d.handleError)(err));
        });
    });
}
blocks$1.blocksTxs = blocksTxs;
async function blocksTxsAll(hashOrNumber, allMethodOptions) {
    return (0, utils_1$9.paginateMethod)(pagination => this.blocksTxs(hashOrNumber, pagination), allMethodOptions);
}
blocks$1.blocksTxsAll = blocksTxsAll;
async function blocksAddresses(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1$9.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`blocks/${hashOrNumber}/addresses`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                // order: paginationOptions.order, // no ordering on /blocks/{hash}/addresses
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$d.handleError)(err));
        });
    });
}
blocks$1.blocksAddresses = blocksAddresses;
async function blocksAddressesAll(hashOrNumber, allMethodOptions) {
    return (0, utils_1$9.paginateMethod)(pagination => this.blocksAddresses(hashOrNumber, pagination), allMethodOptions);
}
blocks$1.blocksAddressesAll = blocksAddressesAll;

var epochs$1 = {};

Object.defineProperty(epochs$1, "__esModule", { value: true });
epochs$1.epochsLatestParameters = epochs$1.epochsParameters = epochs$1.epochsBlocksByPoolIdAll = epochs$1.epochsBlocksByPoolId = epochs$1.epochsBlocksAll = epochs$1.epochsBlocks = epochs$1.epochsStakesByPoolIdAll = epochs$1.epochsStakesByPoolId = epochs$1.epochsStakesAll = epochs$1.epochsStakes = epochs$1.epochsPrevious = epochs$1.epochsNext = epochs$1.epochsLatest = epochs$1.epochs = void 0;
const utils_1$8 = utils;
const errors_1$c = errors$1;
async function epochs(number) {
    return new Promise((resolve, reject) => {
        this.instance(`epochs/${number}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$c.handleError)(err));
        });
    });
}
epochs$1.epochs = epochs;
async function epochsLatest() {
    return new Promise((resolve, reject) => {
        this.instance(`epochs/latest`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$c.handleError)(err));
        });
    });
}
epochs$1.epochsLatest = epochsLatest;
async function epochsNext(number, pagination) {
    const paginationOptions = (0, utils_1$8.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`epochs/${number}/next`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$c.handleError)(err));
        });
    });
}
epochs$1.epochsNext = epochsNext;
async function epochsPrevious(number, pagination) {
    const paginationOptions = (0, utils_1$8.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`epochs/${number}/previous`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$c.handleError)(err));
        });
    });
}
epochs$1.epochsPrevious = epochsPrevious;
async function epochsStakes(number, pagination) {
    const paginationOptions = (0, utils_1$8.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`epochs/${number}/stakes`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$c.handleError)(err));
        });
    });
}
epochs$1.epochsStakes = epochsStakes;
async function epochsStakesAll(number, allMethodOptions) {
    return (0, utils_1$8.paginateMethod)(pagination => this.epochsStakes(number, pagination), allMethodOptions);
}
epochs$1.epochsStakesAll = epochsStakesAll;
async function epochsStakesByPoolId(number, poolId, pagination) {
    const paginationOptions = (0, utils_1$8.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`epochs/${number}/stakes/${poolId}`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$c.handleError)(err));
        });
    });
}
epochs$1.epochsStakesByPoolId = epochsStakesByPoolId;
async function epochsStakesByPoolIdAll(number, poolId, allMethodOptions) {
    return (0, utils_1$8.paginateMethod)(pagination => this.epochsStakesByPoolId(number, poolId, pagination), allMethodOptions);
}
epochs$1.epochsStakesByPoolIdAll = epochsStakesByPoolIdAll;
async function epochsBlocks(number, pagination) {
    const paginationOptions = (0, utils_1$8.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`epochs/${number}/blocks`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$c.handleError)(err));
        });
    });
}
epochs$1.epochsBlocks = epochsBlocks;
async function epochsBlocksAll(number, allMethodOptions) {
    return (0, utils_1$8.paginateMethod)(pagination => this.epochsBlocks(number, pagination), allMethodOptions);
}
epochs$1.epochsBlocksAll = epochsBlocksAll;
async function epochsBlocksByPoolId(number, poolId, pagination) {
    const paginationOptions = (0, utils_1$8.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`epochs/${number}/blocks/${poolId}`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$c.handleError)(err));
        });
    });
}
epochs$1.epochsBlocksByPoolId = epochsBlocksByPoolId;
async function epochsBlocksByPoolIdAll(number, poolId, allMethodOptions) {
    return (0, utils_1$8.paginateMethod)(pagination => this.epochsBlocksByPoolId(number, poolId, pagination), allMethodOptions);
}
epochs$1.epochsBlocksByPoolIdAll = epochsBlocksByPoolIdAll;
async function epochsParameters(number) {
    return new Promise((resolve, reject) => {
        this.instance(`epochs/${number}/parameters`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$c.handleError)(err));
        });
    });
}
epochs$1.epochsParameters = epochsParameters;
async function epochsLatestParameters() {
    return new Promise((resolve, reject) => {
        this.instance(`epochs/latest/parameters`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$c.handleError)(err));
        });
    });
}
epochs$1.epochsLatestParameters = epochsLatestParameters;

var pools$1 = {};

Object.defineProperty(pools$1, "__esModule", { value: true });
pools$1.poolsExtendedAll = pools$1.poolsExtended = pools$1.poolsByIdUpdates = pools$1.poolsByIdBlocks = pools$1.poolsByIdDelegators = pools$1.poolsByIdRelays = pools$1.poolMetadata = pools$1.poolsByIdHistory = pools$1.poolsById = pools$1.poolsRetiring = pools$1.poolsRetired = pools$1.poolsAll = pools$1.pools = void 0;
const utils_1$7 = utils;
const errors_1$b = errors$1;
async function pools(pagination) {
    const paginationOptions = (0, utils_1$7.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`pools`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.pools = pools;
async function poolsAll(allMethodOptions) {
    return (0, utils_1$7.paginateMethod)(pagination => this.pools(pagination), allMethodOptions);
}
pools$1.poolsAll = poolsAll;
async function poolsRetired(pagination) {
    const paginationOptions = (0, utils_1$7.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`pools/retired`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.poolsRetired = poolsRetired;
async function poolsRetiring(pagination) {
    const paginationOptions = (0, utils_1$7.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`pools/retiring`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.poolsRetiring = poolsRetiring;
async function poolsById(poolId) {
    return new Promise((resolve, reject) => {
        this.instance(`pools/${poolId}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.poolsById = poolsById;
async function poolsByIdHistory(poolId, pagination) {
    const paginationOptions = (0, utils_1$7.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`pools/${poolId}/history`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.poolsByIdHistory = poolsByIdHistory;
async function poolMetadata(poolId) {
    return new Promise((resolve, reject) => {
        this.instance(`pools/${poolId}/metadata`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.poolMetadata = poolMetadata;
async function poolsByIdRelays(poolId) {
    return new Promise((resolve, reject) => {
        this.instance(`pools/${poolId}/relays`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.poolsByIdRelays = poolsByIdRelays;
async function poolsByIdDelegators(poolId, pagination) {
    const paginationOptions = (0, utils_1$7.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`pools/${poolId}/delegators`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.poolsByIdDelegators = poolsByIdDelegators;
async function poolsByIdBlocks(poolId, pagination) {
    const paginationOptions = (0, utils_1$7.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`pools/${poolId}/blocks`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.poolsByIdBlocks = poolsByIdBlocks;
async function poolsByIdUpdates(poolId, pagination) {
    const paginationOptions = (0, utils_1$7.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`pools/${poolId}/updates`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.poolsByIdUpdates = poolsByIdUpdates;
async function poolsExtended(pagination) {
    const paginationOptions = (0, utils_1$7.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`pools/extended`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$b.handleError)(err));
        });
    });
}
pools$1.poolsExtended = poolsExtended;
async function poolsExtendedAll(allMethodOptions) {
    return (0, utils_1$7.paginateMethod)(pagination => this.poolsExtended(pagination), allMethodOptions);
}
pools$1.poolsExtendedAll = poolsExtendedAll;

var ledger = {};

Object.defineProperty(ledger, "__esModule", { value: true });
ledger.genesis = void 0;
const errors_1$a = errors$1;
function genesis() {
    return new Promise((resolve, reject) => {
        this.instance(`genesis`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$a.handleError)(err));
        });
    });
}
ledger.genesis = genesis;

var root$1 = {};

Object.defineProperty(root$1, "__esModule", { value: true });
root$1.root = void 0;
const errors_1$9 = errors$1;
async function root() {
    return new Promise((resolve, reject) => {
        this.instance(``)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$9.handleError)(err));
        });
    });
}
root$1.root = root;

var metadata = {};

Object.defineProperty(metadata, "__esModule", { value: true });
metadata.metadataTxsLabelCbor = metadata.metadataTxsLabel = metadata.metadataTxsLabels = void 0;
const utils_1$6 = utils;
const errors_1$8 = errors$1;
async function metadataTxsLabels(pagination) {
    const paginationOptions = (0, utils_1$6.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`metadata/txs/labels`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$8.handleError)(err));
        });
    });
}
metadata.metadataTxsLabels = metadataTxsLabels;
async function metadataTxsLabel(label, pagination) {
    const paginationOptions = (0, utils_1$6.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`metadata/txs/labels/${label}`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$8.handleError)(err));
        });
    });
}
metadata.metadataTxsLabel = metadataTxsLabel;
async function metadataTxsLabelCbor(label, pagination) {
    const paginationOptions = (0, utils_1$6.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`metadata/txs/labels/${label}/cbor`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$8.handleError)(err));
        });
    });
}
metadata.metadataTxsLabelCbor = metadataTxsLabelCbor;

var mempool$1 = {};

Object.defineProperty(mempool$1, "__esModule", { value: true });
mempool$1.mempoolTx = mempool$1.mempoolAll = mempool$1.mempool = void 0;
const utils_1$5 = utils;
const errors_1$7 = errors$1;
async function mempool(pagination) {
    const paginationOptions = (0, utils_1$5.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`mempool`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$7.handleError)(err));
        });
    });
}
mempool$1.mempool = mempool;
async function mempoolAll(allMethodOptions) {
    return (0, utils_1$5.paginateMethod)(pagination => this.mempool(pagination), allMethodOptions);
}
mempool$1.mempoolAll = mempoolAll;
async function mempoolTx(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`mempool/${hash}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$7.handleError)(err));
        });
    });
}
mempool$1.mempoolTx = mempoolTx;

var health$1 = {};

Object.defineProperty(health$1, "__esModule", { value: true });
health$1.healthClock = health$1.health = void 0;
const errors_1$6 = errors$1;
function health() {
    return new Promise((resolve, reject) => {
        this.instance(`health`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$6.handleError)(err));
        });
    });
}
health$1.health = health;
function healthClock() {
    return new Promise((resolve, reject) => {
        this.instance(`health/clock`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$6.handleError)(err));
        });
    });
}
health$1.healthClock = healthClock;

var metrics$1 = {};

Object.defineProperty(metrics$1, "__esModule", { value: true });
metrics$1.metricsEndpoints = metrics$1.metrics = void 0;
const errors_1$5 = errors$1;
async function metrics() {
    return new Promise((resolve, reject) => {
        this.instance(`metrics`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$5.handleError)(err));
        });
    });
}
metrics$1.metrics = metrics;
async function metricsEndpoints() {
    return new Promise((resolve, reject) => {
        this.instance(`metrics/endpoints`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$5.handleError)(err));
        });
    });
}
metrics$1.metricsEndpoints = metricsEndpoints;

var txs$1 = {};

Object.defineProperty(txs$1, "__esModule", { value: true });
txs$1.txSubmit = txs$1.txsRedeemers = txs$1.txsMetadataCbor = txs$1.txsMetadata = txs$1.txsPoolRetires = txs$1.txsPoolUpdates = txs$1.txsMirs = txs$1.txsWithdrawals = txs$1.txsDelegations = txs$1.txsStakes = txs$1.txsUtxos = txs$1.txs = void 0;
const errors_1$4 = errors$1;
async function txs(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txs = txs;
async function txsUtxos(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}/utxos`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txsUtxos = txsUtxos;
async function txsStakes(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}/stakes`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txsStakes = txsStakes;
async function txsDelegations(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}/delegations`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txsDelegations = txsDelegations;
async function txsWithdrawals(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}/withdrawals`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txsWithdrawals = txsWithdrawals;
async function txsMirs(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}/mirs`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txsMirs = txsMirs;
async function txsPoolUpdates(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}/pool_updates`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txsPoolUpdates = txsPoolUpdates;
async function txsPoolRetires(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}/pool_retires`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txsPoolRetires = txsPoolRetires;
async function txsMetadata(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}/metadata`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txsMetadata = txsMetadata;
async function txsMetadataCbor(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}/metadata/cbor`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txsMetadataCbor = txsMetadataCbor;
async function txsRedeemers(hash) {
    return new Promise((resolve, reject) => {
        this.instance(`txs/${hash}/redeemers`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txsRedeemers = txsRedeemers;
async function txSubmit(transaction) {
    let tx;
    if (typeof transaction === 'string') {
        tx = Buffer.from(transaction, 'hex');
    }
    else {
        tx = Buffer.from(transaction);
    }
    return new Promise((resolve, reject) => {
        this.instance
            .post(`tx/submit`, {
            body: tx,
            headers: { 'Content-type': 'application/cbor' },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$4.handleError)(err));
        });
    });
}
txs$1.txSubmit = txSubmit;

var scripts$2 = {};

Object.defineProperty(scripts$2, "__esModule", { value: true });
scripts$2.scriptsRedeemers = scripts$2.scriptsDatumCbor = scripts$2.scriptsDatum = scripts$2.scriptsCbor = scripts$2.scriptsJson = scripts$2.scripts = scripts$2.scriptsByHash = void 0;
const utils_1$4 = utils;
const errors_1$3 = errors$1;
async function scriptsByHash(scriptHash) {
    return new Promise((resolve, reject) => {
        this.instance(`scripts/${scriptHash}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$3.handleError)(err));
        });
    });
}
scripts$2.scriptsByHash = scriptsByHash;
async function scripts$1(pagination) {
    const paginationOptions = (0, utils_1$4.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`scripts`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$3.handleError)(err));
        });
    });
}
scripts$2.scripts = scripts$1;
async function scriptsJson(scriptHash) {
    return new Promise((resolve, reject) => {
        this.instance(`scripts/${scriptHash}/json`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$3.handleError)(err));
        });
    });
}
scripts$2.scriptsJson = scriptsJson;
async function scriptsCbor(scriptHash) {
    return new Promise((resolve, reject) => {
        this.instance(`scripts/${scriptHash}/cbor`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$3.handleError)(err));
        });
    });
}
scripts$2.scriptsCbor = scriptsCbor;
async function scriptsDatum(datumHash) {
    return new Promise((resolve, reject) => {
        this.instance(`scripts/datum/${datumHash}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$3.handleError)(err));
        });
    });
}
scripts$2.scriptsDatum = scriptsDatum;
async function scriptsDatumCbor(datumHash) {
    return new Promise((resolve, reject) => {
        this.instance(`scripts/datum/${datumHash}/cbor`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$3.handleError)(err));
        });
    });
}
scripts$2.scriptsDatumCbor = scriptsDatumCbor;
async function scriptsRedeemers(scriptHash) {
    return new Promise((resolve, reject) => {
        this.instance(`scripts/${scriptHash}/redeemers`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$3.handleError)(err));
        });
    });
}
scripts$2.scriptsRedeemers = scriptsRedeemers;

var nutlink = {};

Object.defineProperty(nutlink, "__esModule", { value: true });
nutlink.nutlinkTickersAll = nutlink.nutlinkTickers = nutlink.nutlinkAddressTickerAll = nutlink.nutlinkAddressTicker = nutlink.nutlinkAddressTickersAll = nutlink.nutlinkAddressTickers = nutlink.nutlinkAddress = void 0;
const utils_1$3 = utils;
const errors_1$2 = errors$1;
async function nutlinkAddress(address) {
    return new Promise((resolve, reject) => {
        this.instance(`nutlink/${address}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$2.handleError)(err)));
    });
}
nutlink.nutlinkAddress = nutlinkAddress;
async function nutlinkAddressTickers(address, pagination) {
    const paginationOptions = (0, utils_1$3.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`nutlink/${address}/tickers`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$2.handleError)(err)));
    });
}
nutlink.nutlinkAddressTickers = nutlinkAddressTickers;
async function nutlinkAddressTickersAll(address, allMethodOptions) {
    return (0, utils_1$3.paginateMethod)(pagination => this.nutlinkAddressTickers(address, pagination), allMethodOptions);
}
nutlink.nutlinkAddressTickersAll = nutlinkAddressTickersAll;
async function nutlinkAddressTicker(address, ticker, pagination) {
    const paginationOptions = (0, utils_1$3.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`nutlink/${address}/tickers/${ticker}`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$2.handleError)(err)));
    });
}
nutlink.nutlinkAddressTicker = nutlinkAddressTicker;
async function nutlinkAddressTickerAll(address, ticker, allMethodOptions) {
    return (0, utils_1$3.paginateMethod)(pagination => this.nutlinkAddressTicker(address, ticker, pagination), allMethodOptions);
}
nutlink.nutlinkAddressTickerAll = nutlinkAddressTickerAll;
async function nutlinkTickers(ticker, pagination) {
    const paginationOptions = (0, utils_1$3.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`nutlink/tickers/${ticker}`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1$2.handleError)(err)));
    });
}
nutlink.nutlinkTickers = nutlinkTickers;
async function nutlinkTickersAll(ticker, allMethodOptions) {
    return (0, utils_1$3.paginateMethod)(pagination => this.nutlinkTickers(ticker, pagination), allMethodOptions);
}
nutlink.nutlinkTickersAll = nutlinkTickersAll;

var network$1 = {};

Object.defineProperty(network$1, "__esModule", { value: true });
network$1.network = void 0;
const errors_1$1 = errors$1;
async function network() {
    return new Promise((resolve, reject) => {
        this.instance(`network`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1$1.handleError)(err));
        });
    });
}
network$1.network = network;

var got = {};

var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(got, "__esModule", { value: true });
got.getInstance = void 0;
const got_1$2 = __importDefault$2(sourceExports);
const getInstance = (apiUrl, options, userAgent, rateLimiter) => {
    return got_1$2.default.extend({
        hooks: {
            beforeRequest: [
                async (hookOptions) => {
                    if (rateLimiter) {
                        await rateLimiter.schedule(() => Promise.resolve(true));
                    }
                    if (options.debug) {
                        console.log(`${hookOptions.method} ${hookOptions.url}`);
                    }
                },
            ],
            beforeError: [
                error => {
                    if (options.debug) {
                        console.error(error);
                    }
                    return error;
                },
            ],
        },
        prefixUrl: apiUrl,
        responseType: 'json',
        http2: options.http2,
        headers: {
            project_id: options.projectId,
            'User-Agent': userAgent,
        },
        retry: options.retrySettings,
        timeout: {
            request: options.requestTimeout,
        },
    });
};
got.getInstance = getInstance;

var name = "@blockfrost/blockfrost-js";
var version = "5.2.0";
var description = "A JavaScript/TypeScript SDK for interacting with the https://blockfrost.io API";
var keywords = [
	"blockfrost",
	"cardano",
	"cardano api"
];
var license = "Apache-2.0";
var author = "blockfrost.io";
var main = "lib/index.js";
var files = [
	"lib/**/*.js",
	"lib/**/*.ts"
];
var scripts = {
	build: "yarn clean && tsc",
	clean: "rimraf lib",
	docs: "yarn typedoc ./src/index.ts --theme ./node_modules/typedoc-github-wiki-theme/dist",
	lint: "eslint ./src/**/*.ts",
	prepublishOnly: "yarn build",
	test: "vitest --silent",
	"type-check": "tsc --project ./tsconfig.types.json",
	"make-badge": "make-coverage-badge --output-path='./coverage-badge.svg'",
	coverage: "vitest run --coverage --silent && make-badge",
	"coverage-ci": "vitest run --coverage --silent"
};
var dependencies = {
	"@blockfrost/blockfrost-utils": "2.0.0",
	"@blockfrost/openapi": "0.1.49",
	"@emurgo/cardano-serialization-lib-nodejs": "^10.2.0",
	"@emurgo/cip14-js": "3.0.1",
	bottleneck: "^2.19.5",
	"form-data": "^4.0.0",
	got: "^11.8.5"
};
var devDependencies = {
	"@types/node": "^14.6.0",
	"@typescript-eslint/eslint-plugin": "^5.44.0",
	"@typescript-eslint/parser": "^5.44.0",
	"@vitest/coverage-c8": "^0.25.3",
	eslint: "^8.28.0",
	"eslint-config-prettier": "^8.5.0",
	"eslint-plugin-prettier": "^4.2.1",
	"make-coverage-badge": "^1.2.0",
	msw: "^0.49.1",
	nock: "^13.2.9",
	prettier: "^2.8.0",
	rimraf: "^3.0.2",
	"serialize-error": "^11.0.0",
	typedoc: "^0.23.21",
	"typedoc-github-wiki-theme": "^1.0.1",
	"typedoc-plugin-markdown": "^3.13.6",
	typescript: "^4.9.3",
	vite: "^3.2.4",
	vitest: "^0.25.2"
};
var packageManager = "yarn@3.3.0";
var engines = {
	node: ">=16"
};
var require$$5 = {
	name: name,
	version: version,
	description: description,
	keywords: keywords,
	license: license,
	author: author,
	main: main,
	files: files,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies,
	packageManager: packageManager,
	engines: engines
};

Object.defineProperty(BlockFrostAPI$1, "__esModule", { value: true });
BlockFrostAPI$1.BlockFrostAPI = void 0;
const config_1$1 = config;
const accounts_1 = accounts$1;
const addresses_1 = addresses$1;
const assets_1 = assets$1;
const blocks_1 = blocks$1;
const epochs_1 = epochs$1;
const pools_1 = pools$1;
const ledger_1 = ledger;
const root_1 = root$1;
const metadata_1 = metadata;
const mempool_1 = mempool$1;
const health_1 = health$1;
const metrics_1 = metrics$1;
const txs_1 = txs$1;
const scripts_1 = scripts$2;
const nutlink_1 = nutlink;
const network_1 = network$1;
const utils_1$2 = utils;
const got_1$1 = got;
const limiter_1$1 = limiter;
// must be require, import would include package.json to the output dir together with "src" dir breaking dir hierarchy
// eslint-disable-next-line @typescript-eslint/no-var-requires
const packageJson$1 = require$$5;
class BlockFrostAPI {
    constructor(options) {
        var _a, _b;
        /**
         * accounts - Obtain information about a specific stake account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about a specific stake account.
         *
         */
        this.accounts = accounts_1.accounts;
        /**
         * accountsDelegations - Obtain information about the delegation of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the delegation of a specific account.
         *
         */
        this.accountsDelegations = accounts_1.accountsDelegations;
        /**
         * accountsDelegationsAll - Obtain information about all delegations of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the delegation of a specific account.
         *
         */
        this.accountsDelegationsAll = accounts_1.accountsDelegationsAll;
        /**
         * accountsRegistrations - Obtain information about the registrations and deregistrations of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the registrations and deregistrations of a specific account.
         *
         */
        this.accountsRegistrations = accounts_1.accountsRegistrations;
        /**
         * accountsRegistrationsAll - Obtain information about all registrations and deregistrations of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the registrations and deregistrations of a specific account.
         *
         */
        this.accountsRegistrationsAll = accounts_1.accountsRegistrationsAll;
        /**
         * accountsRewards - Obtain information about the history of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the history of a specific account.
         *
         */
        this.accountsRewards = accounts_1.accountsRewards;
        /**
         * accountsRewardsAll - Obtain information about whole history of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the history of a specific account.
         *
         */
        this.accountsRewardsAll = accounts_1.accountsRewardsAll;
        /**
         * accountsHistory - Obtain information about the history of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the history of a specific account.
         *
         */
        this.accountsHistory = accounts_1.accountsHistory;
        /**
         * accountsHistoryAll - Obtain information about whole history of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the history of a specific account.
         *
         */
        this.accountsHistoryAll = accounts_1.accountsHistoryAll;
        /**
         * accountsWithdrawals - Obtain information about the withdrawals of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the withdrawals of a specific account.
         *
         */
        this.accountsWithdrawals = accounts_1.accountsWithdrawals;
        /**
         * accountsWithdrawalsAll - Obtain information about all withdrawals of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the withdrawals of a specific account.
         *
         */
        this.accountsWithdrawalsAll = accounts_1.accountsWithdrawalsAll;
        /**
         * accountsMirs - Obtain information about the MIRs of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the MIRs of a specific account.
         *
         */
        this.accountsMirs = accounts_1.accountsMirs;
        /**
         * accountsMirsAll - Obtain information about all MIRs of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the MIRs of a specific account.
         *
         */
        this.accountsMirsAll = accounts_1.accountsMirsAll;
        /**
         * accountsAddresses - Obtain information about the addresses of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the addresses of a specific account.
         *
         */
        this.accountsAddresses = accounts_1.accountsAddresses;
        /**
         * accountsAddressesAll - Obtain information about all addresses of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Information about the addresses of a specific account.
         *
         */
        this.accountsAddressesAll = accounts_1.accountsAddressesAll;
        /**
         * accountsAddressesAssets - Obtain information about assets associated with addresses of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Assets associated with the account addresses
         *
         */
        this.accountsAddressesAssets = accounts_1.accountsAddressesAssets;
        /**
         * accountsAddressesAssets - Obtain information about assets associated with addresses of a specific account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Assets associated with the account addresses
         *
         */
        this.accountsAddressesAssetsAll = accounts_1.accountsAddressesAssetsAll;
        /**
         * accountsAddressesTotal - Obtain summed details aboutof all addresses associated with a given account.
         *
         * @param stakeAddress - Bech32 stake address
         * @returns Assets associated with the account addresses
         *
         */
        this.accountsAddressesTotal = accounts_1.accountsAddressesTotal;
        /**
         * assets - List of assets.
         *
         * @returns List of assets.
         *
         */
        this.assets = assets_1.assets;
        /**
         * assetsById - Information about a specific asset.
         *
         * @param asset - Concatenation of the policy_id and hex-encoded asset_name
         * @returns Information about a specific asset.
         *
         */
        this.assetsById = assets_1.assetsById;
        /**
         * assetsHistory - History of a specific asset.
         *
         * @param asset - Concatenation of the policy_id and hex-encoded asset_name
         * @returns History of a specific asset.
         *
         */
        this.assetsHistory = assets_1.assetsHistory;
        /**
         * assetsHistoryAll - Whole history of a specific asset.
         *
         * @param asset - Concatenation of the policy_id and hex-encoded asset_name
         * @returns History of a specific asset.
         *
         */
        this.assetsHistoryAll = assets_1.assetsHistoryAll;
        /**
         * assetsTransactions - List of a specific asset transactions.
         *
         * @param asset - Concatenation of the policy_id and hex-encoded asset_name
         * @returns List of a specific asset transactions.
         *
         */
        this.assetsTransactions = assets_1.assetsTransactions;
        /**
         * assetsAddresses - List of a addresses containing a specific asset.
         *
         * @param asset - Concatenation of the policy_id and hex-encoded asset_name
         * @returns List of a addresses containing a specific asset.
         *
         */
        this.assetsAddresses = assets_1.assetsAddresses;
        /**
         * assetsPolicyById - List of asset minted under a specific policy.
         *
         * @param policyId - Specific policy_id
         * @returns List of asset minted under a specific policy.
         *
         */
        this.assetsPolicyById = assets_1.assetsPolicyById;
        /**
         * assetsPolicyByIdAll - List of all assets minted under a specific policy.
         *
         * @param policyId - Specific policy_id
         * @returns List of asset minted under a specific policy.
         *
         */
        this.assetsPolicyByIdAll = assets_1.assetsPolicyByIdAll;
        /**
         * addresses
         *
         * @param address
         * @returns xxx
         *
         */
        this.addresses = addresses_1.addresses;
        /**
         * addressesTotal
         *
         * @param address
         * @returns xxx
         *
         */
        this.addressesTotal = addresses_1.addressesTotal;
        /**
         * addressesExtended
         *
         * @param address
         * @returns xxx
         *
         */
        this.addressesExtended = addresses_1.addressesExtended;
        /**
         * addressesTransactions
         *
         * @param address
         * @returns xxx
         *
         */
        this.addressesTransactions = addresses_1.addressesTransactions;
        /**
         * addressesTransactionsAll
         *
         * @param address
         * @returns xxx
         *
         */
        this.addressesTransactionsAll = addresses_1.addressesTransactionsAll;
        /**
         * addressesUtxos
         *
         * @param address
         * @returns xxx
         *
         */
        this.addressesUtxos = addresses_1.addressesUtxos;
        /**
         * addressesUtxosAll
         *
         * @param address
         * @returns xxx
         *
         */
        this.addressesUtxosAll = addresses_1.addressesUtxosAll;
        /**
         * addressesUtxosAsset - List of the address's utxos containing a given asset (paginated)
         *
         * @param address
         * @param asset - Concatenation of the policy_id and hex-encoded asset_name
         * @returns List of the address's utxos containing a given asset
         *
         */
        this.addressesUtxosAsset = addresses_1.addressesUtxosAsset;
        /**
         * addressesUtxosAssetAll - List of the address's utxos containing a given asset
         * @param address
         * @param asset - Concatenation of the policy_id and hex-encoded asset_name
         * @returns List of the address's utxos containing a given asset
         *
         */
        this.addressesUtxosAssetAll = addresses_1.addressesUtxosAssetAll;
        /**
         * addressesUtxos
         *
         * @param address
         * @returns xxx
         *
         */
        this.blocks = blocks_1.blocks;
        /**
         * blocksLatest
         *
         * @returns xxx
         *
         */
        this.blocksLatest = blocks_1.blocksLatest;
        this.blocksLatestTxs = blocks_1.blocksLatestTxs;
        this.blocksLatestTxsAll = blocks_1.blocksLatestTxsAll;
        /**
         * blocksNext
         *
         * @param address
         * @returns xxx
         *
         */
        this.blocksNext = blocks_1.blocksNext;
        /**
         * blockPrevious
         *
         * @param address
         * @returns xxx
         *
         */
        this.blocksPrevious = blocks_1.blocksPrevious;
        /**
         * addressesUtxos
         *
         * @param blocksTxs
         * @returns xxx
         *
         */
        this.blocksTxs = blocks_1.blocksTxs;
        /**
         * blocksTxsAll
         *
         * @param blocksTxsAll
         * @returns xxx
         *
         */
        this.blocksTxsAll = blocks_1.blocksTxsAll;
        this.blocksAddresses = blocks_1.blocksAddresses;
        this.blocksAddressesAll = blocks_1.blocksAddressesAll;
        /**
         * epochs
         *
         * @param number
         * @returns xxx
         *
         */
        this.epochs = epochs_1.epochs;
        /**
         * epochsBlocks
         *
         * @param number
         * @returns xxx
         *
         */
        this.epochsBlocks = epochs_1.epochsBlocks;
        /**
         * epochsBlocksAll
         *
         * @param number
         * @returns xxx
         *
         */
        this.epochsBlocksAll = epochs_1.epochsBlocksAll;
        /**
         * epochsBlocksByPoolId
         *
         * @param number
         * @param poolId
         * @returns xxx
         *
         */
        this.epochsBlocksByPoolId = epochs_1.epochsBlocksByPoolId;
        /**
         * epochsBlocksByPoolIdAll
         *
         * @param number
         * @param poolId
         * @returns xxx
         *
         */
        this.epochsBlocksByPoolIdAll = epochs_1.epochsBlocksByPoolIdAll;
        /**
         * epochsLatest
         *
         * @returns xxx
         *
         */
        this.epochsLatest = epochs_1.epochsLatest;
        /**
         * epochsNext
         *
         * @param number
         * @returns xxx
         *
         */
        this.epochsNext = epochs_1.epochsNext;
        /**
         * epochsParameters
         *
         * @param number
         * @returns xxx
         *
         */
        this.epochsParameters = epochs_1.epochsParameters;
        /**
         * epochsLatestParameters
         *
         * @returns xxx
         *
         */
        this.epochsLatestParameters = epochs_1.epochsLatestParameters;
        /**
         * epochsPrevious
         *
         * @param number
         * @returns xxx
         *
         */
        this.epochsPrevious = epochs_1.epochsPrevious;
        /**
         * epochsStakes
         *
         * @param number
         * @returns xxx
         *
         */
        this.epochsStakes = epochs_1.epochsStakes;
        /**
         * epochsStakesAll
         *
         * @param number
         * @returns xxx
         *
         */
        this.epochsStakesAll = epochs_1.epochsStakesAll;
        /**
         * epochsStakesByPoolId
         *
         * @param number
         * @param poolId
         * @returns xxx
         *
         */
        this.epochsStakesByPoolId = epochs_1.epochsStakesByPoolId;
        /**
         * epochsStakesByPoolIdAll
         *
         * @param number
         * @param poolId
         * @returns xxx
         *
         */
        this.epochsStakesByPoolIdAll = epochs_1.epochsStakesByPoolIdAll;
        /**
         * health
         *
         * @returns xxx
         *
         */
        this.health = health_1.health;
        /**
         * healthClock
         *
         * @returns xxx
         *
         */
        this.healthClock = health_1.healthClock;
        /**
         * ledger
         *
         * @returns xxx
         *
         */
        this.genesis = ledger_1.genesis;
        this.mempool = mempool_1.mempool;
        this.mempoolAll = mempool_1.mempoolAll;
        this.mempoolTx = mempool_1.mempoolTx;
        /**
         * metadataTxsLabel
         *
         * @param label
         * @returns xxx
         *
         */
        this.metadataTxsLabel = metadata_1.metadataTxsLabel;
        /**
         * metadataTxsLabelCbor
         *
         * @param label
         * @returns xxx
         *
         */
        this.metadataTxsLabelCbor = metadata_1.metadataTxsLabelCbor;
        /**
         * metadataTxsLabels
         *
         * @returns xxx
         *
         */
        this.metadataTxsLabels = metadata_1.metadataTxsLabels;
        /**
         * metrics
         *
         * @returns xxx
         *
         */
        this.metrics = metrics_1.metrics;
        /**
         * metricsEndpoints
         *
         * @returns xxx
         *
         */
        this.metricsEndpoints = metrics_1.metricsEndpoints;
        /**
         * nutlinkAddress
         *
         * @returns xxx
         *
         */
        this.nutlinkAddress = nutlink_1.nutlinkAddress;
        /**
      
        * nutlinkAddressTicker
         *
         * @returns xxx
         *
         */
        this.nutlinkAddressTicker = nutlink_1.nutlinkAddressTicker;
        /**
         * nutlinkAddressTickers
         *
         * @returns xxx
         *
         */
        this.nutlinkAddressTickers = nutlink_1.nutlinkAddressTickers;
        /**
         * nutlinkAddressTickersAll
         *
         * @returns xxx
         *
         */
        this.nutlinkAddressTickersAll = nutlink_1.nutlinkAddressTickersAll;
        /**
         * nutlinkAddressTickerAll
         *
         * @returns xxx
         *
         */
        this.nutlinkAddressTickerAll = nutlink_1.nutlinkAddressTickerAll;
        /**
         * nutlinkTickers
         *
         * @returns xxx
         *
         */
        this.nutlinkTickers = nutlink_1.nutlinkTickers;
        /**
         * nutlinkTickersAll
         *
         * @returns xxx
         *
         */
        this.nutlinkTickersAll = nutlink_1.nutlinkTickersAll;
        /**
         * pools
         *
         * @returns xxx
         *
         */
        this.pools = pools_1.pools;
        /**
         * poolsAll
         *
         * @returns xxx
         *
         */
        this.poolsAll = pools_1.poolsAll;
        /**
         * poolMetadata
         *
         * @param poolId
         * @returns xxx
         *
         */
        this.poolMetadata = pools_1.poolMetadata;
        /**
         * poolsById
         *
         * @param poolId
         * @returns xxx
         *
         */
        this.poolsById = pools_1.poolsById;
        /**
         * poolsByIdBlocks
         *
         * @param poolId
         * @returns xxx
         *
         */
        this.poolsByIdBlocks = pools_1.poolsByIdBlocks;
        /**
         * poolsByIdDelegators
         *
         * @param poolId
         * @returns xxx
         *
         */
        this.poolsByIdDelegators = pools_1.poolsByIdDelegators;
        /**
         * poolsByIdHistory
         *
         * @param poolId
         * @returns xxx
         *
         */
        this.poolsByIdHistory = pools_1.poolsByIdHistory;
        /**
         * poolsByIdRelays
         *
         * @param poolId
         * @returns xxx
         *
         */
        this.poolsByIdRelays = pools_1.poolsByIdRelays;
        /**
         * poolsByIdUpdates
         *
         * @param poolId
         * @returns xxx
         *
         */
        this.poolsByIdUpdates = pools_1.poolsByIdUpdates;
        /**
         * poolsRetired
         *
         * @returns xxx
         *
         */
        this.poolsRetired = pools_1.poolsRetired;
        /**
         * poolsRetiring
         *
         * @returns xxx
         *
         */
        this.poolsRetiring = pools_1.poolsRetiring;
        this.poolsExtended = pools_1.poolsExtended;
        this.poolsExtendedAll = pools_1.poolsExtendedAll;
        /**
         * root
         *
         * @returns xxx
         *
         */
        this.root = root_1.root;
        /**
         * List scripts
         *
         * @returns List of script hashes
         *
         */
        this.scripts = scripts_1.scripts;
        /**
         * Information about a specific script
         *
         * @returns Information about a specific script
         *
         */
        this.scriptsByHash = scripts_1.scriptsByHash;
        /**
         *
         */
        this.scriptsJson = scripts_1.scriptsJson;
        /**
         *
         */
        this.scriptsCbor = scripts_1.scriptsCbor;
        /**
         *
         */
        this.scriptsDatum = scripts_1.scriptsDatum;
        /**
         *
         */
        this.scriptsDatumCbor = scripts_1.scriptsDatumCbor;
        /**
         * List of redeemers of a specific script
         *
         * @returns List the information about redeemers of a specific script
         *
         */
        this.scriptsRedeemers = scripts_1.scriptsRedeemers;
        /**
         * txs
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txs = txs_1.txs;
        /**
         * txsMetadataCbor
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txsMetadataCbor = txs_1.txsMetadataCbor;
        /**
         * txsDelegations
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txsDelegations = txs_1.txsDelegations;
        /**
         * txsPoolRetires
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txsPoolRetires = txs_1.txsPoolRetires;
        /**
         * txsPoolUpdates
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txsPoolUpdates = txs_1.txsPoolUpdates;
        /**
         * txsStakes
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txsStakes = txs_1.txsStakes;
        /**
         * txsUtxos
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txsUtxos = txs_1.txsUtxos;
        /**
         * txsWithdrawals
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txsWithdrawals = txs_1.txsWithdrawals;
        /**
         * txsMirs
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txsMirs = txs_1.txsMirs;
        /**
         * txsMetadata
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txsMetadata = txs_1.txsMetadata;
        // XXX:
        this.txsRedeemers = txs_1.txsRedeemers;
        /**
         * txSubmit
         *
         * @param hash
         * @returns xxx
         *
         */
        this.txSubmit = txs_1.txSubmit;
        /**
         * network
         *
         * @returns Detailed network information.
         *
         */
        this.network = network_1.network;
        this.options = (0, utils_1$2.validateOptions)(options);
        let apiBase = config_1$1.API_URLS.mainnet;
        if (this.options.network) {
            if (this.options.network in config_1$1.API_URLS) {
                apiBase = config_1$1.API_URLS[this.options.network];
            }
            else {
                throw Error('Invalid network option. Valid options: mainnet, testnet, preview, preprod.');
            }
        }
        this.apiUrl =
            ((_a = this.options) === null || _a === void 0 ? void 0 : _a.customBackend) || `${apiBase}/v${this.options.version}`;
        this.projectId = this.options.projectId;
        this.userAgent =
            (_b = options === null || options === void 0 ? void 0 : options.userAgent) !== null && _b !== void 0 ? _b : `${packageJson$1.name}@${packageJson$1.version}`;
        this.rateLimiter = this.options.rateLimiter
            ? (0, limiter_1$1.getLimiter)(this.options.rateLimiter)
            : undefined;
        this.instance = (0, got_1$1.getInstance)(this.apiUrl, this.options, this.userAgent, this.rateLimiter);
    }
}
BlockFrostAPI$1.BlockFrostAPI = BlockFrostAPI;

var BlockFrostIPFS$1 = {};

var ipfs = {};

/* eslint-env browser */

var browser = typeof self == 'object' ? self.FormData : window.FormData;

var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(ipfs, "__esModule", { value: true });
ipfs.pinRemove = ipfs.listByPath = ipfs.list = ipfs.pin = ipfs.gateway = ipfs.add = void 0;
const errors_1 = errors$1;
const utils_1$1 = utils;
const form_data_1 = __importDefault$1(browser);
const fs_1 = __importDefault$1(require$$2$2);
async function add(path) {
    const stream = fs_1.default.createReadStream(path);
    const data = new form_data_1.default();
    data.append('file', stream);
    return new Promise((resolve, reject) => {
        this.instance
            .post(`ipfs/add`, {
            body: data,
            headers: {
                'Content-Type': `multipart/form-data; boundary=${data.getBoundary()}`,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
ipfs.add = add;
async function gateway(path) {
    return new Promise((resolve, reject) => {
        this.instance
            .get(`ipfs/gateway`, {
            searchParams: { path },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
ipfs.gateway = gateway;
async function pin(path) {
    return new Promise((resolve, reject) => {
        this.instance
            .post(`ipfs/pin/add/${path}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
ipfs.pin = pin;
async function list(pagination) {
    const paginationOptions = (0, utils_1$1.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`ipfs/pin/list`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
ipfs.list = list;
async function listByPath(path) {
    return new Promise((resolve, reject) => {
        this.instance(`ipfs/pin/list/${path}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
ipfs.listByPath = listByPath;
async function pinRemove(path) {
    return new Promise((resolve, reject) => {
        this.instance
            .post(`ipfs/pin/remove/${path}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
ipfs.pinRemove = pinRemove;

Object.defineProperty(BlockFrostIPFS$1, "__esModule", { value: true });
BlockFrostIPFS$1.BlockFrostIPFS = void 0;
const config_1 = config;
const ipfs_1 = ipfs;
const utils_1 = utils;
const got_1 = got;
const limiter_1 = limiter;
// eslint-disable-next-line @typescript-eslint/no-var-requires
const packageJson = require$$5;
class BlockFrostIPFS {
    constructor(options) {
        var _a;
        /**
         * add - Add a file or directory to ipfs
         *
         * @returns information about added ipfs object
         */
        this.add = ipfs_1.add;
        /**
         * gateway - Relay to an ipfs gateway
         *
         * @returns the object content
         *
         */
        this.gateway = ipfs_1.gateway;
        /**
         * pin - Pin an object
         *
         * @returns pinned object
         *
         */
        this.pin = ipfs_1.pin;
        /**
         * listByPath - List objects pinned to local storage
         *
         * @returns list of pinned objects
         *
         */
        this.listByPath = ipfs_1.listByPath;
        /**
         * list - List objects pinned to local storage
         *
         * @returns list of pinned objects
         *
         */
        this.list = ipfs_1.list;
        /**
         * pinRemove - Remove pinned objects from local storage
         *
         * @returns removed pinned object
         *
         */
        this.pinRemove = ipfs_1.pinRemove;
        this.options = (0, utils_1.validateOptions)(options);
        const apiBase = config_1.API_URLS.ipfs;
        this.apiUrl = `${apiBase}/v${this.options.version}`;
        this.userAgent =
            (_a = options === null || options === void 0 ? void 0 : options.userAgent) !== null && _a !== void 0 ? _a : `${packageJson.name}@${packageJson.version}`;
        this.rateLimiter = this.options.rateLimiter
            ? (0, limiter_1.getLimiter)(this.options.rateLimiter)
            : undefined;
        this.instance = (0, got_1.getInstance)(this.apiUrl, this.options, this.userAgent, this.rateLimiter);
        this.projectId = this.options.projectId;
    }
}
BlockFrostIPFS$1.BlockFrostIPFS = BlockFrostIPFS;

var helpers = {};

var cardano_serialization_lib = {exports: {}};

cardano_serialization_lib.exports;

(function (module) {
	let imports = {};
	imports['__wbindgen_placeholder__'] = module.exports;
	let wasm;
	const { TextDecoder, TextEncoder } = require$$1;

	const heap = new Array(32).fill(undefined);

	heap.push(undefined, null, true, false);

	function getObject(idx) { return heap[idx]; }

	let heap_next = heap.length;

	function dropObject(idx) {
	    if (idx < 36) return;
	    heap[idx] = heap_next;
	    heap_next = idx;
	}

	function takeObject(idx) {
	    const ret = getObject(idx);
	    dropObject(idx);
	    return ret;
	}

	let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

	cachedTextDecoder.decode();

	let cachegetUint8Memory0 = null;
	function getUint8Memory0() {
	    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
	        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
	    }
	    return cachegetUint8Memory0;
	}

	function getStringFromWasm0(ptr, len) {
	    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
	}

	function addHeapObject(obj) {
	    if (heap_next === heap.length) heap.push(heap.length + 1);
	    const idx = heap_next;
	    heap_next = heap[idx];

	    heap[idx] = obj;
	    return idx;
	}

	let WASM_VECTOR_LEN = 0;

	let cachedTextEncoder = new TextEncoder('utf-8');

	const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
	    ? function (arg, view) {
	    return cachedTextEncoder.encodeInto(arg, view);
	}
	    : function (arg, view) {
	    const buf = cachedTextEncoder.encode(arg);
	    view.set(buf);
	    return {
	        read: arg.length,
	        written: buf.length
	    };
	});

	function passStringToWasm0(arg, malloc, realloc) {

	    if (realloc === undefined) {
	        const buf = cachedTextEncoder.encode(arg);
	        const ptr = malloc(buf.length);
	        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
	        WASM_VECTOR_LEN = buf.length;
	        return ptr;
	    }

	    let len = arg.length;
	    let ptr = malloc(len);

	    const mem = getUint8Memory0();

	    let offset = 0;

	    for (; offset < len; offset++) {
	        const code = arg.charCodeAt(offset);
	        if (code > 0x7F) break;
	        mem[ptr + offset] = code;
	    }

	    if (offset !== len) {
	        if (offset !== 0) {
	            arg = arg.slice(offset);
	        }
	        ptr = realloc(ptr, len, len = offset + arg.length * 3);
	        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
	        const ret = encodeString(arg, view);

	        offset += ret.written;
	    }

	    WASM_VECTOR_LEN = offset;
	    return ptr;
	}

	function isLikeNone(x) {
	    return x === undefined || x === null;
	}

	let cachegetInt32Memory0 = null;
	function getInt32Memory0() {
	    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
	        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
	    }
	    return cachegetInt32Memory0;
	}

	function debugString(val) {
	    // primitive types
	    const type = typeof val;
	    if (type == 'number' || type == 'boolean' || val == null) {
	        return  `${val}`;
	    }
	    if (type == 'string') {
	        return `"${val}"`;
	    }
	    if (type == 'symbol') {
	        const description = val.description;
	        if (description == null) {
	            return 'Symbol';
	        } else {
	            return `Symbol(${description})`;
	        }
	    }
	    if (type == 'function') {
	        const name = val.name;
	        if (typeof name == 'string' && name.length > 0) {
	            return `Function(${name})`;
	        } else {
	            return 'Function';
	        }
	    }
	    // objects
	    if (Array.isArray(val)) {
	        const length = val.length;
	        let debug = '[';
	        if (length > 0) {
	            debug += debugString(val[0]);
	        }
	        for(let i = 1; i < length; i++) {
	            debug += ', ' + debugString(val[i]);
	        }
	        debug += ']';
	        return debug;
	    }
	    // Test for built-in
	    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
	    let className;
	    if (builtInMatches.length > 1) {
	        className = builtInMatches[1];
	    } else {
	        // Failed to match the standard '[object ClassName]'
	        return toString.call(val);
	    }
	    if (className == 'Object') {
	        // we're a user defined class or Object
	        // JSON.stringify avoids problems with cycles, and is generally much
	        // easier than looping through ownProperties of `val`.
	        try {
	            return 'Object(' + JSON.stringify(val) + ')';
	        } catch (_) {
	            return 'Object';
	        }
	    }
	    // errors
	    if (val instanceof Error) {
	        return `${val.name}: ${val.message}\n${val.stack}`;
	    }
	    // TODO we could test for more things here, like `Set`s and `Map`s.
	    return className;
	}

	function getArrayU8FromWasm0(ptr, len) {
	    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
	}

	function passArray8ToWasm0(arg, malloc) {
	    const ptr = malloc(arg.length * 1);
	    getUint8Memory0().set(arg, ptr / 1);
	    WASM_VECTOR_LEN = arg.length;
	    return ptr;
	}

	function _assertClass(instance, klass) {
	    if (!(instance instanceof klass)) {
	        throw new Error(`expected instance of ${klass.name}`);
	    }
	    return instance.ptr;
	}

	let cachegetUint32Memory0 = null;
	function getUint32Memory0() {
	    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {
	        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);
	    }
	    return cachegetUint32Memory0;
	}

	function getArrayU32FromWasm0(ptr, len) {
	    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);
	}

	function passArray32ToWasm0(arg, malloc) {
	    const ptr = malloc(arg.length * 4);
	    getUint32Memory0().set(arg, ptr / 4);
	    WASM_VECTOR_LEN = arg.length;
	    return ptr;
	}
	/**
	* @param {TransactionHash} tx_body_hash
	* @param {ByronAddress} addr
	* @param {LegacyDaedalusPrivateKey} key
	* @returns {BootstrapWitness}
	*/
	module.exports.make_daedalus_bootstrap_witness = function(tx_body_hash, addr, key) {
	    _assertClass(tx_body_hash, TransactionHash);
	    _assertClass(addr, ByronAddress);
	    _assertClass(key, LegacyDaedalusPrivateKey);
	    var ret = wasm.make_daedalus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);
	    return BootstrapWitness.__wrap(ret);
	};

	/**
	* @param {TransactionHash} tx_body_hash
	* @param {ByronAddress} addr
	* @param {Bip32PrivateKey} key
	* @returns {BootstrapWitness}
	*/
	module.exports.make_icarus_bootstrap_witness = function(tx_body_hash, addr, key) {
	    _assertClass(tx_body_hash, TransactionHash);
	    _assertClass(addr, ByronAddress);
	    _assertClass(key, Bip32PrivateKey);
	    var ret = wasm.make_icarus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);
	    return BootstrapWitness.__wrap(ret);
	};

	/**
	* @param {TransactionHash} tx_body_hash
	* @param {PrivateKey} sk
	* @returns {Vkeywitness}
	*/
	module.exports.make_vkey_witness = function(tx_body_hash, sk) {
	    _assertClass(tx_body_hash, TransactionHash);
	    _assertClass(sk, PrivateKey);
	    var ret = wasm.make_vkey_witness(tx_body_hash.ptr, sk.ptr);
	    return Vkeywitness.__wrap(ret);
	};

	/**
	* @param {AuxiliaryData} auxiliary_data
	* @returns {AuxiliaryDataHash}
	*/
	module.exports.hash_auxiliary_data = function(auxiliary_data) {
	    _assertClass(auxiliary_data, AuxiliaryData);
	    var ret = wasm.hash_auxiliary_data(auxiliary_data.ptr);
	    return AuxiliaryDataHash.__wrap(ret);
	};

	/**
	* @param {TransactionBody} tx_body
	* @returns {TransactionHash}
	*/
	module.exports.hash_transaction = function(tx_body) {
	    _assertClass(tx_body, TransactionBody);
	    var ret = wasm.hash_transaction(tx_body.ptr);
	    return TransactionHash.__wrap(ret);
	};

	/**
	* @param {PlutusData} plutus_data
	* @returns {DataHash}
	*/
	module.exports.hash_plutus_data = function(plutus_data) {
	    _assertClass(plutus_data, PlutusData);
	    var ret = wasm.hash_plutus_data(plutus_data.ptr);
	    return DataHash.__wrap(ret);
	};

	/**
	* @param {Redeemers} redeemers
	* @param {Costmdls} cost_models
	* @param {PlutusList | undefined} datums
	* @returns {ScriptDataHash}
	*/
	module.exports.hash_script_data = function(redeemers, cost_models, datums) {
	    _assertClass(redeemers, Redeemers);
	    _assertClass(cost_models, Costmdls);
	    let ptr0 = 0;
	    if (!isLikeNone(datums)) {
	        _assertClass(datums, PlutusList);
	        ptr0 = datums.ptr;
	        datums.ptr = 0;
	    }
	    var ret = wasm.hash_script_data(redeemers.ptr, cost_models.ptr, ptr0);
	    return ScriptDataHash.__wrap(ret);
	};

	/**
	* @param {TransactionBody} txbody
	* @param {BigNum} pool_deposit
	* @param {BigNum} key_deposit
	* @returns {Value}
	*/
	module.exports.get_implicit_input = function(txbody, pool_deposit, key_deposit) {
	    _assertClass(txbody, TransactionBody);
	    _assertClass(pool_deposit, BigNum);
	    _assertClass(key_deposit, BigNum);
	    var ret = wasm.get_implicit_input(txbody.ptr, pool_deposit.ptr, key_deposit.ptr);
	    return Value.__wrap(ret);
	};

	/**
	* @param {TransactionBody} txbody
	* @param {BigNum} pool_deposit
	* @param {BigNum} key_deposit
	* @returns {BigNum}
	*/
	module.exports.get_deposit = function(txbody, pool_deposit, key_deposit) {
	    _assertClass(txbody, TransactionBody);
	    _assertClass(pool_deposit, BigNum);
	    _assertClass(key_deposit, BigNum);
	    var ret = wasm.get_deposit(txbody.ptr, pool_deposit.ptr, key_deposit.ptr);
	    return BigNum.__wrap(ret);
	};

	/**
	* @param {Value} assets
	* @param {boolean} has_data_hash
	* @param {BigNum} coins_per_utxo_word
	* @returns {BigNum}
	*/
	module.exports.min_ada_required = function(assets, has_data_hash, coins_per_utxo_word) {
	    _assertClass(assets, Value);
	    _assertClass(coins_per_utxo_word, BigNum);
	    var ret = wasm.min_ada_required(assets.ptr, has_data_hash, coins_per_utxo_word.ptr);
	    return BigNum.__wrap(ret);
	};

	/**
	* Receives a script JSON string
	* and returns a NativeScript.
	* Cardano Wallet and Node styles are supported.
	*
	* * wallet: https://github.com/input-output-hk/cardano-wallet/blob/master/specifications/api/swagger.yaml
	* * node: https://github.com/input-output-hk/cardano-node/blob/master/doc/reference/simple-scripts.md
	*
	* self_xpub is expected to be a Bip32PublicKey as hex-encoded bytes
	* @param {string} json
	* @param {string} self_xpub
	* @param {number} schema
	* @returns {NativeScript}
	*/
	module.exports.encode_json_str_to_native_script = function(json, self_xpub, schema) {
	    var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	    var len0 = WASM_VECTOR_LEN;
	    var ptr1 = passStringToWasm0(self_xpub, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	    var len1 = WASM_VECTOR_LEN;
	    var ret = wasm.encode_json_str_to_native_script(ptr0, len0, ptr1, len1, schema);
	    return NativeScript.__wrap(ret);
	};

	/**
	* @param {Uint8Array} bytes
	* @returns {TransactionMetadatum}
	*/
	module.exports.encode_arbitrary_bytes_as_metadatum = function(bytes) {
	    var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	    var len0 = WASM_VECTOR_LEN;
	    var ret = wasm.encode_arbitrary_bytes_as_metadatum(ptr0, len0);
	    return TransactionMetadatum.__wrap(ret);
	};

	/**
	* @param {TransactionMetadatum} metadata
	* @returns {Uint8Array}
	*/
	module.exports.decode_arbitrary_bytes_from_metadatum = function(metadata) {
	    try {
	        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	        _assertClass(metadata, TransactionMetadatum);
	        wasm.decode_arbitrary_bytes_from_metadatum(retptr, metadata.ptr);
	        var r0 = getInt32Memory0()[retptr / 4 + 0];
	        var r1 = getInt32Memory0()[retptr / 4 + 1];
	        var v0 = getArrayU8FromWasm0(r0, r1).slice();
	        wasm.__wbindgen_free(r0, r1 * 1);
	        return v0;
	    } finally {
	        wasm.__wbindgen_add_to_stack_pointer(16);
	    }
	};

	/**
	* @param {string} json
	* @param {number} schema
	* @returns {TransactionMetadatum}
	*/
	module.exports.encode_json_str_to_metadatum = function(json, schema) {
	    var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	    var len0 = WASM_VECTOR_LEN;
	    var ret = wasm.encode_json_str_to_metadatum(ptr0, len0, schema);
	    return TransactionMetadatum.__wrap(ret);
	};

	/**
	* @param {TransactionMetadatum} metadatum
	* @param {number} schema
	* @returns {string}
	*/
	module.exports.decode_metadatum_to_json_str = function(metadatum, schema) {
	    try {
	        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	        _assertClass(metadatum, TransactionMetadatum);
	        wasm.decode_metadatum_to_json_str(retptr, metadatum.ptr, schema);
	        var r0 = getInt32Memory0()[retptr / 4 + 0];
	        var r1 = getInt32Memory0()[retptr / 4 + 1];
	        return getStringFromWasm0(r0, r1);
	    } finally {
	        wasm.__wbindgen_add_to_stack_pointer(16);
	        wasm.__wbindgen_free(r0, r1);
	    }
	};

	/**
	* @param {Transaction} tx
	* @param {LinearFee} linear_fee
	* @returns {BigNum}
	*/
	module.exports.min_fee = function(tx, linear_fee) {
	    _assertClass(tx, Transaction);
	    _assertClass(linear_fee, LinearFee);
	    var ret = wasm.min_fee(tx.ptr, linear_fee.ptr);
	    return BigNum.__wrap(ret);
	};

	/**
	* @param {ExUnits} ex_units
	* @param {ExUnitPrices} ex_unit_prices
	* @returns {BigNum}
	*/
	module.exports.calculate_ex_units_ceil_cost = function(ex_units, ex_unit_prices) {
	    _assertClass(ex_units, ExUnits);
	    _assertClass(ex_unit_prices, ExUnitPrices);
	    var ret = wasm.calculate_ex_units_ceil_cost(ex_units.ptr, ex_unit_prices.ptr);
	    return BigNum.__wrap(ret);
	};

	/**
	* @param {Transaction} tx
	* @param {ExUnitPrices} ex_unit_prices
	* @returns {BigNum}
	*/
	module.exports.min_script_fee = function(tx, ex_unit_prices) {
	    _assertClass(tx, Transaction);
	    _assertClass(ex_unit_prices, ExUnitPrices);
	    var ret = wasm.min_script_fee(tx.ptr, ex_unit_prices.ptr);
	    return BigNum.__wrap(ret);
	};

	/**
	* @param {string} password
	* @param {string} salt
	* @param {string} nonce
	* @param {string} data
	* @returns {string}
	*/
	module.exports.encrypt_with_password = function(password, salt, nonce, data) {
	    try {
	        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	        var ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ptr1 = passStringToWasm0(salt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len1 = WASM_VECTOR_LEN;
	        var ptr2 = passStringToWasm0(nonce, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len2 = WASM_VECTOR_LEN;
	        var ptr3 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len3 = WASM_VECTOR_LEN;
	        wasm.encrypt_with_password(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
	        var r0 = getInt32Memory0()[retptr / 4 + 0];
	        var r1 = getInt32Memory0()[retptr / 4 + 1];
	        return getStringFromWasm0(r0, r1);
	    } finally {
	        wasm.__wbindgen_add_to_stack_pointer(16);
	        wasm.__wbindgen_free(r0, r1);
	    }
	};

	/**
	* @param {string} password
	* @param {string} data
	* @returns {string}
	*/
	module.exports.decrypt_with_password = function(password, data) {
	    try {
	        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	        var ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len1 = WASM_VECTOR_LEN;
	        wasm.decrypt_with_password(retptr, ptr0, len0, ptr1, len1);
	        var r0 = getInt32Memory0()[retptr / 4 + 0];
	        var r1 = getInt32Memory0()[retptr / 4 + 1];
	        return getStringFromWasm0(r0, r1);
	    } finally {
	        wasm.__wbindgen_add_to_stack_pointer(16);
	        wasm.__wbindgen_free(r0, r1);
	    }
	};

	function handleError(f, args) {
	    try {
	        return f.apply(this, args);
	    } catch (e) {
	        wasm.__wbindgen_exn_store(addHeapObject(e));
	    }
	}
	/**
	*/
	module.exports.CertificateKind = Object.freeze({ StakeRegistration:0,"0":"StakeRegistration",StakeDeregistration:1,"1":"StakeDeregistration",StakeDelegation:2,"2":"StakeDelegation",PoolRegistration:3,"3":"PoolRegistration",PoolRetirement:4,"4":"PoolRetirement",GenesisKeyDelegation:5,"5":"GenesisKeyDelegation",MoveInstantaneousRewardsCert:6,"6":"MoveInstantaneousRewardsCert", });
	/**
	*/
	module.exports.MIRPot = Object.freeze({ Reserves:0,"0":"Reserves",Treasury:1,"1":"Treasury", });
	/**
	*/
	module.exports.MIRKind = Object.freeze({ ToOtherPot:0,"0":"ToOtherPot",ToStakeCredentials:1,"1":"ToStakeCredentials", });
	/**
	*/
	module.exports.RelayKind = Object.freeze({ SingleHostAddr:0,"0":"SingleHostAddr",SingleHostName:1,"1":"SingleHostName",MultiHostName:2,"2":"MultiHostName", });
	/**
	*/
	module.exports.NativeScriptKind = Object.freeze({ ScriptPubkey:0,"0":"ScriptPubkey",ScriptAll:1,"1":"ScriptAll",ScriptAny:2,"2":"ScriptAny",ScriptNOfK:3,"3":"ScriptNOfK",TimelockStart:4,"4":"TimelockStart",TimelockExpiry:5,"5":"TimelockExpiry", });
	/**
	* Each new language uses a different namespace for hashing its script
	* This is because you could have a language where the same bytes have different semantics
	* So this avoids scripts in different languages mapping to the same hash
	* Note that the enum value here is different than the enum value for deciding the cost model of a script
	*/
	module.exports.ScriptHashNamespace = Object.freeze({ NativeScript:0,"0":"NativeScript",PlutusScript:1,"1":"PlutusScript", });
	/**
	*/
	module.exports.NetworkIdKind = Object.freeze({ Testnet:0,"0":"Testnet",Mainnet:1,"1":"Mainnet", });
	/**
	* Used to choosed the schema for a script JSON string
	*/
	module.exports.ScriptSchema = Object.freeze({ Wallet:0,"0":"Wallet",Node:1,"1":"Node", });
	/**
	*/
	module.exports.TransactionMetadatumKind = Object.freeze({ MetadataMap:0,"0":"MetadataMap",MetadataList:1,"1":"MetadataList",Int:2,"2":"Int",Bytes:3,"3":"Bytes",Text:4,"4":"Text", });
	/**
	*/
	module.exports.MetadataJsonSchema = Object.freeze({ NoConversions:0,"0":"NoConversions",BasicConversions:1,"1":"BasicConversions",DetailedSchema:2,"2":"DetailedSchema", });
	/**
	*/
	module.exports.CoinSelectionStrategyCIP2 = Object.freeze({
	/**
	* Performs CIP2's Largest First ada-only selection. Will error if outputs contain non-ADA assets.
	*/
	LargestFirst:0,"0":"LargestFirst",
	/**
	* Performs CIP2's Random Improve ada-only selection. Will error if outputs contain non-ADA assets.
	*/
	RandomImprove:1,"1":"RandomImprove",
	/**
	* Same as LargestFirst, but before adding ADA, will insert by largest-first for each asset type.
	*/
	LargestFirstMultiAsset:2,"2":"LargestFirstMultiAsset",
	/**
	* Same as RandomImprove, but before adding ADA, will insert by random-improve for each asset type.
	*/
	RandomImproveMultiAsset:3,"3":"RandomImproveMultiAsset", });
	/**
	*/
	module.exports.StakeCredKind = Object.freeze({ Key:0,"0":"Key",Script:1,"1":"Script", });
	/**
	*/
	module.exports.LanguageKind = Object.freeze({ PlutusV1:0,"0":"PlutusV1", });
	/**
	*/
	module.exports.PlutusDataKind = Object.freeze({ ConstrPlutusData:0,"0":"ConstrPlutusData",Map:1,"1":"Map",List:2,"2":"List",Integer:3,"3":"Integer",Bytes:4,"4":"Bytes", });
	/**
	*/
	module.exports.RedeemerTagKind = Object.freeze({ Spend:0,"0":"Spend",Mint:1,"1":"Mint",Cert:2,"2":"Cert",Reward:3,"3":"Reward", });
	/**
	*/
	class Address {

	    static __wrap(ptr) {
	        const obj = Object.create(Address.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_address_free(ptr);
	    }
	    /**
	    * @param {Uint8Array} data
	    * @returns {Address}
	    */
	    static from_bytes(data) {
	        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.address_from_bytes(ptr0, len0);
	        return Address.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.address_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string | undefined} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = isLikeNone(prefix) ? 0 : passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.address_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {Address}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.address_from_bech32(ptr0, len0);
	        return Address.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    network_id() {
	        var ret = wasm.address_network_id(this.ptr);
	        return ret;
	    }
	}
	module.exports.Address = Address;
	/**
	*/
	class AssetName {

	    static __wrap(ptr) {
	        const obj = Object.create(AssetName.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_assetname_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.assetname_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {AssetName}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.assetname_from_bytes(ptr0, len0);
	        return AssetName.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} name
	    * @returns {AssetName}
	    */
	    static new(name) {
	        var ptr0 = passArray8ToWasm0(name, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.assetname_new(ptr0, len0);
	        return AssetName.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    name() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.assetname_name(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	}
	module.exports.AssetName = AssetName;
	/**
	*/
	class AssetNames {

	    static __wrap(ptr) {
	        const obj = Object.create(AssetNames.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_assetnames_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.assetnames_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {AssetNames}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.assetnames_from_bytes(ptr0, len0);
	        return AssetNames.__wrap(ret);
	    }
	    /**
	    * @returns {AssetNames}
	    */
	    static new() {
	        var ret = wasm.assetnames_new();
	        return AssetNames.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.assetnames_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {AssetName}
	    */
	    get(index) {
	        var ret = wasm.assetnames_get(this.ptr, index);
	        return AssetName.__wrap(ret);
	    }
	    /**
	    * @param {AssetName} elem
	    */
	    add(elem) {
	        _assertClass(elem, AssetName);
	        wasm.assetnames_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.AssetNames = AssetNames;
	/**
	*/
	class Assets {

	    static __wrap(ptr) {
	        const obj = Object.create(Assets.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_assets_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.assets_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Assets}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.assets_from_bytes(ptr0, len0);
	        return Assets.__wrap(ret);
	    }
	    /**
	    * @returns {Assets}
	    */
	    static new() {
	        var ret = wasm.assets_new();
	        return Assets.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.assets_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {AssetName} key
	    * @param {BigNum} value
	    * @returns {BigNum | undefined}
	    */
	    insert(key, value) {
	        _assertClass(key, AssetName);
	        _assertClass(value, BigNum);
	        var ret = wasm.assets_insert(this.ptr, key.ptr, value.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @param {AssetName} key
	    * @returns {BigNum | undefined}
	    */
	    get(key) {
	        _assertClass(key, AssetName);
	        var ret = wasm.assets_get(this.ptr, key.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {AssetNames}
	    */
	    keys() {
	        var ret = wasm.assets_keys(this.ptr);
	        return AssetNames.__wrap(ret);
	    }
	}
	module.exports.Assets = Assets;
	/**
	*/
	class AuxiliaryData {

	    static __wrap(ptr) {
	        const obj = Object.create(AuxiliaryData.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_auxiliarydata_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.auxiliarydata_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {AuxiliaryData}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.auxiliarydata_from_bytes(ptr0, len0);
	        return AuxiliaryData.__wrap(ret);
	    }
	    /**
	    * @returns {AuxiliaryData}
	    */
	    static new() {
	        var ret = wasm.auxiliarydata_new();
	        return AuxiliaryData.__wrap(ret);
	    }
	    /**
	    * @returns {GeneralTransactionMetadata | undefined}
	    */
	    metadata() {
	        var ret = wasm.auxiliarydata_metadata(this.ptr);
	        return ret === 0 ? undefined : GeneralTransactionMetadata.__wrap(ret);
	    }
	    /**
	    * @param {GeneralTransactionMetadata} metadata
	    */
	    set_metadata(metadata) {
	        _assertClass(metadata, GeneralTransactionMetadata);
	        wasm.auxiliarydata_set_metadata(this.ptr, metadata.ptr);
	    }
	    /**
	    * @returns {NativeScripts | undefined}
	    */
	    native_scripts() {
	        var ret = wasm.auxiliarydata_native_scripts(this.ptr);
	        return ret === 0 ? undefined : NativeScripts.__wrap(ret);
	    }
	    /**
	    * @param {NativeScripts} native_scripts
	    */
	    set_native_scripts(native_scripts) {
	        _assertClass(native_scripts, NativeScripts);
	        wasm.auxiliarydata_set_native_scripts(this.ptr, native_scripts.ptr);
	    }
	    /**
	    * @returns {PlutusScripts | undefined}
	    */
	    plutus_scripts() {
	        var ret = wasm.auxiliarydata_plutus_scripts(this.ptr);
	        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);
	    }
	    /**
	    * @param {PlutusScripts} plutus_scripts
	    */
	    set_plutus_scripts(plutus_scripts) {
	        _assertClass(plutus_scripts, PlutusScripts);
	        wasm.auxiliarydata_set_plutus_scripts(this.ptr, plutus_scripts.ptr);
	    }
	}
	module.exports.AuxiliaryData = AuxiliaryData;
	/**
	*/
	class AuxiliaryDataHash {

	    static __wrap(ptr) {
	        const obj = Object.create(AuxiliaryDataHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_auxiliarydatahash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.auxiliarydatahash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.auxiliarydatahash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {AuxiliaryDataHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.auxiliarydatahash_from_bech32(ptr0, len0);
	        return AuxiliaryDataHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {AuxiliaryDataHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.auxiliarydatahash_from_bytes(ptr0, len0);
	        return AuxiliaryDataHash.__wrap(ret);
	    }
	}
	module.exports.AuxiliaryDataHash = AuxiliaryDataHash;
	/**
	*/
	class AuxiliaryDataSet {

	    static __wrap(ptr) {
	        const obj = Object.create(AuxiliaryDataSet.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_auxiliarydataset_free(ptr);
	    }
	    /**
	    * @returns {AuxiliaryDataSet}
	    */
	    static new() {
	        var ret = wasm.auxiliarydataset_new();
	        return AuxiliaryDataSet.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.auxiliarydataset_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} tx_index
	    * @param {AuxiliaryData} data
	    * @returns {AuxiliaryData | undefined}
	    */
	    insert(tx_index, data) {
	        _assertClass(data, AuxiliaryData);
	        var ret = wasm.auxiliarydataset_insert(this.ptr, tx_index, data.ptr);
	        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
	    }
	    /**
	    * @param {number} tx_index
	    * @returns {AuxiliaryData | undefined}
	    */
	    get(tx_index) {
	        var ret = wasm.auxiliarydataset_get(this.ptr, tx_index);
	        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
	    }
	    /**
	    * @returns {Uint32Array}
	    */
	    indices() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.auxiliarydataset_indices(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU32FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 4);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	}
	module.exports.AuxiliaryDataSet = AuxiliaryDataSet;
	/**
	*/
	class BaseAddress {

	    static __wrap(ptr) {
	        const obj = Object.create(BaseAddress.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_baseaddress_free(ptr);
	    }
	    /**
	    * @param {number} network
	    * @param {StakeCredential} payment
	    * @param {StakeCredential} stake
	    * @returns {BaseAddress}
	    */
	    static new(network, payment, stake) {
	        _assertClass(payment, StakeCredential);
	        _assertClass(stake, StakeCredential);
	        var ret = wasm.baseaddress_new(network, payment.ptr, stake.ptr);
	        return BaseAddress.__wrap(ret);
	    }
	    /**
	    * @returns {StakeCredential}
	    */
	    payment_cred() {
	        var ret = wasm.baseaddress_payment_cred(this.ptr);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @returns {StakeCredential}
	    */
	    stake_cred() {
	        var ret = wasm.baseaddress_stake_cred(this.ptr);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @returns {Address}
	    */
	    to_address() {
	        var ret = wasm.baseaddress_to_address(this.ptr);
	        return Address.__wrap(ret);
	    }
	    /**
	    * @param {Address} addr
	    * @returns {BaseAddress | undefined}
	    */
	    static from_address(addr) {
	        _assertClass(addr, Address);
	        var ret = wasm.baseaddress_from_address(addr.ptr);
	        return ret === 0 ? undefined : BaseAddress.__wrap(ret);
	    }
	}
	module.exports.BaseAddress = BaseAddress;
	/**
	*/
	class BigInt {

	    static __wrap(ptr) {
	        const obj = Object.create(BigInt.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_bigint_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bigint_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {BigInt}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.bigint_from_bytes(ptr0, len0);
	        return BigInt.__wrap(ret);
	    }
	    /**
	    * @returns {boolean}
	    */
	    is_zero() {
	        var ret = wasm.bigint_is_zero(this.ptr);
	        return ret !== 0;
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    as_u64() {
	        var ret = wasm.bigint_as_u64(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @param {string} text
	    * @returns {BigInt}
	    */
	    static from_str(text) {
	        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.bigint_from_str(ptr0, len0);
	        return BigInt.__wrap(ret);
	    }
	    /**
	    * @returns {string}
	    */
	    to_str() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bigint_to_str(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {BigInt} other
	    * @returns {BigInt}
	    */
	    add(other) {
	        _assertClass(other, BigInt);
	        var ret = wasm.bigint_add(this.ptr, other.ptr);
	        return BigInt.__wrap(ret);
	    }
	    /**
	    * @param {BigInt} other
	    * @returns {BigInt}
	    */
	    mul(other) {
	        _assertClass(other, BigInt);
	        var ret = wasm.bigint_mul(this.ptr, other.ptr);
	        return BigInt.__wrap(ret);
	    }
	    /**
	    * @returns {BigInt}
	    */
	    static one() {
	        var ret = wasm.bigint_one();
	        return BigInt.__wrap(ret);
	    }
	    /**
	    * @returns {BigInt}
	    */
	    increment() {
	        var ret = wasm.bigint_increment(this.ptr);
	        return BigInt.__wrap(ret);
	    }
	    /**
	    * @param {BigInt} other
	    * @returns {BigInt}
	    */
	    div_ceil(other) {
	        _assertClass(other, BigInt);
	        var ret = wasm.bigint_div_ceil(this.ptr, other.ptr);
	        return BigInt.__wrap(ret);
	    }
	}
	module.exports.BigInt = BigInt;
	/**
	*/
	class BigNum {

	    static __wrap(ptr) {
	        const obj = Object.create(BigNum.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_bignum_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bignum_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {BigNum}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.bignum_from_bytes(ptr0, len0);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @param {string} string
	    * @returns {BigNum}
	    */
	    static from_str(string) {
	        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.bignum_from_str(ptr0, len0);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {string}
	    */
	    to_str() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bignum_to_str(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @returns {BigNum}
	    */
	    static zero() {
	        var ret = wasm.bignum_zero();
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    static one() {
	        var ret = wasm.bignum_one();
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {boolean}
	    */
	    is_zero() {
	        var ret = wasm.bignum_is_zero(this.ptr);
	        return ret !== 0;
	    }
	    /**
	    * @param {BigNum} other
	    * @returns {BigNum}
	    */
	    checked_mul(other) {
	        _assertClass(other, BigNum);
	        var ret = wasm.bignum_checked_mul(this.ptr, other.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} other
	    * @returns {BigNum}
	    */
	    checked_add(other) {
	        _assertClass(other, BigNum);
	        var ret = wasm.bignum_checked_add(this.ptr, other.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} other
	    * @returns {BigNum}
	    */
	    checked_sub(other) {
	        _assertClass(other, BigNum);
	        var ret = wasm.bignum_checked_sub(this.ptr, other.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * returns 0 if it would otherwise underflow
	    * @param {BigNum} other
	    * @returns {BigNum}
	    */
	    clamped_sub(other) {
	        _assertClass(other, BigNum);
	        var ret = wasm.bignum_clamped_sub(this.ptr, other.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} rhs_value
	    * @returns {number}
	    */
	    compare(rhs_value) {
	        _assertClass(rhs_value, BigNum);
	        var ret = wasm.bignum_compare(this.ptr, rhs_value.ptr);
	        return ret;
	    }
	}
	module.exports.BigNum = BigNum;
	/**
	*/
	class Bip32PrivateKey {

	    static __wrap(ptr) {
	        const obj = Object.create(Bip32PrivateKey.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_bip32privatekey_free(ptr);
	    }
	    /**
	    * derive this private key with the given index.
	    *
	    * # Security considerations
	    *
	    * * hard derivation index cannot be soft derived with the public key
	    *
	    * # Hard derivation vs Soft derivation
	    *
	    * If you pass an index below 0x80000000 then it is a soft derivation.
	    * The advantage of soft derivation is that it is possible to derive the
	    * public key too. I.e. derivation the private key with a soft derivation
	    * index and then retrieving the associated public key is equivalent to
	    * deriving the public key associated to the parent private key.
	    *
	    * Hard derivation index does not allow public key derivation.
	    *
	    * This is why deriving the private key should not fail while deriving
	    * the public key may fail (if the derivation index is invalid).
	    * @param {number} index
	    * @returns {Bip32PrivateKey}
	    */
	    derive(index) {
	        var ret = wasm.bip32privatekey_derive(this.ptr, index);
	        return Bip32PrivateKey.__wrap(ret);
	    }
	    /**
	    * 128-byte xprv a key format in Cardano that some software still uses or requires
	    * the traditional 96-byte xprv is simply encoded as
	    * prv | chaincode
	    * however, because some software may not know how to compute a public key from a private key,
	    * the 128-byte inlines the public key in the following format
	    * prv | pub | chaincode
	    * so be careful if you see the term "xprv" as it could refer to either one
	    * our library does not require the pub (instead we compute the pub key when needed)
	    * @param {Uint8Array} bytes
	    * @returns {Bip32PrivateKey}
	    */
	    static from_128_xprv(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.bip32privatekey_from_128_xprv(ptr0, len0);
	        return Bip32PrivateKey.__wrap(ret);
	    }
	    /**
	    * see from_128_xprv
	    * @returns {Uint8Array}
	    */
	    to_128_xprv() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bip32privatekey_to_128_xprv(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @returns {Bip32PrivateKey}
	    */
	    static generate_ed25519_bip32() {
	        var ret = wasm.bip32privatekey_generate_ed25519_bip32();
	        return Bip32PrivateKey.__wrap(ret);
	    }
	    /**
	    * @returns {PrivateKey}
	    */
	    to_raw_key() {
	        var ret = wasm.bip32privatekey_to_raw_key(this.ptr);
	        return PrivateKey.__wrap(ret);
	    }
	    /**
	    * @returns {Bip32PublicKey}
	    */
	    to_public() {
	        var ret = wasm.bip32privatekey_to_public(this.ptr);
	        return Bip32PublicKey.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Bip32PrivateKey}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.bip32privatekey_from_bytes(ptr0, len0);
	        return Bip32PrivateKey.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    as_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bip32privatekey_as_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} bech32_str
	    * @returns {Bip32PrivateKey}
	    */
	    static from_bech32(bech32_str) {
	        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.bip32privatekey_from_bech32(ptr0, len0);
	        return Bip32PrivateKey.__wrap(ret);
	    }
	    /**
	    * @returns {string}
	    */
	    to_bech32() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bip32privatekey_to_bech32(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {Uint8Array} entropy
	    * @param {Uint8Array} password
	    * @returns {Bip32PrivateKey}
	    */
	    static from_bip39_entropy(entropy, password) {
	        var ptr0 = passArray8ToWasm0(entropy, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ptr1 = passArray8ToWasm0(password, wasm.__wbindgen_malloc);
	        var len1 = WASM_VECTOR_LEN;
	        var ret = wasm.bip32privatekey_from_bip39_entropy(ptr0, len0, ptr1, len1);
	        return Bip32PrivateKey.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    chaincode() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bip32privatekey_chaincode(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	}
	module.exports.Bip32PrivateKey = Bip32PrivateKey;
	/**
	*/
	class Bip32PublicKey {

	    static __wrap(ptr) {
	        const obj = Object.create(Bip32PublicKey.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_bip32publickey_free(ptr);
	    }
	    /**
	    * derive this public key with the given index.
	    *
	    * # Errors
	    *
	    * If the index is not a soft derivation index (< 0x80000000) then
	    * calling this method will fail.
	    *
	    * # Security considerations
	    *
	    * * hard derivation index cannot be soft derived with the public key
	    *
	    * # Hard derivation vs Soft derivation
	    *
	    * If you pass an index below 0x80000000 then it is a soft derivation.
	    * The advantage of soft derivation is that it is possible to derive the
	    * public key too. I.e. derivation the private key with a soft derivation
	    * index and then retrieving the associated public key is equivalent to
	    * deriving the public key associated to the parent private key.
	    *
	    * Hard derivation index does not allow public key derivation.
	    *
	    * This is why deriving the private key should not fail while deriving
	    * the public key may fail (if the derivation index is invalid).
	    * @param {number} index
	    * @returns {Bip32PublicKey}
	    */
	    derive(index) {
	        var ret = wasm.bip32publickey_derive(this.ptr, index);
	        return Bip32PublicKey.__wrap(ret);
	    }
	    /**
	    * @returns {PublicKey}
	    */
	    to_raw_key() {
	        var ret = wasm.bip32publickey_to_raw_key(this.ptr);
	        return PublicKey.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Bip32PublicKey}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.bip32publickey_from_bytes(ptr0, len0);
	        return Bip32PublicKey.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    as_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bip32publickey_as_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} bech32_str
	    * @returns {Bip32PublicKey}
	    */
	    static from_bech32(bech32_str) {
	        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.bip32publickey_from_bech32(ptr0, len0);
	        return Bip32PublicKey.__wrap(ret);
	    }
	    /**
	    * @returns {string}
	    */
	    to_bech32() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bip32publickey_to_bech32(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    chaincode() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bip32publickey_chaincode(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	}
	module.exports.Bip32PublicKey = Bip32PublicKey;
	/**
	*/
	class Block {

	    static __wrap(ptr) {
	        const obj = Object.create(Block.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_block_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.block_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Block}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.block_from_bytes(ptr0, len0);
	        return Block.__wrap(ret);
	    }
	    /**
	    * @returns {Header}
	    */
	    header() {
	        var ret = wasm.block_header(this.ptr);
	        return Header.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionBodies}
	    */
	    transaction_bodies() {
	        var ret = wasm.block_transaction_bodies(this.ptr);
	        return TransactionBodies.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionWitnessSets}
	    */
	    transaction_witness_sets() {
	        var ret = wasm.block_transaction_witness_sets(this.ptr);
	        return TransactionWitnessSets.__wrap(ret);
	    }
	    /**
	    * @returns {AuxiliaryDataSet}
	    */
	    auxiliary_data_set() {
	        var ret = wasm.block_auxiliary_data_set(this.ptr);
	        return AuxiliaryDataSet.__wrap(ret);
	    }
	    /**
	    * @returns {Uint32Array}
	    */
	    invalid_transactions() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.block_invalid_transactions(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU32FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 4);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Header} header
	    * @param {TransactionBodies} transaction_bodies
	    * @param {TransactionWitnessSets} transaction_witness_sets
	    * @param {AuxiliaryDataSet} auxiliary_data_set
	    * @param {Uint32Array} invalid_transactions
	    * @returns {Block}
	    */
	    static new(header, transaction_bodies, transaction_witness_sets, auxiliary_data_set, invalid_transactions) {
	        _assertClass(header, Header);
	        _assertClass(transaction_bodies, TransactionBodies);
	        _assertClass(transaction_witness_sets, TransactionWitnessSets);
	        _assertClass(auxiliary_data_set, AuxiliaryDataSet);
	        var ptr0 = passArray32ToWasm0(invalid_transactions, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.block_new(header.ptr, transaction_bodies.ptr, transaction_witness_sets.ptr, auxiliary_data_set.ptr, ptr0, len0);
	        return Block.__wrap(ret);
	    }
	}
	module.exports.Block = Block;
	/**
	*/
	class BlockHash {

	    static __wrap(ptr) {
	        const obj = Object.create(BlockHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_blockhash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.blockhash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.blockhash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {BlockHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.blockhash_from_bech32(ptr0, len0);
	        return BlockHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {BlockHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.blockhash_from_bytes(ptr0, len0);
	        return BlockHash.__wrap(ret);
	    }
	}
	module.exports.BlockHash = BlockHash;
	/**
	*/
	class BootstrapWitness {

	    static __wrap(ptr) {
	        const obj = Object.create(BootstrapWitness.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_bootstrapwitness_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bootstrapwitness_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {BootstrapWitness}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.bootstrapwitness_from_bytes(ptr0, len0);
	        return BootstrapWitness.__wrap(ret);
	    }
	    /**
	    * @returns {Vkey}
	    */
	    vkey() {
	        var ret = wasm.bootstrapwitness_vkey(this.ptr);
	        return Vkey.__wrap(ret);
	    }
	    /**
	    * @returns {Ed25519Signature}
	    */
	    signature() {
	        var ret = wasm.bootstrapwitness_signature(this.ptr);
	        return Ed25519Signature.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    chain_code() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bootstrapwitness_chain_code(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    attributes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.bootstrapwitness_attributes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Vkey} vkey
	    * @param {Ed25519Signature} signature
	    * @param {Uint8Array} chain_code
	    * @param {Uint8Array} attributes
	    * @returns {BootstrapWitness}
	    */
	    static new(vkey, signature, chain_code, attributes) {
	        _assertClass(vkey, Vkey);
	        _assertClass(signature, Ed25519Signature);
	        var ptr0 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ptr1 = passArray8ToWasm0(attributes, wasm.__wbindgen_malloc);
	        var len1 = WASM_VECTOR_LEN;
	        var ret = wasm.bootstrapwitness_new(vkey.ptr, signature.ptr, ptr0, len0, ptr1, len1);
	        return BootstrapWitness.__wrap(ret);
	    }
	}
	module.exports.BootstrapWitness = BootstrapWitness;
	/**
	*/
	class BootstrapWitnesses {

	    static __wrap(ptr) {
	        const obj = Object.create(BootstrapWitnesses.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_bootstrapwitnesses_free(ptr);
	    }
	    /**
	    * @returns {BootstrapWitnesses}
	    */
	    static new() {
	        var ret = wasm.bootstrapwitnesses_new();
	        return BootstrapWitnesses.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.bootstrapwitnesses_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {BootstrapWitness}
	    */
	    get(index) {
	        var ret = wasm.bootstrapwitnesses_get(this.ptr, index);
	        return BootstrapWitness.__wrap(ret);
	    }
	    /**
	    * @param {BootstrapWitness} elem
	    */
	    add(elem) {
	        _assertClass(elem, BootstrapWitness);
	        wasm.bootstrapwitnesses_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.BootstrapWitnesses = BootstrapWitnesses;
	/**
	*/
	class ByronAddress {

	    static __wrap(ptr) {
	        const obj = Object.create(ByronAddress.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_byronaddress_free(ptr);
	    }
	    /**
	    * @returns {string}
	    */
	    to_base58() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.byronaddress_to_base58(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.byronaddress_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ByronAddress}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.byronaddress_from_bytes(ptr0, len0);
	        return ByronAddress.__wrap(ret);
	    }
	    /**
	    * returns the byron protocol magic embedded in the address, or mainnet id if none is present
	    * note: for bech32 addresses, you need to use network_id instead
	    * @returns {number}
	    */
	    byron_protocol_magic() {
	        var ret = wasm.byronaddress_byron_protocol_magic(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    attributes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.byronaddress_attributes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @returns {number}
	    */
	    network_id() {
	        var ret = wasm.byronaddress_network_id(this.ptr);
	        return ret;
	    }
	    /**
	    * @param {string} s
	    * @returns {ByronAddress}
	    */
	    static from_base58(s) {
	        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.byronaddress_from_base58(ptr0, len0);
	        return ByronAddress.__wrap(ret);
	    }
	    /**
	    * @param {Bip32PublicKey} key
	    * @param {number} protocol_magic
	    * @returns {ByronAddress}
	    */
	    static icarus_from_key(key, protocol_magic) {
	        _assertClass(key, Bip32PublicKey);
	        var ret = wasm.byronaddress_icarus_from_key(key.ptr, protocol_magic);
	        return ByronAddress.__wrap(ret);
	    }
	    /**
	    * @param {string} s
	    * @returns {boolean}
	    */
	    static is_valid(s) {
	        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.byronaddress_is_valid(ptr0, len0);
	        return ret !== 0;
	    }
	    /**
	    * @returns {Address}
	    */
	    to_address() {
	        var ret = wasm.byronaddress_to_address(this.ptr);
	        return Address.__wrap(ret);
	    }
	    /**
	    * @param {Address} addr
	    * @returns {ByronAddress | undefined}
	    */
	    static from_address(addr) {
	        _assertClass(addr, Address);
	        var ret = wasm.byronaddress_from_address(addr.ptr);
	        return ret === 0 ? undefined : ByronAddress.__wrap(ret);
	    }
	}
	module.exports.ByronAddress = ByronAddress;
	/**
	*/
	class Certificate {

	    static __wrap(ptr) {
	        const obj = Object.create(Certificate.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_certificate_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.certificate_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Certificate}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.certificate_from_bytes(ptr0, len0);
	        return Certificate.__wrap(ret);
	    }
	    /**
	    * @param {StakeRegistration} stake_registration
	    * @returns {Certificate}
	    */
	    static new_stake_registration(stake_registration) {
	        _assertClass(stake_registration, StakeRegistration);
	        var ret = wasm.certificate_new_stake_registration(stake_registration.ptr);
	        return Certificate.__wrap(ret);
	    }
	    /**
	    * @param {StakeDeregistration} stake_deregistration
	    * @returns {Certificate}
	    */
	    static new_stake_deregistration(stake_deregistration) {
	        _assertClass(stake_deregistration, StakeDeregistration);
	        var ret = wasm.certificate_new_stake_deregistration(stake_deregistration.ptr);
	        return Certificate.__wrap(ret);
	    }
	    /**
	    * @param {StakeDelegation} stake_delegation
	    * @returns {Certificate}
	    */
	    static new_stake_delegation(stake_delegation) {
	        _assertClass(stake_delegation, StakeDelegation);
	        var ret = wasm.certificate_new_stake_delegation(stake_delegation.ptr);
	        return Certificate.__wrap(ret);
	    }
	    /**
	    * @param {PoolRegistration} pool_registration
	    * @returns {Certificate}
	    */
	    static new_pool_registration(pool_registration) {
	        _assertClass(pool_registration, PoolRegistration);
	        var ret = wasm.certificate_new_pool_registration(pool_registration.ptr);
	        return Certificate.__wrap(ret);
	    }
	    /**
	    * @param {PoolRetirement} pool_retirement
	    * @returns {Certificate}
	    */
	    static new_pool_retirement(pool_retirement) {
	        _assertClass(pool_retirement, PoolRetirement);
	        var ret = wasm.certificate_new_pool_retirement(pool_retirement.ptr);
	        return Certificate.__wrap(ret);
	    }
	    /**
	    * @param {GenesisKeyDelegation} genesis_key_delegation
	    * @returns {Certificate}
	    */
	    static new_genesis_key_delegation(genesis_key_delegation) {
	        _assertClass(genesis_key_delegation, GenesisKeyDelegation);
	        var ret = wasm.certificate_new_genesis_key_delegation(genesis_key_delegation.ptr);
	        return Certificate.__wrap(ret);
	    }
	    /**
	    * @param {MoveInstantaneousRewardsCert} move_instantaneous_rewards_cert
	    * @returns {Certificate}
	    */
	    static new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert) {
	        _assertClass(move_instantaneous_rewards_cert, MoveInstantaneousRewardsCert);
	        var ret = wasm.certificate_new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert.ptr);
	        return Certificate.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    kind() {
	        var ret = wasm.certificate_kind(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {StakeRegistration | undefined}
	    */
	    as_stake_registration() {
	        var ret = wasm.certificate_as_stake_registration(this.ptr);
	        return ret === 0 ? undefined : StakeRegistration.__wrap(ret);
	    }
	    /**
	    * @returns {StakeDeregistration | undefined}
	    */
	    as_stake_deregistration() {
	        var ret = wasm.certificate_as_stake_deregistration(this.ptr);
	        return ret === 0 ? undefined : StakeDeregistration.__wrap(ret);
	    }
	    /**
	    * @returns {StakeDelegation | undefined}
	    */
	    as_stake_delegation() {
	        var ret = wasm.certificate_as_stake_delegation(this.ptr);
	        return ret === 0 ? undefined : StakeDelegation.__wrap(ret);
	    }
	    /**
	    * @returns {PoolRegistration | undefined}
	    */
	    as_pool_registration() {
	        var ret = wasm.certificate_as_pool_registration(this.ptr);
	        return ret === 0 ? undefined : PoolRegistration.__wrap(ret);
	    }
	    /**
	    * @returns {PoolRetirement | undefined}
	    */
	    as_pool_retirement() {
	        var ret = wasm.certificate_as_pool_retirement(this.ptr);
	        return ret === 0 ? undefined : PoolRetirement.__wrap(ret);
	    }
	    /**
	    * @returns {GenesisKeyDelegation | undefined}
	    */
	    as_genesis_key_delegation() {
	        var ret = wasm.certificate_as_genesis_key_delegation(this.ptr);
	        return ret === 0 ? undefined : GenesisKeyDelegation.__wrap(ret);
	    }
	    /**
	    * @returns {MoveInstantaneousRewardsCert | undefined}
	    */
	    as_move_instantaneous_rewards_cert() {
	        var ret = wasm.certificate_as_move_instantaneous_rewards_cert(this.ptr);
	        return ret === 0 ? undefined : MoveInstantaneousRewardsCert.__wrap(ret);
	    }
	}
	module.exports.Certificate = Certificate;
	/**
	*/
	class Certificates {

	    static __wrap(ptr) {
	        const obj = Object.create(Certificates.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_certificates_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.certificates_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Certificates}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.certificates_from_bytes(ptr0, len0);
	        return Certificates.__wrap(ret);
	    }
	    /**
	    * @returns {Certificates}
	    */
	    static new() {
	        var ret = wasm.certificates_new();
	        return Certificates.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.certificates_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {Certificate}
	    */
	    get(index) {
	        var ret = wasm.certificates_get(this.ptr, index);
	        return Certificate.__wrap(ret);
	    }
	    /**
	    * @param {Certificate} elem
	    */
	    add(elem) {
	        _assertClass(elem, Certificate);
	        wasm.certificates_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.Certificates = Certificates;
	/**
	*/
	class ConstrPlutusData {

	    static __wrap(ptr) {
	        const obj = Object.create(ConstrPlutusData.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_constrplutusdata_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.constrplutusdata_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ConstrPlutusData}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.constrplutusdata_from_bytes(ptr0, len0);
	        return ConstrPlutusData.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    alternative() {
	        var ret = wasm.constrplutusdata_alternative(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {PlutusList}
	    */
	    data() {
	        var ret = wasm.constrplutusdata_data(this.ptr);
	        return PlutusList.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} alternative
	    * @param {PlutusList} data
	    * @returns {ConstrPlutusData}
	    */
	    static new(alternative, data) {
	        _assertClass(alternative, BigNum);
	        _assertClass(data, PlutusList);
	        var ret = wasm.constrplutusdata_new(alternative.ptr, data.ptr);
	        return ConstrPlutusData.__wrap(ret);
	    }
	}
	module.exports.ConstrPlutusData = ConstrPlutusData;
	/**
	*/
	class CostModel {

	    static __wrap(ptr) {
	        const obj = Object.create(CostModel.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_costmodel_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.costmodel_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {CostModel}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.costmodel_from_bytes(ptr0, len0);
	        return CostModel.__wrap(ret);
	    }
	    /**
	    * @returns {CostModel}
	    */
	    static new() {
	        var ret = wasm.costmodel_new();
	        return CostModel.__wrap(ret);
	    }
	    /**
	    * @param {number} operation
	    * @param {Int} cost
	    * @returns {Int}
	    */
	    set(operation, cost) {
	        _assertClass(cost, Int);
	        var ret = wasm.costmodel_set(this.ptr, operation, cost.ptr);
	        return Int.__wrap(ret);
	    }
	    /**
	    * @param {number} operation
	    * @returns {Int}
	    */
	    get(operation) {
	        var ret = wasm.costmodel_get(this.ptr, operation);
	        return Int.__wrap(ret);
	    }
	}
	module.exports.CostModel = CostModel;
	/**
	*/
	class Costmdls {

	    static __wrap(ptr) {
	        const obj = Object.create(Costmdls.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_costmdls_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.costmdls_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Costmdls}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.costmdls_from_bytes(ptr0, len0);
	        return Costmdls.__wrap(ret);
	    }
	    /**
	    * @returns {Costmdls}
	    */
	    static new() {
	        var ret = wasm.costmdls_new();
	        return Costmdls.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.costmdls_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {Language} key
	    * @param {CostModel} value
	    * @returns {CostModel | undefined}
	    */
	    insert(key, value) {
	        _assertClass(key, Language);
	        _assertClass(value, CostModel);
	        var ret = wasm.costmdls_insert(this.ptr, key.ptr, value.ptr);
	        return ret === 0 ? undefined : CostModel.__wrap(ret);
	    }
	    /**
	    * @param {Language} key
	    * @returns {CostModel | undefined}
	    */
	    get(key) {
	        _assertClass(key, Language);
	        var ret = wasm.costmdls_get(this.ptr, key.ptr);
	        return ret === 0 ? undefined : CostModel.__wrap(ret);
	    }
	    /**
	    * @returns {Languages}
	    */
	    keys() {
	        var ret = wasm.costmdls_keys(this.ptr);
	        return Languages.__wrap(ret);
	    }
	}
	module.exports.Costmdls = Costmdls;
	/**
	*/
	class DNSRecordAorAAAA {

	    static __wrap(ptr) {
	        const obj = Object.create(DNSRecordAorAAAA.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_dnsrecordaoraaaa_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.dnsrecordaoraaaa_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {DNSRecordAorAAAA}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.dnsrecordaoraaaa_from_bytes(ptr0, len0);
	        return DNSRecordAorAAAA.__wrap(ret);
	    }
	    /**
	    * @param {string} dns_name
	    * @returns {DNSRecordAorAAAA}
	    */
	    static new(dns_name) {
	        var ptr0 = passStringToWasm0(dns_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.dnsrecordaoraaaa_new(ptr0, len0);
	        return DNSRecordAorAAAA.__wrap(ret);
	    }
	    /**
	    * @returns {string}
	    */
	    record() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.dnsrecordaoraaaa_record(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	}
	module.exports.DNSRecordAorAAAA = DNSRecordAorAAAA;
	/**
	*/
	class DNSRecordSRV {

	    static __wrap(ptr) {
	        const obj = Object.create(DNSRecordSRV.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_dnsrecordsrv_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.dnsrecordsrv_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {DNSRecordSRV}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.dnsrecordsrv_from_bytes(ptr0, len0);
	        return DNSRecordSRV.__wrap(ret);
	    }
	    /**
	    * @param {string} dns_name
	    * @returns {DNSRecordSRV}
	    */
	    static new(dns_name) {
	        var ptr0 = passStringToWasm0(dns_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.dnsrecordsrv_new(ptr0, len0);
	        return DNSRecordSRV.__wrap(ret);
	    }
	    /**
	    * @returns {string}
	    */
	    record() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.dnsrecordsrv_record(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	}
	module.exports.DNSRecordSRV = DNSRecordSRV;
	/**
	*/
	class DataHash {

	    static __wrap(ptr) {
	        const obj = Object.create(DataHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_datahash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.datahash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.datahash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {DataHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.datahash_from_bech32(ptr0, len0);
	        return DataHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {DataHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.datahash_from_bytes(ptr0, len0);
	        return DataHash.__wrap(ret);
	    }
	}
	module.exports.DataHash = DataHash;
	/**
	*/
	class Ed25519KeyHash {

	    static __wrap(ptr) {
	        const obj = Object.create(Ed25519KeyHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_ed25519keyhash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.ed25519keyhash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.ed25519keyhash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {Ed25519KeyHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.ed25519keyhash_from_bech32(ptr0, len0);
	        return Ed25519KeyHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Ed25519KeyHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.ed25519keyhash_from_bytes(ptr0, len0);
	        return Ed25519KeyHash.__wrap(ret);
	    }
	}
	module.exports.Ed25519KeyHash = Ed25519KeyHash;
	/**
	*/
	class Ed25519KeyHashes {

	    static __wrap(ptr) {
	        const obj = Object.create(Ed25519KeyHashes.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_ed25519keyhashes_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.ed25519keyhashes_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Ed25519KeyHashes}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.ed25519keyhashes_from_bytes(ptr0, len0);
	        return Ed25519KeyHashes.__wrap(ret);
	    }
	    /**
	    * @returns {Ed25519KeyHashes}
	    */
	    static new() {
	        var ret = wasm.ed25519keyhashes_new();
	        return Ed25519KeyHashes.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.ed25519keyhashes_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {Ed25519KeyHash}
	    */
	    get(index) {
	        var ret = wasm.ed25519keyhashes_get(this.ptr, index);
	        return Ed25519KeyHash.__wrap(ret);
	    }
	    /**
	    * @param {Ed25519KeyHash} elem
	    */
	    add(elem) {
	        _assertClass(elem, Ed25519KeyHash);
	        wasm.ed25519keyhashes_add(this.ptr, elem.ptr);
	    }
	    /**
	    * @returns {Ed25519KeyHashes | undefined}
	    */
	    to_option() {
	        var ret = wasm.ed25519keyhashes_to_option(this.ptr);
	        return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);
	    }
	}
	module.exports.Ed25519KeyHashes = Ed25519KeyHashes;
	/**
	*/
	class Ed25519Signature {

	    static __wrap(ptr) {
	        const obj = Object.create(Ed25519Signature.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_ed25519signature_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.ed25519signature_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @returns {string}
	    */
	    to_bech32() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.ed25519signature_to_bech32(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @returns {string}
	    */
	    to_hex() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.ed25519signature_to_hex(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech32_str
	    * @returns {Ed25519Signature}
	    */
	    static from_bech32(bech32_str) {
	        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.ed25519signature_from_bech32(ptr0, len0);
	        return Ed25519Signature.__wrap(ret);
	    }
	    /**
	    * @param {string} input
	    * @returns {Ed25519Signature}
	    */
	    static from_hex(input) {
	        var ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.ed25519signature_from_hex(ptr0, len0);
	        return Ed25519Signature.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Ed25519Signature}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.ed25519signature_from_bytes(ptr0, len0);
	        return Ed25519Signature.__wrap(ret);
	    }
	}
	module.exports.Ed25519Signature = Ed25519Signature;
	/**
	*/
	class EnterpriseAddress {

	    static __wrap(ptr) {
	        const obj = Object.create(EnterpriseAddress.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_enterpriseaddress_free(ptr);
	    }
	    /**
	    * @param {number} network
	    * @param {StakeCredential} payment
	    * @returns {EnterpriseAddress}
	    */
	    static new(network, payment) {
	        _assertClass(payment, StakeCredential);
	        var ret = wasm.enterpriseaddress_new(network, payment.ptr);
	        return EnterpriseAddress.__wrap(ret);
	    }
	    /**
	    * @returns {StakeCredential}
	    */
	    payment_cred() {
	        var ret = wasm.enterpriseaddress_payment_cred(this.ptr);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @returns {Address}
	    */
	    to_address() {
	        var ret = wasm.enterpriseaddress_to_address(this.ptr);
	        return Address.__wrap(ret);
	    }
	    /**
	    * @param {Address} addr
	    * @returns {EnterpriseAddress | undefined}
	    */
	    static from_address(addr) {
	        _assertClass(addr, Address);
	        var ret = wasm.enterpriseaddress_from_address(addr.ptr);
	        return ret === 0 ? undefined : EnterpriseAddress.__wrap(ret);
	    }
	}
	module.exports.EnterpriseAddress = EnterpriseAddress;
	/**
	*/
	class ExUnitPrices {

	    static __wrap(ptr) {
	        const obj = Object.create(ExUnitPrices.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_exunitprices_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.exunitprices_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ExUnitPrices}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.exunitprices_from_bytes(ptr0, len0);
	        return ExUnitPrices.__wrap(ret);
	    }
	    /**
	    * @returns {UnitInterval}
	    */
	    mem_price() {
	        var ret = wasm.exunitprices_mem_price(this.ptr);
	        return UnitInterval.__wrap(ret);
	    }
	    /**
	    * @returns {UnitInterval}
	    */
	    step_price() {
	        var ret = wasm.exunitprices_step_price(this.ptr);
	        return UnitInterval.__wrap(ret);
	    }
	    /**
	    * @param {UnitInterval} mem_price
	    * @param {UnitInterval} step_price
	    * @returns {ExUnitPrices}
	    */
	    static new(mem_price, step_price) {
	        _assertClass(mem_price, UnitInterval);
	        _assertClass(step_price, UnitInterval);
	        var ret = wasm.exunitprices_new(mem_price.ptr, step_price.ptr);
	        return ExUnitPrices.__wrap(ret);
	    }
	}
	module.exports.ExUnitPrices = ExUnitPrices;
	/**
	*/
	class ExUnits {

	    static __wrap(ptr) {
	        const obj = Object.create(ExUnits.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_exunits_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.exunits_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ExUnits}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.exunits_from_bytes(ptr0, len0);
	        return ExUnits.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    mem() {
	        var ret = wasm.exunits_mem(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    steps() {
	        var ret = wasm.exunits_steps(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} mem
	    * @param {BigNum} steps
	    * @returns {ExUnits}
	    */
	    static new(mem, steps) {
	        _assertClass(mem, BigNum);
	        _assertClass(steps, BigNum);
	        var ret = wasm.exunits_new(mem.ptr, steps.ptr);
	        return ExUnits.__wrap(ret);
	    }
	}
	module.exports.ExUnits = ExUnits;
	/**
	*/
	class GeneralTransactionMetadata {

	    static __wrap(ptr) {
	        const obj = Object.create(GeneralTransactionMetadata.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_generaltransactionmetadata_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.generaltransactionmetadata_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {GeneralTransactionMetadata}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.generaltransactionmetadata_from_bytes(ptr0, len0);
	        return GeneralTransactionMetadata.__wrap(ret);
	    }
	    /**
	    * @returns {GeneralTransactionMetadata}
	    */
	    static new() {
	        var ret = wasm.generaltransactionmetadata_new();
	        return GeneralTransactionMetadata.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.generaltransactionmetadata_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {BigNum} key
	    * @param {TransactionMetadatum} value
	    * @returns {TransactionMetadatum | undefined}
	    */
	    insert(key, value) {
	        _assertClass(key, BigNum);
	        _assertClass(value, TransactionMetadatum);
	        var ret = wasm.generaltransactionmetadata_insert(this.ptr, key.ptr, value.ptr);
	        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} key
	    * @returns {TransactionMetadatum | undefined}
	    */
	    get(key) {
	        _assertClass(key, BigNum);
	        var ret = wasm.generaltransactionmetadata_get(this.ptr, key.ptr);
	        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionMetadatumLabels}
	    */
	    keys() {
	        var ret = wasm.generaltransactionmetadata_keys(this.ptr);
	        return TransactionMetadatumLabels.__wrap(ret);
	    }
	}
	module.exports.GeneralTransactionMetadata = GeneralTransactionMetadata;
	/**
	*/
	class GenesisDelegateHash {

	    static __wrap(ptr) {
	        const obj = Object.create(GenesisDelegateHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_genesisdelegatehash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.genesisdelegatehash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.genesisdelegatehash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {GenesisDelegateHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.genesisdelegatehash_from_bech32(ptr0, len0);
	        return GenesisDelegateHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {GenesisDelegateHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.genesisdelegatehash_from_bytes(ptr0, len0);
	        return GenesisDelegateHash.__wrap(ret);
	    }
	}
	module.exports.GenesisDelegateHash = GenesisDelegateHash;
	/**
	*/
	class GenesisHash {

	    static __wrap(ptr) {
	        const obj = Object.create(GenesisHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_genesishash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.genesishash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.genesishash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {GenesisHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.genesishash_from_bech32(ptr0, len0);
	        return GenesisHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {GenesisHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.genesishash_from_bytes(ptr0, len0);
	        return GenesisHash.__wrap(ret);
	    }
	}
	module.exports.GenesisHash = GenesisHash;
	/**
	*/
	class GenesisHashes {

	    static __wrap(ptr) {
	        const obj = Object.create(GenesisHashes.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_genesishashes_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.genesishashes_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {GenesisHashes}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.genesishashes_from_bytes(ptr0, len0);
	        return GenesisHashes.__wrap(ret);
	    }
	    /**
	    * @returns {GenesisHashes}
	    */
	    static new() {
	        var ret = wasm.genesishashes_new();
	        return GenesisHashes.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.genesishashes_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {GenesisHash}
	    */
	    get(index) {
	        var ret = wasm.genesishashes_get(this.ptr, index);
	        return GenesisHash.__wrap(ret);
	    }
	    /**
	    * @param {GenesisHash} elem
	    */
	    add(elem) {
	        _assertClass(elem, GenesisHash);
	        wasm.genesishashes_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.GenesisHashes = GenesisHashes;
	/**
	*/
	class GenesisKeyDelegation {

	    static __wrap(ptr) {
	        const obj = Object.create(GenesisKeyDelegation.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_genesiskeydelegation_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.genesiskeydelegation_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {GenesisKeyDelegation}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.genesiskeydelegation_from_bytes(ptr0, len0);
	        return GenesisKeyDelegation.__wrap(ret);
	    }
	    /**
	    * @returns {GenesisHash}
	    */
	    genesishash() {
	        var ret = wasm.genesiskeydelegation_genesishash(this.ptr);
	        return GenesisHash.__wrap(ret);
	    }
	    /**
	    * @returns {GenesisDelegateHash}
	    */
	    genesis_delegate_hash() {
	        var ret = wasm.genesiskeydelegation_genesis_delegate_hash(this.ptr);
	        return GenesisDelegateHash.__wrap(ret);
	    }
	    /**
	    * @returns {VRFKeyHash}
	    */
	    vrf_keyhash() {
	        var ret = wasm.genesiskeydelegation_vrf_keyhash(this.ptr);
	        return VRFKeyHash.__wrap(ret);
	    }
	    /**
	    * @param {GenesisHash} genesishash
	    * @param {GenesisDelegateHash} genesis_delegate_hash
	    * @param {VRFKeyHash} vrf_keyhash
	    * @returns {GenesisKeyDelegation}
	    */
	    static new(genesishash, genesis_delegate_hash, vrf_keyhash) {
	        _assertClass(genesishash, GenesisHash);
	        _assertClass(genesis_delegate_hash, GenesisDelegateHash);
	        _assertClass(vrf_keyhash, VRFKeyHash);
	        var ret = wasm.genesiskeydelegation_new(genesishash.ptr, genesis_delegate_hash.ptr, vrf_keyhash.ptr);
	        return GenesisKeyDelegation.__wrap(ret);
	    }
	}
	module.exports.GenesisKeyDelegation = GenesisKeyDelegation;
	/**
	*/
	class Header {

	    static __wrap(ptr) {
	        const obj = Object.create(Header.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_header_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.header_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Header}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.header_from_bytes(ptr0, len0);
	        return Header.__wrap(ret);
	    }
	    /**
	    * @returns {HeaderBody}
	    */
	    header_body() {
	        var ret = wasm.header_header_body(this.ptr);
	        return HeaderBody.__wrap(ret);
	    }
	    /**
	    * @returns {KESSignature}
	    */
	    body_signature() {
	        var ret = wasm.header_body_signature(this.ptr);
	        return KESSignature.__wrap(ret);
	    }
	    /**
	    * @param {HeaderBody} header_body
	    * @param {KESSignature} body_signature
	    * @returns {Header}
	    */
	    static new(header_body, body_signature) {
	        _assertClass(header_body, HeaderBody);
	        _assertClass(body_signature, KESSignature);
	        var ret = wasm.header_new(header_body.ptr, body_signature.ptr);
	        return Header.__wrap(ret);
	    }
	}
	module.exports.Header = Header;
	/**
	*/
	class HeaderBody {

	    static __wrap(ptr) {
	        const obj = Object.create(HeaderBody.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_headerbody_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.headerbody_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {HeaderBody}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.headerbody_from_bytes(ptr0, len0);
	        return HeaderBody.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    block_number() {
	        var ret = wasm.headerbody_block_number(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.
	    * Otherwise will just raise an error.
	    * @returns {number}
	    */
	    slot() {
	        var ret = wasm.headerbody_slot(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {BigNum}
	    */
	    slot_bignum() {
	        var ret = wasm.headerbody_slot_bignum(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {BlockHash | undefined}
	    */
	    prev_hash() {
	        var ret = wasm.headerbody_prev_hash(this.ptr);
	        return ret === 0 ? undefined : BlockHash.__wrap(ret);
	    }
	    /**
	    * @returns {Vkey}
	    */
	    issuer_vkey() {
	        var ret = wasm.headerbody_issuer_vkey(this.ptr);
	        return Vkey.__wrap(ret);
	    }
	    /**
	    * @returns {VRFVKey}
	    */
	    vrf_vkey() {
	        var ret = wasm.headerbody_vrf_vkey(this.ptr);
	        return VRFVKey.__wrap(ret);
	    }
	    /**
	    * @returns {VRFCert}
	    */
	    nonce_vrf() {
	        var ret = wasm.headerbody_nonce_vrf(this.ptr);
	        return VRFCert.__wrap(ret);
	    }
	    /**
	    * @returns {VRFCert}
	    */
	    leader_vrf() {
	        var ret = wasm.headerbody_leader_vrf(this.ptr);
	        return VRFCert.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    block_body_size() {
	        var ret = wasm.headerbody_block_body_size(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {BlockHash}
	    */
	    block_body_hash() {
	        var ret = wasm.headerbody_block_body_hash(this.ptr);
	        return BlockHash.__wrap(ret);
	    }
	    /**
	    * @returns {OperationalCert}
	    */
	    operational_cert() {
	        var ret = wasm.headerbody_operational_cert(this.ptr);
	        return OperationalCert.__wrap(ret);
	    }
	    /**
	    * @returns {ProtocolVersion}
	    */
	    protocol_version() {
	        var ret = wasm.headerbody_protocol_version(this.ptr);
	        return ProtocolVersion.__wrap(ret);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * This constructor uses outdated slot number format.
	    * Use `.new_headerbody` instead
	    * @param {number} block_number
	    * @param {number} slot
	    * @param {BlockHash | undefined} prev_hash
	    * @param {Vkey} issuer_vkey
	    * @param {VRFVKey} vrf_vkey
	    * @param {VRFCert} nonce_vrf
	    * @param {VRFCert} leader_vrf
	    * @param {number} block_body_size
	    * @param {BlockHash} block_body_hash
	    * @param {OperationalCert} operational_cert
	    * @param {ProtocolVersion} protocol_version
	    * @returns {HeaderBody}
	    */
	    static new(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, nonce_vrf, leader_vrf, block_body_size, block_body_hash, operational_cert, protocol_version) {
	        let ptr0 = 0;
	        if (!isLikeNone(prev_hash)) {
	            _assertClass(prev_hash, BlockHash);
	            ptr0 = prev_hash.ptr;
	            prev_hash.ptr = 0;
	        }
	        _assertClass(issuer_vkey, Vkey);
	        _assertClass(vrf_vkey, VRFVKey);
	        _assertClass(nonce_vrf, VRFCert);
	        _assertClass(leader_vrf, VRFCert);
	        _assertClass(block_body_hash, BlockHash);
	        _assertClass(operational_cert, OperationalCert);
	        _assertClass(protocol_version, ProtocolVersion);
	        var ret = wasm.headerbody_new(block_number, slot, ptr0, issuer_vkey.ptr, vrf_vkey.ptr, nonce_vrf.ptr, leader_vrf.ptr, block_body_size, block_body_hash.ptr, operational_cert.ptr, protocol_version.ptr);
	        return HeaderBody.__wrap(ret);
	    }
	    /**
	    * @param {number} block_number
	    * @param {BigNum} slot
	    * @param {BlockHash | undefined} prev_hash
	    * @param {Vkey} issuer_vkey
	    * @param {VRFVKey} vrf_vkey
	    * @param {VRFCert} nonce_vrf
	    * @param {VRFCert} leader_vrf
	    * @param {number} block_body_size
	    * @param {BlockHash} block_body_hash
	    * @param {OperationalCert} operational_cert
	    * @param {ProtocolVersion} protocol_version
	    * @returns {HeaderBody}
	    */
	    static new_headerbody(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, nonce_vrf, leader_vrf, block_body_size, block_body_hash, operational_cert, protocol_version) {
	        _assertClass(slot, BigNum);
	        let ptr0 = 0;
	        if (!isLikeNone(prev_hash)) {
	            _assertClass(prev_hash, BlockHash);
	            ptr0 = prev_hash.ptr;
	            prev_hash.ptr = 0;
	        }
	        _assertClass(issuer_vkey, Vkey);
	        _assertClass(vrf_vkey, VRFVKey);
	        _assertClass(nonce_vrf, VRFCert);
	        _assertClass(leader_vrf, VRFCert);
	        _assertClass(block_body_hash, BlockHash);
	        _assertClass(operational_cert, OperationalCert);
	        _assertClass(protocol_version, ProtocolVersion);
	        var ret = wasm.headerbody_new_headerbody(block_number, slot.ptr, ptr0, issuer_vkey.ptr, vrf_vkey.ptr, nonce_vrf.ptr, leader_vrf.ptr, block_body_size, block_body_hash.ptr, operational_cert.ptr, protocol_version.ptr);
	        return HeaderBody.__wrap(ret);
	    }
	}
	module.exports.HeaderBody = HeaderBody;
	/**
	*/
	class Int {

	    static __wrap(ptr) {
	        const obj = Object.create(Int.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_int_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.int_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Int}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.int_from_bytes(ptr0, len0);
	        return Int.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} x
	    * @returns {Int}
	    */
	    static new(x) {
	        _assertClass(x, BigNum);
	        var ret = wasm.int_new(x.ptr);
	        return Int.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} x
	    * @returns {Int}
	    */
	    static new_negative(x) {
	        _assertClass(x, BigNum);
	        var ret = wasm.int_new_negative(x.ptr);
	        return Int.__wrap(ret);
	    }
	    /**
	    * @param {number} x
	    * @returns {Int}
	    */
	    static new_i32(x) {
	        var ret = wasm.int_new_i32(x);
	        return Int.__wrap(ret);
	    }
	    /**
	    * @returns {boolean}
	    */
	    is_positive() {
	        var ret = wasm.int_is_positive(this.ptr);
	        return ret !== 0;
	    }
	    /**
	    * BigNum can only contain unsigned u64 values
	    *
	    * This function will return the BigNum representation
	    * only in case the underlying i128 value is positive.
	    *
	    * Otherwise nothing will be returned (undefined).
	    * @returns {BigNum | undefined}
	    */
	    as_positive() {
	        var ret = wasm.int_as_positive(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * BigNum can only contain unsigned u64 values
	    *
	    * This function will return the *absolute* BigNum representation
	    * only in case the underlying i128 value is negative.
	    *
	    * Otherwise nothing will be returned (undefined).
	    * @returns {BigNum | undefined}
	    */
	    as_negative() {
	        var ret = wasm.int_as_negative(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * Returns an i32 value in case the underlying original i128 value is within the limits.
	    * Otherwise will just return an empty value (undefined).
	    * @returns {number | undefined}
	    */
	    as_i32() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.int_as_i32(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * Returns the underlying value converted to i32 if possible (within limits)
	    * Otherwise will just return an empty value (undefined).
	    * @returns {number | undefined}
	    */
	    as_i32_or_nothing() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.int_as_i32_or_nothing(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * Returns the underlying value converted to i32 if possible (within limits)
	    * JsError in case of out of boundary overflow
	    * @returns {number}
	    */
	    as_i32_or_fail() {
	        var ret = wasm.int_as_i32_or_fail(this.ptr);
	        return ret;
	    }
	    /**
	    * Returns string representation of the underlying i128 value directly.
	    * Might contain the minus sign (-) in case of negative value.
	    * @returns {string}
	    */
	    to_str() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.int_to_str(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	}
	module.exports.Int = Int;
	/**
	*/
	class Ipv4 {

	    static __wrap(ptr) {
	        const obj = Object.create(Ipv4.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_ipv4_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.ipv4_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Ipv4}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.ipv4_from_bytes(ptr0, len0);
	        return Ipv4.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} data
	    * @returns {Ipv4}
	    */
	    static new(data) {
	        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.ipv4_new(ptr0, len0);
	        return Ipv4.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    ip() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.ipv4_ip(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	}
	module.exports.Ipv4 = Ipv4;
	/**
	*/
	class Ipv6 {

	    static __wrap(ptr) {
	        const obj = Object.create(Ipv6.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_ipv6_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.ipv6_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Ipv6}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.ipv6_from_bytes(ptr0, len0);
	        return Ipv6.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} data
	    * @returns {Ipv6}
	    */
	    static new(data) {
	        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.ipv6_new(ptr0, len0);
	        return Ipv6.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    ip() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.ipv6_ip(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	}
	module.exports.Ipv6 = Ipv6;
	/**
	*/
	class KESSignature {

	    static __wrap(ptr) {
	        const obj = Object.create(KESSignature.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_kessignature_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.kessignature_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {KESSignature}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.kessignature_from_bytes(ptr0, len0);
	        return KESSignature.__wrap(ret);
	    }
	}
	module.exports.KESSignature = KESSignature;
	/**
	*/
	class KESVKey {

	    static __wrap(ptr) {
	        const obj = Object.create(KESVKey.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_kesvkey_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.kesvkey_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.kesvkey_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {KESVKey}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.kesvkey_from_bech32(ptr0, len0);
	        return KESVKey.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {KESVKey}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.kesvkey_from_bytes(ptr0, len0);
	        return KESVKey.__wrap(ret);
	    }
	}
	module.exports.KESVKey = KESVKey;
	/**
	*/
	class Language {

	    static __wrap(ptr) {
	        const obj = Object.create(Language.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_language_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.language_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Language}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.language_from_bytes(ptr0, len0);
	        return Language.__wrap(ret);
	    }
	    /**
	    * @returns {Language}
	    */
	    static new_plutus_v1() {
	        var ret = wasm.language_new_plutus_v1();
	        return Language.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    kind() {
	        var ret = wasm.language_kind(this.ptr);
	        return ret >>> 0;
	    }
	}
	module.exports.Language = Language;
	/**
	*/
	class Languages {

	    static __wrap(ptr) {
	        const obj = Object.create(Languages.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_languages_free(ptr);
	    }
	    /**
	    * @returns {Languages}
	    */
	    static new() {
	        var ret = wasm.languages_new();
	        return Languages.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.languages_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {Language}
	    */
	    get(index) {
	        var ret = wasm.languages_get(this.ptr, index);
	        return Language.__wrap(ret);
	    }
	    /**
	    * @param {Language} elem
	    */
	    add(elem) {
	        _assertClass(elem, Language);
	        var ptr0 = elem.ptr;
	        elem.ptr = 0;
	        wasm.languages_add(this.ptr, ptr0);
	    }
	}
	module.exports.Languages = Languages;
	/**
	*/
	class LegacyDaedalusPrivateKey {

	    static __wrap(ptr) {
	        const obj = Object.create(LegacyDaedalusPrivateKey.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_legacydaedalusprivatekey_free(ptr);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {LegacyDaedalusPrivateKey}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.legacydaedalusprivatekey_from_bytes(ptr0, len0);
	        return LegacyDaedalusPrivateKey.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    as_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.legacydaedalusprivatekey_as_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    chaincode() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.legacydaedalusprivatekey_chaincode(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	}
	module.exports.LegacyDaedalusPrivateKey = LegacyDaedalusPrivateKey;
	/**
	*/
	class LinearFee {

	    static __wrap(ptr) {
	        const obj = Object.create(LinearFee.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_linearfee_free(ptr);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    constant() {
	        var ret = wasm.linearfee_constant(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    coefficient() {
	        var ret = wasm.linearfee_coefficient(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} coefficient
	    * @param {BigNum} constant
	    * @returns {LinearFee}
	    */
	    static new(coefficient, constant) {
	        _assertClass(coefficient, BigNum);
	        _assertClass(constant, BigNum);
	        var ret = wasm.linearfee_new(coefficient.ptr, constant.ptr);
	        return LinearFee.__wrap(ret);
	    }
	}
	module.exports.LinearFee = LinearFee;
	/**
	*/
	class MIRToStakeCredentials {

	    static __wrap(ptr) {
	        const obj = Object.create(MIRToStakeCredentials.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_mirtostakecredentials_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.mirtostakecredentials_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {MIRToStakeCredentials}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.mirtostakecredentials_from_bytes(ptr0, len0);
	        return MIRToStakeCredentials.__wrap(ret);
	    }
	    /**
	    * @returns {MIRToStakeCredentials}
	    */
	    static new() {
	        var ret = wasm.mirtostakecredentials_new();
	        return MIRToStakeCredentials.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.mirtostakecredentials_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {StakeCredential} cred
	    * @param {Int} delta
	    * @returns {Int | undefined}
	    */
	    insert(cred, delta) {
	        _assertClass(cred, StakeCredential);
	        _assertClass(delta, Int);
	        var ret = wasm.mirtostakecredentials_insert(this.ptr, cred.ptr, delta.ptr);
	        return ret === 0 ? undefined : Int.__wrap(ret);
	    }
	    /**
	    * @param {StakeCredential} cred
	    * @returns {Int | undefined}
	    */
	    get(cred) {
	        _assertClass(cred, StakeCredential);
	        var ret = wasm.mirtostakecredentials_get(this.ptr, cred.ptr);
	        return ret === 0 ? undefined : Int.__wrap(ret);
	    }
	    /**
	    * @returns {StakeCredentials}
	    */
	    keys() {
	        var ret = wasm.mirtostakecredentials_keys(this.ptr);
	        return StakeCredentials.__wrap(ret);
	    }
	}
	module.exports.MIRToStakeCredentials = MIRToStakeCredentials;
	/**
	*/
	class MetadataList {

	    static __wrap(ptr) {
	        const obj = Object.create(MetadataList.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_metadatalist_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.metadatalist_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {MetadataList}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.metadatalist_from_bytes(ptr0, len0);
	        return MetadataList.__wrap(ret);
	    }
	    /**
	    * @returns {MetadataList}
	    */
	    static new() {
	        var ret = wasm.metadatalist_new();
	        return MetadataList.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.metadatalist_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {TransactionMetadatum}
	    */
	    get(index) {
	        var ret = wasm.metadatalist_get(this.ptr, index);
	        return TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {TransactionMetadatum} elem
	    */
	    add(elem) {
	        _assertClass(elem, TransactionMetadatum);
	        wasm.metadatalist_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.MetadataList = MetadataList;
	/**
	*/
	class MetadataMap {

	    static __wrap(ptr) {
	        const obj = Object.create(MetadataMap.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_metadatamap_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.metadatamap_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {MetadataMap}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.metadatamap_from_bytes(ptr0, len0);
	        return MetadataMap.__wrap(ret);
	    }
	    /**
	    * @returns {MetadataMap}
	    */
	    static new() {
	        var ret = wasm.metadatamap_new();
	        return MetadataMap.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.metadatamap_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {TransactionMetadatum} key
	    * @param {TransactionMetadatum} value
	    * @returns {TransactionMetadatum | undefined}
	    */
	    insert(key, value) {
	        _assertClass(key, TransactionMetadatum);
	        _assertClass(value, TransactionMetadatum);
	        var ret = wasm.metadatamap_insert(this.ptr, key.ptr, value.ptr);
	        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {string} key
	    * @param {TransactionMetadatum} value
	    * @returns {TransactionMetadatum | undefined}
	    */
	    insert_str(key, value) {
	        var ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        _assertClass(value, TransactionMetadatum);
	        var ret = wasm.metadatamap_insert_str(this.ptr, ptr0, len0, value.ptr);
	        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {number} key
	    * @param {TransactionMetadatum} value
	    * @returns {TransactionMetadatum | undefined}
	    */
	    insert_i32(key, value) {
	        _assertClass(value, TransactionMetadatum);
	        var ret = wasm.metadatamap_insert_i32(this.ptr, key, value.ptr);
	        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {TransactionMetadatum} key
	    * @returns {TransactionMetadatum}
	    */
	    get(key) {
	        _assertClass(key, TransactionMetadatum);
	        var ret = wasm.metadatamap_get(this.ptr, key.ptr);
	        return TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {string} key
	    * @returns {TransactionMetadatum}
	    */
	    get_str(key) {
	        var ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.metadatamap_get_str(this.ptr, ptr0, len0);
	        return TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {number} key
	    * @returns {TransactionMetadatum}
	    */
	    get_i32(key) {
	        var ret = wasm.metadatamap_get_i32(this.ptr, key);
	        return TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {TransactionMetadatum} key
	    * @returns {boolean}
	    */
	    has(key) {
	        _assertClass(key, TransactionMetadatum);
	        var ret = wasm.metadatamap_has(this.ptr, key.ptr);
	        return ret !== 0;
	    }
	    /**
	    * @returns {MetadataList}
	    */
	    keys() {
	        var ret = wasm.metadatamap_keys(this.ptr);
	        return MetadataList.__wrap(ret);
	    }
	}
	module.exports.MetadataMap = MetadataMap;
	/**
	*/
	class Mint {

	    static __wrap(ptr) {
	        const obj = Object.create(Mint.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_mint_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.mint_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Mint}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.mint_from_bytes(ptr0, len0);
	        return Mint.__wrap(ret);
	    }
	    /**
	    * @returns {Mint}
	    */
	    static new() {
	        var ret = wasm.mint_new();
	        return Mint.__wrap(ret);
	    }
	    /**
	    * @param {ScriptHash} key
	    * @param {MintAssets} value
	    * @returns {Mint}
	    */
	    static new_from_entry(key, value) {
	        _assertClass(key, ScriptHash);
	        _assertClass(value, MintAssets);
	        var ret = wasm.mint_new_from_entry(key.ptr, value.ptr);
	        return Mint.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.mint_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {ScriptHash} key
	    * @param {MintAssets} value
	    * @returns {MintAssets | undefined}
	    */
	    insert(key, value) {
	        _assertClass(key, ScriptHash);
	        _assertClass(value, MintAssets);
	        var ret = wasm.mint_insert(this.ptr, key.ptr, value.ptr);
	        return ret === 0 ? undefined : MintAssets.__wrap(ret);
	    }
	    /**
	    * @param {ScriptHash} key
	    * @returns {MintAssets | undefined}
	    */
	    get(key) {
	        _assertClass(key, ScriptHash);
	        var ret = wasm.mint_get(this.ptr, key.ptr);
	        return ret === 0 ? undefined : MintAssets.__wrap(ret);
	    }
	    /**
	    * @returns {ScriptHashes}
	    */
	    keys() {
	        var ret = wasm.mint_keys(this.ptr);
	        return ScriptHashes.__wrap(ret);
	    }
	    /**
	    * Returns the multiasset where only positive (minting) entries are present
	    * @returns {MultiAsset}
	    */
	    as_positive_multiasset() {
	        var ret = wasm.mint_as_positive_multiasset(this.ptr);
	        return MultiAsset.__wrap(ret);
	    }
	    /**
	    * Returns the multiasset where only negative (burning) entries are present
	    * @returns {MultiAsset}
	    */
	    as_negative_multiasset() {
	        var ret = wasm.mint_as_negative_multiasset(this.ptr);
	        return MultiAsset.__wrap(ret);
	    }
	}
	module.exports.Mint = Mint;
	/**
	*/
	class MintAssets {

	    static __wrap(ptr) {
	        const obj = Object.create(MintAssets.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_mintassets_free(ptr);
	    }
	    /**
	    * @returns {MintAssets}
	    */
	    static new() {
	        var ret = wasm.mintassets_new();
	        return MintAssets.__wrap(ret);
	    }
	    /**
	    * @param {AssetName} key
	    * @param {Int} value
	    * @returns {MintAssets}
	    */
	    static new_from_entry(key, value) {
	        _assertClass(key, AssetName);
	        _assertClass(value, Int);
	        var ptr0 = value.ptr;
	        value.ptr = 0;
	        var ret = wasm.mintassets_new_from_entry(key.ptr, ptr0);
	        return MintAssets.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.mintassets_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {AssetName} key
	    * @param {Int} value
	    * @returns {Int | undefined}
	    */
	    insert(key, value) {
	        _assertClass(key, AssetName);
	        _assertClass(value, Int);
	        var ptr0 = value.ptr;
	        value.ptr = 0;
	        var ret = wasm.mintassets_insert(this.ptr, key.ptr, ptr0);
	        return ret === 0 ? undefined : Int.__wrap(ret);
	    }
	    /**
	    * @param {AssetName} key
	    * @returns {Int | undefined}
	    */
	    get(key) {
	        _assertClass(key, AssetName);
	        var ret = wasm.mintassets_get(this.ptr, key.ptr);
	        return ret === 0 ? undefined : Int.__wrap(ret);
	    }
	    /**
	    * @returns {AssetNames}
	    */
	    keys() {
	        var ret = wasm.mintassets_keys(this.ptr);
	        return AssetNames.__wrap(ret);
	    }
	}
	module.exports.MintAssets = MintAssets;
	/**
	*/
	class MoveInstantaneousReward {

	    static __wrap(ptr) {
	        const obj = Object.create(MoveInstantaneousReward.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_moveinstantaneousreward_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.moveinstantaneousreward_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {MoveInstantaneousReward}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.moveinstantaneousreward_from_bytes(ptr0, len0);
	        return MoveInstantaneousReward.__wrap(ret);
	    }
	    /**
	    * @param {number} pot
	    * @param {BigNum} amount
	    * @returns {MoveInstantaneousReward}
	    */
	    static new_to_other_pot(pot, amount) {
	        _assertClass(amount, BigNum);
	        var ret = wasm.moveinstantaneousreward_new_to_other_pot(pot, amount.ptr);
	        return MoveInstantaneousReward.__wrap(ret);
	    }
	    /**
	    * @param {number} pot
	    * @param {MIRToStakeCredentials} amounts
	    * @returns {MoveInstantaneousReward}
	    */
	    static new_to_stake_creds(pot, amounts) {
	        _assertClass(amounts, MIRToStakeCredentials);
	        var ret = wasm.moveinstantaneousreward_new_to_stake_creds(pot, amounts.ptr);
	        return MoveInstantaneousReward.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    pot() {
	        var ret = wasm.moveinstantaneousreward_pot(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {number}
	    */
	    kind() {
	        var ret = wasm.moveinstantaneousreward_kind(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    as_to_other_pot() {
	        var ret = wasm.moveinstantaneousreward_as_to_other_pot(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {MIRToStakeCredentials | undefined}
	    */
	    as_to_stake_creds() {
	        var ret = wasm.moveinstantaneousreward_as_to_stake_creds(this.ptr);
	        return ret === 0 ? undefined : MIRToStakeCredentials.__wrap(ret);
	    }
	}
	module.exports.MoveInstantaneousReward = MoveInstantaneousReward;
	/**
	*/
	class MoveInstantaneousRewardsCert {

	    static __wrap(ptr) {
	        const obj = Object.create(MoveInstantaneousRewardsCert.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_moveinstantaneousrewardscert_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.moveinstantaneousrewardscert_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {MoveInstantaneousRewardsCert}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.moveinstantaneousrewardscert_from_bytes(ptr0, len0);
	        return MoveInstantaneousRewardsCert.__wrap(ret);
	    }
	    /**
	    * @returns {MoveInstantaneousReward}
	    */
	    move_instantaneous_reward() {
	        var ret = wasm.moveinstantaneousrewardscert_move_instantaneous_reward(this.ptr);
	        return MoveInstantaneousReward.__wrap(ret);
	    }
	    /**
	    * @param {MoveInstantaneousReward} move_instantaneous_reward
	    * @returns {MoveInstantaneousRewardsCert}
	    */
	    static new(move_instantaneous_reward) {
	        _assertClass(move_instantaneous_reward, MoveInstantaneousReward);
	        var ret = wasm.moveinstantaneousrewardscert_new(move_instantaneous_reward.ptr);
	        return MoveInstantaneousRewardsCert.__wrap(ret);
	    }
	}
	module.exports.MoveInstantaneousRewardsCert = MoveInstantaneousRewardsCert;
	/**
	*/
	class MultiAsset {

	    static __wrap(ptr) {
	        const obj = Object.create(MultiAsset.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_multiasset_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.multiasset_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {MultiAsset}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.multiasset_from_bytes(ptr0, len0);
	        return MultiAsset.__wrap(ret);
	    }
	    /**
	    * @returns {MultiAsset}
	    */
	    static new() {
	        var ret = wasm.multiasset_new();
	        return MultiAsset.__wrap(ret);
	    }
	    /**
	    * the number of unique policy IDs in the multiasset
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.multiasset_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * set (and replace if it exists) all assets with policy {policy_id} to a copy of {assets}
	    * @param {ScriptHash} policy_id
	    * @param {Assets} assets
	    * @returns {Assets | undefined}
	    */
	    insert(policy_id, assets) {
	        _assertClass(policy_id, ScriptHash);
	        _assertClass(assets, Assets);
	        var ret = wasm.multiasset_insert(this.ptr, policy_id.ptr, assets.ptr);
	        return ret === 0 ? undefined : Assets.__wrap(ret);
	    }
	    /**
	    * all assets under {policy_id}, if any exist, or else None (undefined in JS)
	    * @param {ScriptHash} policy_id
	    * @returns {Assets | undefined}
	    */
	    get(policy_id) {
	        _assertClass(policy_id, ScriptHash);
	        var ret = wasm.multiasset_get(this.ptr, policy_id.ptr);
	        return ret === 0 ? undefined : Assets.__wrap(ret);
	    }
	    /**
	    * sets the asset {asset_name} to {value} under policy {policy_id}
	    * returns the previous amount if it was set, or else None (undefined in JS)
	    * @param {ScriptHash} policy_id
	    * @param {AssetName} asset_name
	    * @param {BigNum} value
	    * @returns {BigNum | undefined}
	    */
	    set_asset(policy_id, asset_name, value) {
	        _assertClass(policy_id, ScriptHash);
	        _assertClass(asset_name, AssetName);
	        _assertClass(value, BigNum);
	        var ptr0 = value.ptr;
	        value.ptr = 0;
	        var ret = wasm.multiasset_set_asset(this.ptr, policy_id.ptr, asset_name.ptr, ptr0);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * returns the amount of asset {asset_name} under policy {policy_id}
	    * If such an asset does not exist, 0 is returned.
	    * @param {ScriptHash} policy_id
	    * @param {AssetName} asset_name
	    * @returns {BigNum}
	    */
	    get_asset(policy_id, asset_name) {
	        _assertClass(policy_id, ScriptHash);
	        _assertClass(asset_name, AssetName);
	        var ret = wasm.multiasset_get_asset(this.ptr, policy_id.ptr, asset_name.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * returns all policy IDs used by assets in this multiasset
	    * @returns {ScriptHashes}
	    */
	    keys() {
	        var ret = wasm.multiasset_keys(this.ptr);
	        return ScriptHashes.__wrap(ret);
	    }
	    /**
	    * removes an asset from the list if the result is 0 or less
	    * does not modify this object, instead the result is returned
	    * @param {MultiAsset} rhs_ma
	    * @returns {MultiAsset}
	    */
	    sub(rhs_ma) {
	        _assertClass(rhs_ma, MultiAsset);
	        var ret = wasm.multiasset_sub(this.ptr, rhs_ma.ptr);
	        return MultiAsset.__wrap(ret);
	    }
	}
	module.exports.MultiAsset = MultiAsset;
	/**
	*/
	class MultiHostName {

	    static __wrap(ptr) {
	        const obj = Object.create(MultiHostName.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_multihostname_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.multihostname_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {MultiHostName}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.multihostname_from_bytes(ptr0, len0);
	        return MultiHostName.__wrap(ret);
	    }
	    /**
	    * @returns {DNSRecordSRV}
	    */
	    dns_name() {
	        var ret = wasm.multihostname_dns_name(this.ptr);
	        return DNSRecordSRV.__wrap(ret);
	    }
	    /**
	    * @param {DNSRecordSRV} dns_name
	    * @returns {MultiHostName}
	    */
	    static new(dns_name) {
	        _assertClass(dns_name, DNSRecordSRV);
	        var ret = wasm.multihostname_new(dns_name.ptr);
	        return MultiHostName.__wrap(ret);
	    }
	}
	module.exports.MultiHostName = MultiHostName;
	/**
	*/
	class NativeScript {

	    static __wrap(ptr) {
	        const obj = Object.create(NativeScript.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_nativescript_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.nativescript_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {NativeScript}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.nativescript_from_bytes(ptr0, len0);
	        return NativeScript.__wrap(ret);
	    }
	    /**
	    * @returns {ScriptHash}
	    */
	    hash() {
	        var ret = wasm.nativescript_hash(this.ptr);
	        return ScriptHash.__wrap(ret);
	    }
	    /**
	    * @param {ScriptPubkey} script_pubkey
	    * @returns {NativeScript}
	    */
	    static new_script_pubkey(script_pubkey) {
	        _assertClass(script_pubkey, ScriptPubkey);
	        var ret = wasm.nativescript_new_script_pubkey(script_pubkey.ptr);
	        return NativeScript.__wrap(ret);
	    }
	    /**
	    * @param {ScriptAll} script_all
	    * @returns {NativeScript}
	    */
	    static new_script_all(script_all) {
	        _assertClass(script_all, ScriptAll);
	        var ret = wasm.nativescript_new_script_all(script_all.ptr);
	        return NativeScript.__wrap(ret);
	    }
	    /**
	    * @param {ScriptAny} script_any
	    * @returns {NativeScript}
	    */
	    static new_script_any(script_any) {
	        _assertClass(script_any, ScriptAny);
	        var ret = wasm.nativescript_new_script_any(script_any.ptr);
	        return NativeScript.__wrap(ret);
	    }
	    /**
	    * @param {ScriptNOfK} script_n_of_k
	    * @returns {NativeScript}
	    */
	    static new_script_n_of_k(script_n_of_k) {
	        _assertClass(script_n_of_k, ScriptNOfK);
	        var ret = wasm.nativescript_new_script_n_of_k(script_n_of_k.ptr);
	        return NativeScript.__wrap(ret);
	    }
	    /**
	    * @param {TimelockStart} timelock_start
	    * @returns {NativeScript}
	    */
	    static new_timelock_start(timelock_start) {
	        _assertClass(timelock_start, TimelockStart);
	        var ret = wasm.nativescript_new_timelock_start(timelock_start.ptr);
	        return NativeScript.__wrap(ret);
	    }
	    /**
	    * @param {TimelockExpiry} timelock_expiry
	    * @returns {NativeScript}
	    */
	    static new_timelock_expiry(timelock_expiry) {
	        _assertClass(timelock_expiry, TimelockExpiry);
	        var ret = wasm.nativescript_new_timelock_expiry(timelock_expiry.ptr);
	        return NativeScript.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    kind() {
	        var ret = wasm.nativescript_kind(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {ScriptPubkey | undefined}
	    */
	    as_script_pubkey() {
	        var ret = wasm.nativescript_as_script_pubkey(this.ptr);
	        return ret === 0 ? undefined : ScriptPubkey.__wrap(ret);
	    }
	    /**
	    * @returns {ScriptAll | undefined}
	    */
	    as_script_all() {
	        var ret = wasm.nativescript_as_script_all(this.ptr);
	        return ret === 0 ? undefined : ScriptAll.__wrap(ret);
	    }
	    /**
	    * @returns {ScriptAny | undefined}
	    */
	    as_script_any() {
	        var ret = wasm.nativescript_as_script_any(this.ptr);
	        return ret === 0 ? undefined : ScriptAny.__wrap(ret);
	    }
	    /**
	    * @returns {ScriptNOfK | undefined}
	    */
	    as_script_n_of_k() {
	        var ret = wasm.nativescript_as_script_n_of_k(this.ptr);
	        return ret === 0 ? undefined : ScriptNOfK.__wrap(ret);
	    }
	    /**
	    * @returns {TimelockStart | undefined}
	    */
	    as_timelock_start() {
	        var ret = wasm.nativescript_as_timelock_start(this.ptr);
	        return ret === 0 ? undefined : TimelockStart.__wrap(ret);
	    }
	    /**
	    * @returns {TimelockExpiry | undefined}
	    */
	    as_timelock_expiry() {
	        var ret = wasm.nativescript_as_timelock_expiry(this.ptr);
	        return ret === 0 ? undefined : TimelockExpiry.__wrap(ret);
	    }
	    /**
	    * Returns an array of unique Ed25519KeyHashes
	    * contained within this script recursively on any depth level.
	    * The order of the keys in the result is not determined in any way.
	    * @returns {Ed25519KeyHashes}
	    */
	    get_required_signers() {
	        var ret = wasm.nativescript_get_required_signers(this.ptr);
	        return Ed25519KeyHashes.__wrap(ret);
	    }
	}
	module.exports.NativeScript = NativeScript;
	/**
	*/
	class NativeScripts {

	    static __wrap(ptr) {
	        const obj = Object.create(NativeScripts.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_nativescripts_free(ptr);
	    }
	    /**
	    * @returns {NativeScripts}
	    */
	    static new() {
	        var ret = wasm.nativescripts_new();
	        return NativeScripts.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.nativescripts_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {NativeScript}
	    */
	    get(index) {
	        var ret = wasm.nativescripts_get(this.ptr, index);
	        return NativeScript.__wrap(ret);
	    }
	    /**
	    * @param {NativeScript} elem
	    */
	    add(elem) {
	        _assertClass(elem, NativeScript);
	        wasm.nativescripts_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.NativeScripts = NativeScripts;
	/**
	*/
	class NetworkId {

	    static __wrap(ptr) {
	        const obj = Object.create(NetworkId.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_networkid_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.networkid_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {NetworkId}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.networkid_from_bytes(ptr0, len0);
	        return NetworkId.__wrap(ret);
	    }
	    /**
	    * @returns {NetworkId}
	    */
	    static testnet() {
	        var ret = wasm.networkid_testnet();
	        return NetworkId.__wrap(ret);
	    }
	    /**
	    * @returns {NetworkId}
	    */
	    static mainnet() {
	        var ret = wasm.networkid_mainnet();
	        return NetworkId.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    kind() {
	        var ret = wasm.networkid_kind(this.ptr);
	        return ret >>> 0;
	    }
	}
	module.exports.NetworkId = NetworkId;
	/**
	*/
	class NetworkInfo {

	    static __wrap(ptr) {
	        const obj = Object.create(NetworkInfo.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_networkinfo_free(ptr);
	    }
	    /**
	    * @param {number} network_id
	    * @param {number} protocol_magic
	    * @returns {NetworkInfo}
	    */
	    static new(network_id, protocol_magic) {
	        var ret = wasm.networkinfo_new(network_id, protocol_magic);
	        return NetworkInfo.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    network_id() {
	        var ret = wasm.networkinfo_network_id(this.ptr);
	        return ret;
	    }
	    /**
	    * @returns {number}
	    */
	    protocol_magic() {
	        var ret = wasm.networkinfo_protocol_magic(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {NetworkInfo}
	    */
	    static testnet() {
	        var ret = wasm.networkinfo_testnet();
	        return NetworkInfo.__wrap(ret);
	    }
	    /**
	    * @returns {NetworkInfo}
	    */
	    static mainnet() {
	        var ret = wasm.networkinfo_mainnet();
	        return NetworkInfo.__wrap(ret);
	    }
	}
	module.exports.NetworkInfo = NetworkInfo;
	/**
	*/
	class Nonce {

	    static __wrap(ptr) {
	        const obj = Object.create(Nonce.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_nonce_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.nonce_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Nonce}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.nonce_from_bytes(ptr0, len0);
	        return Nonce.__wrap(ret);
	    }
	    /**
	    * @returns {Nonce}
	    */
	    static new_identity() {
	        var ret = wasm.nonce_new_identity();
	        return Nonce.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} hash
	    * @returns {Nonce}
	    */
	    static new_from_hash(hash) {
	        var ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.nonce_new_from_hash(ptr0, len0);
	        return Nonce.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array | undefined}
	    */
	    get_hash() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.nonce_get_hash(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            let v0;
	            if (r0 !== 0) {
	                v0 = getArrayU8FromWasm0(r0, r1).slice();
	                wasm.__wbindgen_free(r0, r1 * 1);
	            }
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	}
	module.exports.Nonce = Nonce;
	/**
	*/
	class OperationalCert {

	    static __wrap(ptr) {
	        const obj = Object.create(OperationalCert.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_operationalcert_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.operationalcert_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {OperationalCert}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.operationalcert_from_bytes(ptr0, len0);
	        return OperationalCert.__wrap(ret);
	    }
	    /**
	    * @returns {KESVKey}
	    */
	    hot_vkey() {
	        var ret = wasm.operationalcert_hot_vkey(this.ptr);
	        return KESVKey.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    sequence_number() {
	        var ret = wasm.operationalcert_sequence_number(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {number}
	    */
	    kes_period() {
	        var ret = wasm.operationalcert_kes_period(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {Ed25519Signature}
	    */
	    sigma() {
	        var ret = wasm.operationalcert_sigma(this.ptr);
	        return Ed25519Signature.__wrap(ret);
	    }
	    /**
	    * @param {KESVKey} hot_vkey
	    * @param {number} sequence_number
	    * @param {number} kes_period
	    * @param {Ed25519Signature} sigma
	    * @returns {OperationalCert}
	    */
	    static new(hot_vkey, sequence_number, kes_period, sigma) {
	        _assertClass(hot_vkey, KESVKey);
	        _assertClass(sigma, Ed25519Signature);
	        var ret = wasm.operationalcert_new(hot_vkey.ptr, sequence_number, kes_period, sigma.ptr);
	        return OperationalCert.__wrap(ret);
	    }
	}
	module.exports.OperationalCert = OperationalCert;
	/**
	*/
	class PlutusData {

	    static __wrap(ptr) {
	        const obj = Object.create(PlutusData.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_plutusdata_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.plutusdata_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PlutusData}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.plutusdata_from_bytes(ptr0, len0);
	        return PlutusData.__wrap(ret);
	    }
	    /**
	    * @param {ConstrPlutusData} constr_plutus_data
	    * @returns {PlutusData}
	    */
	    static new_constr_plutus_data(constr_plutus_data) {
	        _assertClass(constr_plutus_data, ConstrPlutusData);
	        var ret = wasm.plutusdata_new_constr_plutus_data(constr_plutus_data.ptr);
	        return PlutusData.__wrap(ret);
	    }
	    /**
	    * Same as `.new_constr_plutus_data` but creates constr with empty data list
	    * @param {BigNum} alternative
	    * @returns {PlutusData}
	    */
	    static new_empty_constr_plutus_data(alternative) {
	        _assertClass(alternative, BigNum);
	        var ret = wasm.plutusdata_new_empty_constr_plutus_data(alternative.ptr);
	        return PlutusData.__wrap(ret);
	    }
	    /**
	    * @param {PlutusMap} map
	    * @returns {PlutusData}
	    */
	    static new_map(map) {
	        _assertClass(map, PlutusMap);
	        var ret = wasm.plutusdata_new_map(map.ptr);
	        return PlutusData.__wrap(ret);
	    }
	    /**
	    * @param {PlutusList} list
	    * @returns {PlutusData}
	    */
	    static new_list(list) {
	        _assertClass(list, PlutusList);
	        var ret = wasm.plutusdata_new_list(list.ptr);
	        return PlutusData.__wrap(ret);
	    }
	    /**
	    * @param {BigInt} integer
	    * @returns {PlutusData}
	    */
	    static new_integer(integer) {
	        _assertClass(integer, BigInt);
	        var ret = wasm.plutusdata_new_integer(integer.ptr);
	        return PlutusData.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PlutusData}
	    */
	    static new_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.plutusdata_new_bytes(ptr0, len0);
	        return PlutusData.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    kind() {
	        var ret = wasm.plutusdata_kind(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {ConstrPlutusData | undefined}
	    */
	    as_constr_plutus_data() {
	        var ret = wasm.plutusdata_as_constr_plutus_data(this.ptr);
	        return ret === 0 ? undefined : ConstrPlutusData.__wrap(ret);
	    }
	    /**
	    * @returns {PlutusMap | undefined}
	    */
	    as_map() {
	        var ret = wasm.plutusdata_as_map(this.ptr);
	        return ret === 0 ? undefined : PlutusMap.__wrap(ret);
	    }
	    /**
	    * @returns {PlutusList | undefined}
	    */
	    as_list() {
	        var ret = wasm.plutusdata_as_list(this.ptr);
	        return ret === 0 ? undefined : PlutusList.__wrap(ret);
	    }
	    /**
	    * @returns {BigInt | undefined}
	    */
	    as_integer() {
	        var ret = wasm.plutusdata_as_integer(this.ptr);
	        return ret === 0 ? undefined : BigInt.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array | undefined}
	    */
	    as_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.plutusdata_as_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            let v0;
	            if (r0 !== 0) {
	                v0 = getArrayU8FromWasm0(r0, r1).slice();
	                wasm.__wbindgen_free(r0, r1 * 1);
	            }
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	}
	module.exports.PlutusData = PlutusData;
	/**
	*/
	class PlutusList {

	    static __wrap(ptr) {
	        const obj = Object.create(PlutusList.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_plutuslist_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.plutuslist_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PlutusList}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.plutuslist_from_bytes(ptr0, len0);
	        return PlutusList.__wrap(ret);
	    }
	    /**
	    * @returns {PlutusList}
	    */
	    static new() {
	        var ret = wasm.plutuslist_new();
	        return PlutusList.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.plutuslist_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {PlutusData}
	    */
	    get(index) {
	        var ret = wasm.plutuslist_get(this.ptr, index);
	        return PlutusData.__wrap(ret);
	    }
	    /**
	    * @param {PlutusData} elem
	    */
	    add(elem) {
	        _assertClass(elem, PlutusData);
	        wasm.plutuslist_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.PlutusList = PlutusList;
	/**
	*/
	class PlutusMap {

	    static __wrap(ptr) {
	        const obj = Object.create(PlutusMap.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_plutusmap_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.plutusmap_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PlutusMap}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.plutusmap_from_bytes(ptr0, len0);
	        return PlutusMap.__wrap(ret);
	    }
	    /**
	    * @returns {PlutusMap}
	    */
	    static new() {
	        var ret = wasm.plutusmap_new();
	        return PlutusMap.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.plutusmap_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {PlutusData} key
	    * @param {PlutusData} value
	    * @returns {PlutusData | undefined}
	    */
	    insert(key, value) {
	        _assertClass(key, PlutusData);
	        _assertClass(value, PlutusData);
	        var ret = wasm.plutusmap_insert(this.ptr, key.ptr, value.ptr);
	        return ret === 0 ? undefined : PlutusData.__wrap(ret);
	    }
	    /**
	    * @param {PlutusData} key
	    * @returns {PlutusData | undefined}
	    */
	    get(key) {
	        _assertClass(key, PlutusData);
	        var ret = wasm.plutusmap_get(this.ptr, key.ptr);
	        return ret === 0 ? undefined : PlutusData.__wrap(ret);
	    }
	    /**
	    * @returns {PlutusList}
	    */
	    keys() {
	        var ret = wasm.plutusmap_keys(this.ptr);
	        return PlutusList.__wrap(ret);
	    }
	}
	module.exports.PlutusMap = PlutusMap;
	/**
	*/
	class PlutusScript {

	    static __wrap(ptr) {
	        const obj = Object.create(PlutusScript.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_plutusscript_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.plutusscript_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PlutusScript}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.plutusscript_from_bytes(ptr0, len0);
	        return PlutusScript.__wrap(ret);
	    }
	    /**
	    *
	    *     * Creates a new Plutus script from the RAW bytes of the compiled script.
	    *     * This does NOT include any CBOR encoding around these bytes (e.g. from "cborBytes" in cardano-cli)
	    *     * If you creating this from those you should use PlutusScript::from_bytes() instead.
	    *
	    * @param {Uint8Array} bytes
	    * @returns {PlutusScript}
	    */
	    static new(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.plutusscript_new(ptr0, len0);
	        return PlutusScript.__wrap(ret);
	    }
	    /**
	    *
	    *     * The raw bytes of this compiled Plutus script.
	    *     * If you need "cborBytes" for cardano-cli use PlutusScript::to_bytes() instead.
	    *
	    * @returns {Uint8Array}
	    */
	    bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.plutusscript_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @returns {ScriptHash}
	    */
	    hash() {
	        var ret = wasm.plutusscript_hash(this.ptr);
	        return ScriptHash.__wrap(ret);
	    }
	}
	module.exports.PlutusScript = PlutusScript;
	/**
	*/
	class PlutusScripts {

	    static __wrap(ptr) {
	        const obj = Object.create(PlutusScripts.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_plutusscripts_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.plutusscripts_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PlutusScripts}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.plutusscripts_from_bytes(ptr0, len0);
	        return PlutusScripts.__wrap(ret);
	    }
	    /**
	    * @returns {PlutusScripts}
	    */
	    static new() {
	        var ret = wasm.plutusscripts_new();
	        return PlutusScripts.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.plutusscripts_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {PlutusScript}
	    */
	    get(index) {
	        var ret = wasm.plutusscripts_get(this.ptr, index);
	        return PlutusScript.__wrap(ret);
	    }
	    /**
	    * @param {PlutusScript} elem
	    */
	    add(elem) {
	        _assertClass(elem, PlutusScript);
	        wasm.plutusscripts_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.PlutusScripts = PlutusScripts;
	/**
	*/
	class PlutusWitness {

	    static __wrap(ptr) {
	        const obj = Object.create(PlutusWitness.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_plutuswitness_free(ptr);
	    }
	    /**
	    * @param {PlutusScript} script
	    * @param {PlutusData} datum
	    * @param {Redeemer} redeemer
	    * @returns {PlutusWitness}
	    */
	    static new(script, datum, redeemer) {
	        _assertClass(script, PlutusScript);
	        _assertClass(datum, PlutusData);
	        _assertClass(redeemer, Redeemer);
	        var ret = wasm.plutuswitness_new(script.ptr, datum.ptr, redeemer.ptr);
	        return PlutusWitness.__wrap(ret);
	    }
	    /**
	    * @returns {PlutusScript}
	    */
	    script() {
	        var ret = wasm.plutuswitness_script(this.ptr);
	        return PlutusScript.__wrap(ret);
	    }
	    /**
	    * @returns {PlutusData}
	    */
	    datum() {
	        var ret = wasm.plutuswitness_datum(this.ptr);
	        return PlutusData.__wrap(ret);
	    }
	    /**
	    * @returns {Redeemer}
	    */
	    redeemer() {
	        var ret = wasm.plutuswitness_redeemer(this.ptr);
	        return Redeemer.__wrap(ret);
	    }
	}
	module.exports.PlutusWitness = PlutusWitness;
	/**
	*/
	class PlutusWitnesses {

	    static __wrap(ptr) {
	        const obj = Object.create(PlutusWitnesses.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_plutuswitnesses_free(ptr);
	    }
	    /**
	    * @returns {PlutusWitnesses}
	    */
	    static new() {
	        var ret = wasm.plutuswitnesses_new();
	        return PlutusWitnesses.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.plutuswitnesses_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {PlutusWitness}
	    */
	    get(index) {
	        var ret = wasm.plutuswitnesses_get(this.ptr, index);
	        return PlutusWitness.__wrap(ret);
	    }
	    /**
	    * @param {PlutusWitness} elem
	    */
	    add(elem) {
	        _assertClass(elem, PlutusWitness);
	        wasm.plutuswitnesses_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.PlutusWitnesses = PlutusWitnesses;
	/**
	*/
	class Pointer {

	    static __wrap(ptr) {
	        const obj = Object.create(Pointer.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_pointer_free(ptr);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * This constructor uses outdated slot number format for the ttl value, tx_index and cert_index.
	    * Use `.new_pointer` instead
	    * @param {number} slot
	    * @param {number} tx_index
	    * @param {number} cert_index
	    * @returns {Pointer}
	    */
	    static new(slot, tx_index, cert_index) {
	        var ret = wasm.pointer_new(slot, tx_index, cert_index);
	        return Pointer.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} slot
	    * @param {BigNum} tx_index
	    * @param {BigNum} cert_index
	    * @returns {Pointer}
	    */
	    static new_pointer(slot, tx_index, cert_index) {
	        _assertClass(slot, BigNum);
	        _assertClass(tx_index, BigNum);
	        _assertClass(cert_index, BigNum);
	        var ret = wasm.pointer_new_pointer(slot.ptr, tx_index.ptr, cert_index.ptr);
	        return Pointer.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    slot() {
	        var ret = wasm.pointer_slot(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {number}
	    */
	    tx_index() {
	        var ret = wasm.pointer_tx_index(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {number}
	    */
	    cert_index() {
	        var ret = wasm.pointer_cert_index(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {BigNum}
	    */
	    slot_bignum() {
	        var ret = wasm.pointer_slot_bignum(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    tx_index_bignum() {
	        var ret = wasm.pointer_tx_index_bignum(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    cert_index_bignum() {
	        var ret = wasm.pointer_cert_index_bignum(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	}
	module.exports.Pointer = Pointer;
	/**
	*/
	class PointerAddress {

	    static __wrap(ptr) {
	        const obj = Object.create(PointerAddress.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_pointeraddress_free(ptr);
	    }
	    /**
	    * @param {number} network
	    * @param {StakeCredential} payment
	    * @param {Pointer} stake
	    * @returns {PointerAddress}
	    */
	    static new(network, payment, stake) {
	        _assertClass(payment, StakeCredential);
	        _assertClass(stake, Pointer);
	        var ret = wasm.pointeraddress_new(network, payment.ptr, stake.ptr);
	        return PointerAddress.__wrap(ret);
	    }
	    /**
	    * @returns {StakeCredential}
	    */
	    payment_cred() {
	        var ret = wasm.pointeraddress_payment_cred(this.ptr);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @returns {Pointer}
	    */
	    stake_pointer() {
	        var ret = wasm.pointeraddress_stake_pointer(this.ptr);
	        return Pointer.__wrap(ret);
	    }
	    /**
	    * @returns {Address}
	    */
	    to_address() {
	        var ret = wasm.pointeraddress_to_address(this.ptr);
	        return Address.__wrap(ret);
	    }
	    /**
	    * @param {Address} addr
	    * @returns {PointerAddress | undefined}
	    */
	    static from_address(addr) {
	        _assertClass(addr, Address);
	        var ret = wasm.pointeraddress_from_address(addr.ptr);
	        return ret === 0 ? undefined : PointerAddress.__wrap(ret);
	    }
	}
	module.exports.PointerAddress = PointerAddress;
	/**
	*/
	class PoolMetadata {

	    static __wrap(ptr) {
	        const obj = Object.create(PoolMetadata.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_poolmetadata_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.poolmetadata_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PoolMetadata}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.poolmetadata_from_bytes(ptr0, len0);
	        return PoolMetadata.__wrap(ret);
	    }
	    /**
	    * @returns {URL}
	    */
	    url() {
	        var ret = wasm.poolmetadata_url(this.ptr);
	        return URL.__wrap(ret);
	    }
	    /**
	    * @returns {PoolMetadataHash}
	    */
	    pool_metadata_hash() {
	        var ret = wasm.poolmetadata_pool_metadata_hash(this.ptr);
	        return PoolMetadataHash.__wrap(ret);
	    }
	    /**
	    * @param {URL} url
	    * @param {PoolMetadataHash} pool_metadata_hash
	    * @returns {PoolMetadata}
	    */
	    static new(url, pool_metadata_hash) {
	        _assertClass(url, URL);
	        _assertClass(pool_metadata_hash, PoolMetadataHash);
	        var ret = wasm.poolmetadata_new(url.ptr, pool_metadata_hash.ptr);
	        return PoolMetadata.__wrap(ret);
	    }
	}
	module.exports.PoolMetadata = PoolMetadata;
	/**
	*/
	class PoolMetadataHash {

	    static __wrap(ptr) {
	        const obj = Object.create(PoolMetadataHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_poolmetadatahash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.poolmetadatahash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.poolmetadatahash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {PoolMetadataHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.poolmetadatahash_from_bech32(ptr0, len0);
	        return PoolMetadataHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PoolMetadataHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.poolmetadatahash_from_bytes(ptr0, len0);
	        return PoolMetadataHash.__wrap(ret);
	    }
	}
	module.exports.PoolMetadataHash = PoolMetadataHash;
	/**
	*/
	class PoolParams {

	    static __wrap(ptr) {
	        const obj = Object.create(PoolParams.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_poolparams_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.poolparams_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PoolParams}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.poolparams_from_bytes(ptr0, len0);
	        return PoolParams.__wrap(ret);
	    }
	    /**
	    * @returns {Ed25519KeyHash}
	    */
	    operator() {
	        var ret = wasm.poolparams_operator(this.ptr);
	        return Ed25519KeyHash.__wrap(ret);
	    }
	    /**
	    * @returns {VRFKeyHash}
	    */
	    vrf_keyhash() {
	        var ret = wasm.poolparams_vrf_keyhash(this.ptr);
	        return VRFKeyHash.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    pledge() {
	        var ret = wasm.poolparams_pledge(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    cost() {
	        var ret = wasm.poolparams_cost(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {UnitInterval}
	    */
	    margin() {
	        var ret = wasm.poolparams_margin(this.ptr);
	        return UnitInterval.__wrap(ret);
	    }
	    /**
	    * @returns {RewardAddress}
	    */
	    reward_account() {
	        var ret = wasm.poolparams_reward_account(this.ptr);
	        return RewardAddress.__wrap(ret);
	    }
	    /**
	    * @returns {Ed25519KeyHashes}
	    */
	    pool_owners() {
	        var ret = wasm.poolparams_pool_owners(this.ptr);
	        return Ed25519KeyHashes.__wrap(ret);
	    }
	    /**
	    * @returns {Relays}
	    */
	    relays() {
	        var ret = wasm.poolparams_relays(this.ptr);
	        return Relays.__wrap(ret);
	    }
	    /**
	    * @returns {PoolMetadata | undefined}
	    */
	    pool_metadata() {
	        var ret = wasm.poolparams_pool_metadata(this.ptr);
	        return ret === 0 ? undefined : PoolMetadata.__wrap(ret);
	    }
	    /**
	    * @param {Ed25519KeyHash} operator
	    * @param {VRFKeyHash} vrf_keyhash
	    * @param {BigNum} pledge
	    * @param {BigNum} cost
	    * @param {UnitInterval} margin
	    * @param {RewardAddress} reward_account
	    * @param {Ed25519KeyHashes} pool_owners
	    * @param {Relays} relays
	    * @param {PoolMetadata | undefined} pool_metadata
	    * @returns {PoolParams}
	    */
	    static new(operator, vrf_keyhash, pledge, cost, margin, reward_account, pool_owners, relays, pool_metadata) {
	        _assertClass(operator, Ed25519KeyHash);
	        _assertClass(vrf_keyhash, VRFKeyHash);
	        _assertClass(pledge, BigNum);
	        _assertClass(cost, BigNum);
	        _assertClass(margin, UnitInterval);
	        _assertClass(reward_account, RewardAddress);
	        _assertClass(pool_owners, Ed25519KeyHashes);
	        _assertClass(relays, Relays);
	        let ptr0 = 0;
	        if (!isLikeNone(pool_metadata)) {
	            _assertClass(pool_metadata, PoolMetadata);
	            ptr0 = pool_metadata.ptr;
	            pool_metadata.ptr = 0;
	        }
	        var ret = wasm.poolparams_new(operator.ptr, vrf_keyhash.ptr, pledge.ptr, cost.ptr, margin.ptr, reward_account.ptr, pool_owners.ptr, relays.ptr, ptr0);
	        return PoolParams.__wrap(ret);
	    }
	}
	module.exports.PoolParams = PoolParams;
	/**
	*/
	class PoolRegistration {

	    static __wrap(ptr) {
	        const obj = Object.create(PoolRegistration.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_poolregistration_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.poolregistration_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PoolRegistration}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.poolregistration_from_bytes(ptr0, len0);
	        return PoolRegistration.__wrap(ret);
	    }
	    /**
	    * @returns {PoolParams}
	    */
	    pool_params() {
	        var ret = wasm.poolregistration_pool_params(this.ptr);
	        return PoolParams.__wrap(ret);
	    }
	    /**
	    * @param {PoolParams} pool_params
	    * @returns {PoolRegistration}
	    */
	    static new(pool_params) {
	        _assertClass(pool_params, PoolParams);
	        var ret = wasm.poolregistration_new(pool_params.ptr);
	        return PoolRegistration.__wrap(ret);
	    }
	}
	module.exports.PoolRegistration = PoolRegistration;
	/**
	*/
	class PoolRetirement {

	    static __wrap(ptr) {
	        const obj = Object.create(PoolRetirement.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_poolretirement_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.poolretirement_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PoolRetirement}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.poolretirement_from_bytes(ptr0, len0);
	        return PoolRetirement.__wrap(ret);
	    }
	    /**
	    * @returns {Ed25519KeyHash}
	    */
	    pool_keyhash() {
	        var ret = wasm.poolretirement_pool_keyhash(this.ptr);
	        return Ed25519KeyHash.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    epoch() {
	        var ret = wasm.poolretirement_epoch(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {Ed25519KeyHash} pool_keyhash
	    * @param {number} epoch
	    * @returns {PoolRetirement}
	    */
	    static new(pool_keyhash, epoch) {
	        _assertClass(pool_keyhash, Ed25519KeyHash);
	        var ret = wasm.poolretirement_new(pool_keyhash.ptr, epoch);
	        return PoolRetirement.__wrap(ret);
	    }
	}
	module.exports.PoolRetirement = PoolRetirement;
	/**
	*/
	class PrivateKey {

	    static __wrap(ptr) {
	        const obj = Object.create(PrivateKey.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_privatekey_free(ptr);
	    }
	    /**
	    * @returns {PublicKey}
	    */
	    to_public() {
	        var ret = wasm.privatekey_to_public(this.ptr);
	        return PublicKey.__wrap(ret);
	    }
	    /**
	    * @returns {PrivateKey}
	    */
	    static generate_ed25519() {
	        var ret = wasm.privatekey_generate_ed25519();
	        return PrivateKey.__wrap(ret);
	    }
	    /**
	    * @returns {PrivateKey}
	    */
	    static generate_ed25519extended() {
	        var ret = wasm.privatekey_generate_ed25519extended();
	        return PrivateKey.__wrap(ret);
	    }
	    /**
	    * Get private key from its bech32 representation
	    * ```javascript
	    * PrivateKey.from_bech32(&#39;ed25519_sk1ahfetf02qwwg4dkq7mgp4a25lx5vh9920cr5wnxmpzz9906qvm8qwvlts0&#39;);
	    * ```
	    * For an extended 25519 key
	    * ```javascript
	    * PrivateKey.from_bech32(&#39;ed25519e_sk1gqwl4szuwwh6d0yk3nsqcc6xxc3fpvjlevgwvt60df59v8zd8f8prazt8ln3lmz096ux3xvhhvm3ca9wj2yctdh3pnw0szrma07rt5gl748fp&#39;);
	    * ```
	    * @param {string} bech32_str
	    * @returns {PrivateKey}
	    */
	    static from_bech32(bech32_str) {
	        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.privatekey_from_bech32(ptr0, len0);
	        return PrivateKey.__wrap(ret);
	    }
	    /**
	    * @returns {string}
	    */
	    to_bech32() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.privatekey_to_bech32(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    as_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.privatekey_as_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PrivateKey}
	    */
	    static from_extended_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.privatekey_from_extended_bytes(ptr0, len0);
	        return PrivateKey.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PrivateKey}
	    */
	    static from_normal_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.privatekey_from_normal_bytes(ptr0, len0);
	        return PrivateKey.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} message
	    * @returns {Ed25519Signature}
	    */
	    sign(message) {
	        var ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.privatekey_sign(this.ptr, ptr0, len0);
	        return Ed25519Signature.__wrap(ret);
	    }
	}
	module.exports.PrivateKey = PrivateKey;
	/**
	*/
	class ProposedProtocolParameterUpdates {

	    static __wrap(ptr) {
	        const obj = Object.create(ProposedProtocolParameterUpdates.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_proposedprotocolparameterupdates_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.proposedprotocolparameterupdates_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ProposedProtocolParameterUpdates}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.proposedprotocolparameterupdates_from_bytes(ptr0, len0);
	        return ProposedProtocolParameterUpdates.__wrap(ret);
	    }
	    /**
	    * @returns {ProposedProtocolParameterUpdates}
	    */
	    static new() {
	        var ret = wasm.proposedprotocolparameterupdates_new();
	        return ProposedProtocolParameterUpdates.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.proposedprotocolparameterupdates_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {GenesisHash} key
	    * @param {ProtocolParamUpdate} value
	    * @returns {ProtocolParamUpdate | undefined}
	    */
	    insert(key, value) {
	        _assertClass(key, GenesisHash);
	        _assertClass(value, ProtocolParamUpdate);
	        var ret = wasm.proposedprotocolparameterupdates_insert(this.ptr, key.ptr, value.ptr);
	        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);
	    }
	    /**
	    * @param {GenesisHash} key
	    * @returns {ProtocolParamUpdate | undefined}
	    */
	    get(key) {
	        _assertClass(key, GenesisHash);
	        var ret = wasm.proposedprotocolparameterupdates_get(this.ptr, key.ptr);
	        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);
	    }
	    /**
	    * @returns {GenesisHashes}
	    */
	    keys() {
	        var ret = wasm.proposedprotocolparameterupdates_keys(this.ptr);
	        return GenesisHashes.__wrap(ret);
	    }
	}
	module.exports.ProposedProtocolParameterUpdates = ProposedProtocolParameterUpdates;
	/**
	*/
	class ProtocolParamUpdate {

	    static __wrap(ptr) {
	        const obj = Object.create(ProtocolParamUpdate.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_protocolparamupdate_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolparamupdate_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ProtocolParamUpdate}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.protocolparamupdate_from_bytes(ptr0, len0);
	        return ProtocolParamUpdate.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} minfee_a
	    */
	    set_minfee_a(minfee_a) {
	        _assertClass(minfee_a, BigNum);
	        wasm.protocolparamupdate_set_minfee_a(this.ptr, minfee_a.ptr);
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    minfee_a() {
	        var ret = wasm.protocolparamupdate_minfee_a(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} minfee_b
	    */
	    set_minfee_b(minfee_b) {
	        _assertClass(minfee_b, BigNum);
	        wasm.protocolparamupdate_set_minfee_b(this.ptr, minfee_b.ptr);
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    minfee_b() {
	        var ret = wasm.protocolparamupdate_minfee_b(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @param {number} max_block_body_size
	    */
	    set_max_block_body_size(max_block_body_size) {
	        wasm.protocolparamupdate_set_max_block_body_size(this.ptr, max_block_body_size);
	    }
	    /**
	    * @returns {number | undefined}
	    */
	    max_block_body_size() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolparamupdate_max_block_body_size(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1 >>> 0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {number} max_tx_size
	    */
	    set_max_tx_size(max_tx_size) {
	        wasm.protocolparamupdate_set_max_tx_size(this.ptr, max_tx_size);
	    }
	    /**
	    * @returns {number | undefined}
	    */
	    max_tx_size() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolparamupdate_max_tx_size(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1 >>> 0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {number} max_block_header_size
	    */
	    set_max_block_header_size(max_block_header_size) {
	        wasm.protocolparamupdate_set_max_block_header_size(this.ptr, max_block_header_size);
	    }
	    /**
	    * @returns {number | undefined}
	    */
	    max_block_header_size() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolparamupdate_max_block_header_size(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1 >>> 0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {BigNum} key_deposit
	    */
	    set_key_deposit(key_deposit) {
	        _assertClass(key_deposit, BigNum);
	        wasm.protocolparamupdate_set_key_deposit(this.ptr, key_deposit.ptr);
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    key_deposit() {
	        var ret = wasm.protocolparamupdate_key_deposit(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} pool_deposit
	    */
	    set_pool_deposit(pool_deposit) {
	        _assertClass(pool_deposit, BigNum);
	        wasm.protocolparamupdate_set_pool_deposit(this.ptr, pool_deposit.ptr);
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    pool_deposit() {
	        var ret = wasm.protocolparamupdate_pool_deposit(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @param {number} max_epoch
	    */
	    set_max_epoch(max_epoch) {
	        wasm.protocolparamupdate_set_max_epoch(this.ptr, max_epoch);
	    }
	    /**
	    * @returns {number | undefined}
	    */
	    max_epoch() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolparamupdate_max_epoch(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1 >>> 0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {number} n_opt
	    */
	    set_n_opt(n_opt) {
	        wasm.protocolparamupdate_set_n_opt(this.ptr, n_opt);
	    }
	    /**
	    * @returns {number | undefined}
	    */
	    n_opt() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolparamupdate_n_opt(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1 >>> 0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {UnitInterval} pool_pledge_influence
	    */
	    set_pool_pledge_influence(pool_pledge_influence) {
	        _assertClass(pool_pledge_influence, UnitInterval);
	        wasm.protocolparamupdate_set_pool_pledge_influence(this.ptr, pool_pledge_influence.ptr);
	    }
	    /**
	    * @returns {UnitInterval | undefined}
	    */
	    pool_pledge_influence() {
	        var ret = wasm.protocolparamupdate_pool_pledge_influence(this.ptr);
	        return ret === 0 ? undefined : UnitInterval.__wrap(ret);
	    }
	    /**
	    * @param {UnitInterval} expansion_rate
	    */
	    set_expansion_rate(expansion_rate) {
	        _assertClass(expansion_rate, UnitInterval);
	        wasm.protocolparamupdate_set_expansion_rate(this.ptr, expansion_rate.ptr);
	    }
	    /**
	    * @returns {UnitInterval | undefined}
	    */
	    expansion_rate() {
	        var ret = wasm.protocolparamupdate_expansion_rate(this.ptr);
	        return ret === 0 ? undefined : UnitInterval.__wrap(ret);
	    }
	    /**
	    * @param {UnitInterval} treasury_growth_rate
	    */
	    set_treasury_growth_rate(treasury_growth_rate) {
	        _assertClass(treasury_growth_rate, UnitInterval);
	        wasm.protocolparamupdate_set_treasury_growth_rate(this.ptr, treasury_growth_rate.ptr);
	    }
	    /**
	    * @returns {UnitInterval | undefined}
	    */
	    treasury_growth_rate() {
	        var ret = wasm.protocolparamupdate_treasury_growth_rate(this.ptr);
	        return ret === 0 ? undefined : UnitInterval.__wrap(ret);
	    }
	    /**
	    * @param {UnitInterval} d
	    */
	    set_d(d) {
	        _assertClass(d, UnitInterval);
	        wasm.protocolparamupdate_set_d(this.ptr, d.ptr);
	    }
	    /**
	    * @returns {UnitInterval | undefined}
	    */
	    d() {
	        var ret = wasm.protocolparamupdate_d(this.ptr);
	        return ret === 0 ? undefined : UnitInterval.__wrap(ret);
	    }
	    /**
	    * @param {Nonce} extra_entropy
	    */
	    set_extra_entropy(extra_entropy) {
	        _assertClass(extra_entropy, Nonce);
	        wasm.protocolparamupdate_set_extra_entropy(this.ptr, extra_entropy.ptr);
	    }
	    /**
	    * @returns {Nonce | undefined}
	    */
	    extra_entropy() {
	        var ret = wasm.protocolparamupdate_extra_entropy(this.ptr);
	        return ret === 0 ? undefined : Nonce.__wrap(ret);
	    }
	    /**
	    * @param {ProtocolVersions} protocol_version
	    */
	    set_protocol_version(protocol_version) {
	        _assertClass(protocol_version, ProtocolVersions);
	        wasm.protocolparamupdate_set_protocol_version(this.ptr, protocol_version.ptr);
	    }
	    /**
	    * @returns {ProtocolVersions | undefined}
	    */
	    protocol_version() {
	        var ret = wasm.protocolparamupdate_protocol_version(this.ptr);
	        return ret === 0 ? undefined : ProtocolVersions.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} min_pool_cost
	    */
	    set_min_pool_cost(min_pool_cost) {
	        _assertClass(min_pool_cost, BigNum);
	        wasm.protocolparamupdate_set_min_pool_cost(this.ptr, min_pool_cost.ptr);
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    min_pool_cost() {
	        var ret = wasm.protocolparamupdate_min_pool_cost(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} ada_per_utxo_byte
	    */
	    set_ada_per_utxo_byte(ada_per_utxo_byte) {
	        _assertClass(ada_per_utxo_byte, BigNum);
	        wasm.protocolparamupdate_set_ada_per_utxo_byte(this.ptr, ada_per_utxo_byte.ptr);
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    ada_per_utxo_byte() {
	        var ret = wasm.protocolparamupdate_ada_per_utxo_byte(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @param {Costmdls} cost_models
	    */
	    set_cost_models(cost_models) {
	        _assertClass(cost_models, Costmdls);
	        wasm.protocolparamupdate_set_cost_models(this.ptr, cost_models.ptr);
	    }
	    /**
	    * @returns {Costmdls | undefined}
	    */
	    cost_models() {
	        var ret = wasm.protocolparamupdate_cost_models(this.ptr);
	        return ret === 0 ? undefined : Costmdls.__wrap(ret);
	    }
	    /**
	    * @param {ExUnitPrices} execution_costs
	    */
	    set_execution_costs(execution_costs) {
	        _assertClass(execution_costs, ExUnitPrices);
	        wasm.protocolparamupdate_set_execution_costs(this.ptr, execution_costs.ptr);
	    }
	    /**
	    * @returns {ExUnitPrices | undefined}
	    */
	    execution_costs() {
	        var ret = wasm.protocolparamupdate_execution_costs(this.ptr);
	        return ret === 0 ? undefined : ExUnitPrices.__wrap(ret);
	    }
	    /**
	    * @param {ExUnits} max_tx_ex_units
	    */
	    set_max_tx_ex_units(max_tx_ex_units) {
	        _assertClass(max_tx_ex_units, ExUnits);
	        wasm.protocolparamupdate_set_max_tx_ex_units(this.ptr, max_tx_ex_units.ptr);
	    }
	    /**
	    * @returns {ExUnits | undefined}
	    */
	    max_tx_ex_units() {
	        var ret = wasm.protocolparamupdate_max_tx_ex_units(this.ptr);
	        return ret === 0 ? undefined : ExUnits.__wrap(ret);
	    }
	    /**
	    * @param {ExUnits} max_block_ex_units
	    */
	    set_max_block_ex_units(max_block_ex_units) {
	        _assertClass(max_block_ex_units, ExUnits);
	        wasm.protocolparamupdate_set_max_block_ex_units(this.ptr, max_block_ex_units.ptr);
	    }
	    /**
	    * @returns {ExUnits | undefined}
	    */
	    max_block_ex_units() {
	        var ret = wasm.protocolparamupdate_max_block_ex_units(this.ptr);
	        return ret === 0 ? undefined : ExUnits.__wrap(ret);
	    }
	    /**
	    * @param {number} max_value_size
	    */
	    set_max_value_size(max_value_size) {
	        wasm.protocolparamupdate_set_max_value_size(this.ptr, max_value_size);
	    }
	    /**
	    * @returns {number | undefined}
	    */
	    max_value_size() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolparamupdate_max_value_size(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1 >>> 0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {number} collateral_percentage
	    */
	    set_collateral_percentage(collateral_percentage) {
	        wasm.protocolparamupdate_set_collateral_percentage(this.ptr, collateral_percentage);
	    }
	    /**
	    * @returns {number | undefined}
	    */
	    collateral_percentage() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolparamupdate_collateral_percentage(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1 >>> 0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {number} max_collateral_inputs
	    */
	    set_max_collateral_inputs(max_collateral_inputs) {
	        wasm.protocolparamupdate_set_max_collateral_inputs(this.ptr, max_collateral_inputs);
	    }
	    /**
	    * @returns {number | undefined}
	    */
	    max_collateral_inputs() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolparamupdate_max_collateral_inputs(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1 >>> 0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @returns {ProtocolParamUpdate}
	    */
	    static new() {
	        var ret = wasm.protocolparamupdate_new();
	        return ProtocolParamUpdate.__wrap(ret);
	    }
	}
	module.exports.ProtocolParamUpdate = ProtocolParamUpdate;
	/**
	*/
	class ProtocolVersion {

	    static __wrap(ptr) {
	        const obj = Object.create(ProtocolVersion.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_protocolversion_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolversion_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ProtocolVersion}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.protocolversion_from_bytes(ptr0, len0);
	        return ProtocolVersion.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    major() {
	        var ret = wasm.protocolversion_major(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {number}
	    */
	    minor() {
	        var ret = wasm.protocolversion_minor(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} major
	    * @param {number} minor
	    * @returns {ProtocolVersion}
	    */
	    static new(major, minor) {
	        var ret = wasm.protocolversion_new(major, minor);
	        return ProtocolVersion.__wrap(ret);
	    }
	}
	module.exports.ProtocolVersion = ProtocolVersion;
	/**
	*/
	class ProtocolVersions {

	    static __wrap(ptr) {
	        const obj = Object.create(ProtocolVersions.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_protocolversions_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.protocolversions_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ProtocolVersions}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.protocolversions_from_bytes(ptr0, len0);
	        return ProtocolVersions.__wrap(ret);
	    }
	    /**
	    * @returns {ProtocolVersions}
	    */
	    static new() {
	        var ret = wasm.protocolversions_new();
	        return ProtocolVersions.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.protocolversions_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {ProtocolVersion}
	    */
	    get(index) {
	        var ret = wasm.protocolversions_get(this.ptr, index);
	        return ProtocolVersion.__wrap(ret);
	    }
	    /**
	    * @param {ProtocolVersion} elem
	    */
	    add(elem) {
	        _assertClass(elem, ProtocolVersion);
	        wasm.protocolversions_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.ProtocolVersions = ProtocolVersions;
	/**
	* ED25519 key used as public key
	*/
	class PublicKey {

	    static __wrap(ptr) {
	        const obj = Object.create(PublicKey.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_publickey_free(ptr);
	    }
	    /**
	    * Get public key from its bech32 representation
	    * Example:
	    * ```javascript
	    * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);
	    * ```
	    * @param {string} bech32_str
	    * @returns {PublicKey}
	    */
	    static from_bech32(bech32_str) {
	        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.publickey_from_bech32(ptr0, len0);
	        return PublicKey.__wrap(ret);
	    }
	    /**
	    * @returns {string}
	    */
	    to_bech32() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.publickey_to_bech32(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    as_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.publickey_as_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {PublicKey}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.publickey_from_bytes(ptr0, len0);
	        return PublicKey.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} data
	    * @param {Ed25519Signature} signature
	    * @returns {boolean}
	    */
	    verify(data, signature) {
	        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        _assertClass(signature, Ed25519Signature);
	        var ret = wasm.publickey_verify(this.ptr, ptr0, len0, signature.ptr);
	        return ret !== 0;
	    }
	    /**
	    * @returns {Ed25519KeyHash}
	    */
	    hash() {
	        var ret = wasm.publickey_hash(this.ptr);
	        return Ed25519KeyHash.__wrap(ret);
	    }
	}
	module.exports.PublicKey = PublicKey;
	/**
	*/
	class PublicKeys {

	    static __wrap(ptr) {
	        const obj = Object.create(PublicKeys.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_publickeys_free(ptr);
	    }
	    /**
	    */
	    constructor() {
	        var ret = wasm.publickeys_new();
	        return PublicKeys.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    size() {
	        var ret = wasm.publickeys_size(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {PublicKey}
	    */
	    get(index) {
	        var ret = wasm.publickeys_get(this.ptr, index);
	        return PublicKey.__wrap(ret);
	    }
	    /**
	    * @param {PublicKey} key
	    */
	    add(key) {
	        _assertClass(key, PublicKey);
	        wasm.publickeys_add(this.ptr, key.ptr);
	    }
	}
	module.exports.PublicKeys = PublicKeys;
	/**
	*/
	class Redeemer {

	    static __wrap(ptr) {
	        const obj = Object.create(Redeemer.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_redeemer_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.redeemer_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Redeemer}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.redeemer_from_bytes(ptr0, len0);
	        return Redeemer.__wrap(ret);
	    }
	    /**
	    * @returns {RedeemerTag}
	    */
	    tag() {
	        var ret = wasm.redeemer_tag(this.ptr);
	        return RedeemerTag.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    index() {
	        var ret = wasm.redeemer_index(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {PlutusData}
	    */
	    data() {
	        var ret = wasm.redeemer_data(this.ptr);
	        return PlutusData.__wrap(ret);
	    }
	    /**
	    * @returns {ExUnits}
	    */
	    ex_units() {
	        var ret = wasm.redeemer_ex_units(this.ptr);
	        return ExUnits.__wrap(ret);
	    }
	    /**
	    * @param {RedeemerTag} tag
	    * @param {BigNum} index
	    * @param {PlutusData} data
	    * @param {ExUnits} ex_units
	    * @returns {Redeemer}
	    */
	    static new(tag, index, data, ex_units) {
	        _assertClass(tag, RedeemerTag);
	        _assertClass(index, BigNum);
	        _assertClass(data, PlutusData);
	        _assertClass(ex_units, ExUnits);
	        var ret = wasm.redeemer_new(tag.ptr, index.ptr, data.ptr, ex_units.ptr);
	        return Redeemer.__wrap(ret);
	    }
	}
	module.exports.Redeemer = Redeemer;
	/**
	*/
	class RedeemerTag {

	    static __wrap(ptr) {
	        const obj = Object.create(RedeemerTag.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_redeemertag_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.redeemertag_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {RedeemerTag}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.redeemertag_from_bytes(ptr0, len0);
	        return RedeemerTag.__wrap(ret);
	    }
	    /**
	    * @returns {RedeemerTag}
	    */
	    static new_spend() {
	        var ret = wasm.redeemertag_new_spend();
	        return RedeemerTag.__wrap(ret);
	    }
	    /**
	    * @returns {RedeemerTag}
	    */
	    static new_mint() {
	        var ret = wasm.redeemertag_new_mint();
	        return RedeemerTag.__wrap(ret);
	    }
	    /**
	    * @returns {RedeemerTag}
	    */
	    static new_cert() {
	        var ret = wasm.redeemertag_new_cert();
	        return RedeemerTag.__wrap(ret);
	    }
	    /**
	    * @returns {RedeemerTag}
	    */
	    static new_reward() {
	        var ret = wasm.redeemertag_new_reward();
	        return RedeemerTag.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    kind() {
	        var ret = wasm.redeemertag_kind(this.ptr);
	        return ret >>> 0;
	    }
	}
	module.exports.RedeemerTag = RedeemerTag;
	/**
	*/
	class Redeemers {

	    static __wrap(ptr) {
	        const obj = Object.create(Redeemers.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_redeemers_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.redeemers_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Redeemers}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.redeemers_from_bytes(ptr0, len0);
	        return Redeemers.__wrap(ret);
	    }
	    /**
	    * @returns {Redeemers}
	    */
	    static new() {
	        var ret = wasm.redeemers_new();
	        return Redeemers.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.redeemers_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {Redeemer}
	    */
	    get(index) {
	        var ret = wasm.redeemers_get(this.ptr, index);
	        return Redeemer.__wrap(ret);
	    }
	    /**
	    * @param {Redeemer} elem
	    */
	    add(elem) {
	        _assertClass(elem, Redeemer);
	        wasm.redeemers_add(this.ptr, elem.ptr);
	    }
	    /**
	    * @returns {ExUnits}
	    */
	    total_ex_units() {
	        var ret = wasm.redeemers_total_ex_units(this.ptr);
	        return ExUnits.__wrap(ret);
	    }
	}
	module.exports.Redeemers = Redeemers;
	/**
	*/
	class Relay {

	    static __wrap(ptr) {
	        const obj = Object.create(Relay.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_relay_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.relay_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Relay}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.relay_from_bytes(ptr0, len0);
	        return Relay.__wrap(ret);
	    }
	    /**
	    * @param {SingleHostAddr} single_host_addr
	    * @returns {Relay}
	    */
	    static new_single_host_addr(single_host_addr) {
	        _assertClass(single_host_addr, SingleHostAddr);
	        var ret = wasm.relay_new_single_host_addr(single_host_addr.ptr);
	        return Relay.__wrap(ret);
	    }
	    /**
	    * @param {SingleHostName} single_host_name
	    * @returns {Relay}
	    */
	    static new_single_host_name(single_host_name) {
	        _assertClass(single_host_name, SingleHostName);
	        var ret = wasm.relay_new_single_host_name(single_host_name.ptr);
	        return Relay.__wrap(ret);
	    }
	    /**
	    * @param {MultiHostName} multi_host_name
	    * @returns {Relay}
	    */
	    static new_multi_host_name(multi_host_name) {
	        _assertClass(multi_host_name, MultiHostName);
	        var ret = wasm.relay_new_multi_host_name(multi_host_name.ptr);
	        return Relay.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    kind() {
	        var ret = wasm.relay_kind(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {SingleHostAddr | undefined}
	    */
	    as_single_host_addr() {
	        var ret = wasm.relay_as_single_host_addr(this.ptr);
	        return ret === 0 ? undefined : SingleHostAddr.__wrap(ret);
	    }
	    /**
	    * @returns {SingleHostName | undefined}
	    */
	    as_single_host_name() {
	        var ret = wasm.relay_as_single_host_name(this.ptr);
	        return ret === 0 ? undefined : SingleHostName.__wrap(ret);
	    }
	    /**
	    * @returns {MultiHostName | undefined}
	    */
	    as_multi_host_name() {
	        var ret = wasm.relay_as_multi_host_name(this.ptr);
	        return ret === 0 ? undefined : MultiHostName.__wrap(ret);
	    }
	}
	module.exports.Relay = Relay;
	/**
	*/
	class Relays {

	    static __wrap(ptr) {
	        const obj = Object.create(Relays.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_relays_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.relays_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Relays}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.relays_from_bytes(ptr0, len0);
	        return Relays.__wrap(ret);
	    }
	    /**
	    * @returns {Relays}
	    */
	    static new() {
	        var ret = wasm.relays_new();
	        return Relays.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.relays_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {Relay}
	    */
	    get(index) {
	        var ret = wasm.relays_get(this.ptr, index);
	        return Relay.__wrap(ret);
	    }
	    /**
	    * @param {Relay} elem
	    */
	    add(elem) {
	        _assertClass(elem, Relay);
	        wasm.relays_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.Relays = Relays;
	/**
	*/
	class RewardAddress {

	    static __wrap(ptr) {
	        const obj = Object.create(RewardAddress.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_rewardaddress_free(ptr);
	    }
	    /**
	    * @param {number} network
	    * @param {StakeCredential} payment
	    * @returns {RewardAddress}
	    */
	    static new(network, payment) {
	        _assertClass(payment, StakeCredential);
	        var ret = wasm.rewardaddress_new(network, payment.ptr);
	        return RewardAddress.__wrap(ret);
	    }
	    /**
	    * @returns {StakeCredential}
	    */
	    payment_cred() {
	        var ret = wasm.rewardaddress_payment_cred(this.ptr);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @returns {Address}
	    */
	    to_address() {
	        var ret = wasm.rewardaddress_to_address(this.ptr);
	        return Address.__wrap(ret);
	    }
	    /**
	    * @param {Address} addr
	    * @returns {RewardAddress | undefined}
	    */
	    static from_address(addr) {
	        _assertClass(addr, Address);
	        var ret = wasm.rewardaddress_from_address(addr.ptr);
	        return ret === 0 ? undefined : RewardAddress.__wrap(ret);
	    }
	}
	module.exports.RewardAddress = RewardAddress;
	/**
	*/
	class RewardAddresses {

	    static __wrap(ptr) {
	        const obj = Object.create(RewardAddresses.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_rewardaddresses_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.rewardaddresses_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {RewardAddresses}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.rewardaddresses_from_bytes(ptr0, len0);
	        return RewardAddresses.__wrap(ret);
	    }
	    /**
	    * @returns {RewardAddresses}
	    */
	    static new() {
	        var ret = wasm.rewardaddresses_new();
	        return RewardAddresses.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.rewardaddresses_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {RewardAddress}
	    */
	    get(index) {
	        var ret = wasm.rewardaddresses_get(this.ptr, index);
	        return RewardAddress.__wrap(ret);
	    }
	    /**
	    * @param {RewardAddress} elem
	    */
	    add(elem) {
	        _assertClass(elem, RewardAddress);
	        wasm.rewardaddresses_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.RewardAddresses = RewardAddresses;
	/**
	*/
	class ScriptAll {

	    static __wrap(ptr) {
	        const obj = Object.create(ScriptAll.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_scriptall_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.scriptall_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ScriptAll}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.scriptall_from_bytes(ptr0, len0);
	        return ScriptAll.__wrap(ret);
	    }
	    /**
	    * @returns {NativeScripts}
	    */
	    native_scripts() {
	        var ret = wasm.scriptall_native_scripts(this.ptr);
	        return NativeScripts.__wrap(ret);
	    }
	    /**
	    * @param {NativeScripts} native_scripts
	    * @returns {ScriptAll}
	    */
	    static new(native_scripts) {
	        _assertClass(native_scripts, NativeScripts);
	        var ret = wasm.scriptall_new(native_scripts.ptr);
	        return ScriptAll.__wrap(ret);
	    }
	}
	module.exports.ScriptAll = ScriptAll;
	/**
	*/
	class ScriptAny {

	    static __wrap(ptr) {
	        const obj = Object.create(ScriptAny.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_scriptany_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.scriptany_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ScriptAny}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.scriptany_from_bytes(ptr0, len0);
	        return ScriptAny.__wrap(ret);
	    }
	    /**
	    * @returns {NativeScripts}
	    */
	    native_scripts() {
	        var ret = wasm.scriptany_native_scripts(this.ptr);
	        return NativeScripts.__wrap(ret);
	    }
	    /**
	    * @param {NativeScripts} native_scripts
	    * @returns {ScriptAny}
	    */
	    static new(native_scripts) {
	        _assertClass(native_scripts, NativeScripts);
	        var ret = wasm.scriptany_new(native_scripts.ptr);
	        return ScriptAny.__wrap(ret);
	    }
	}
	module.exports.ScriptAny = ScriptAny;
	/**
	*/
	class ScriptDataHash {

	    static __wrap(ptr) {
	        const obj = Object.create(ScriptDataHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_scriptdatahash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.scriptdatahash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.scriptdatahash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {ScriptDataHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.scriptdatahash_from_bech32(ptr0, len0);
	        return ScriptDataHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ScriptDataHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.scriptdatahash_from_bytes(ptr0, len0);
	        return ScriptDataHash.__wrap(ret);
	    }
	}
	module.exports.ScriptDataHash = ScriptDataHash;
	/**
	*/
	class ScriptHash {

	    static __wrap(ptr) {
	        const obj = Object.create(ScriptHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_scripthash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.scripthash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.scripthash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {ScriptHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.scripthash_from_bech32(ptr0, len0);
	        return ScriptHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ScriptHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.scripthash_from_bytes(ptr0, len0);
	        return ScriptHash.__wrap(ret);
	    }
	}
	module.exports.ScriptHash = ScriptHash;
	/**
	*/
	class ScriptHashes {

	    static __wrap(ptr) {
	        const obj = Object.create(ScriptHashes.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_scripthashes_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.scripthashes_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ScriptHashes}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.scripthashes_from_bytes(ptr0, len0);
	        return ScriptHashes.__wrap(ret);
	    }
	    /**
	    * @returns {ScriptHashes}
	    */
	    static new() {
	        var ret = wasm.scripthashes_new();
	        return ScriptHashes.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.scripthashes_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {ScriptHash}
	    */
	    get(index) {
	        var ret = wasm.scripthashes_get(this.ptr, index);
	        return ScriptHash.__wrap(ret);
	    }
	    /**
	    * @param {ScriptHash} elem
	    */
	    add(elem) {
	        _assertClass(elem, ScriptHash);
	        wasm.scripthashes_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.ScriptHashes = ScriptHashes;
	/**
	*/
	class ScriptNOfK {

	    static __wrap(ptr) {
	        const obj = Object.create(ScriptNOfK.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_scriptnofk_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.scriptnofk_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ScriptNOfK}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.scriptnofk_from_bytes(ptr0, len0);
	        return ScriptNOfK.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    n() {
	        var ret = wasm.scriptnofk_n(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {NativeScripts}
	    */
	    native_scripts() {
	        var ret = wasm.scriptnofk_native_scripts(this.ptr);
	        return NativeScripts.__wrap(ret);
	    }
	    /**
	    * @param {number} n
	    * @param {NativeScripts} native_scripts
	    * @returns {ScriptNOfK}
	    */
	    static new(n, native_scripts) {
	        _assertClass(native_scripts, NativeScripts);
	        var ret = wasm.scriptnofk_new(n, native_scripts.ptr);
	        return ScriptNOfK.__wrap(ret);
	    }
	}
	module.exports.ScriptNOfK = ScriptNOfK;
	/**
	*/
	class ScriptPubkey {

	    static __wrap(ptr) {
	        const obj = Object.create(ScriptPubkey.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_scriptpubkey_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.scriptpubkey_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {ScriptPubkey}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.scriptpubkey_from_bytes(ptr0, len0);
	        return ScriptPubkey.__wrap(ret);
	    }
	    /**
	    * @returns {Ed25519KeyHash}
	    */
	    addr_keyhash() {
	        var ret = wasm.scriptpubkey_addr_keyhash(this.ptr);
	        return Ed25519KeyHash.__wrap(ret);
	    }
	    /**
	    * @param {Ed25519KeyHash} addr_keyhash
	    * @returns {ScriptPubkey}
	    */
	    static new(addr_keyhash) {
	        _assertClass(addr_keyhash, Ed25519KeyHash);
	        var ret = wasm.scriptpubkey_new(addr_keyhash.ptr);
	        return ScriptPubkey.__wrap(ret);
	    }
	}
	module.exports.ScriptPubkey = ScriptPubkey;
	/**
	*/
	class SingleHostAddr {

	    static __wrap(ptr) {
	        const obj = Object.create(SingleHostAddr.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_singlehostaddr_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.singlehostaddr_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {SingleHostAddr}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.singlehostaddr_from_bytes(ptr0, len0);
	        return SingleHostAddr.__wrap(ret);
	    }
	    /**
	    * @returns {number | undefined}
	    */
	    port() {
	        var ret = wasm.singlehostaddr_port(this.ptr);
	        return ret === 0xFFFFFF ? undefined : ret;
	    }
	    /**
	    * @returns {Ipv4 | undefined}
	    */
	    ipv4() {
	        var ret = wasm.singlehostaddr_ipv4(this.ptr);
	        return ret === 0 ? undefined : Ipv4.__wrap(ret);
	    }
	    /**
	    * @returns {Ipv6 | undefined}
	    */
	    ipv6() {
	        var ret = wasm.singlehostaddr_ipv6(this.ptr);
	        return ret === 0 ? undefined : Ipv6.__wrap(ret);
	    }
	    /**
	    * @param {number | undefined} port
	    * @param {Ipv4 | undefined} ipv4
	    * @param {Ipv6 | undefined} ipv6
	    * @returns {SingleHostAddr}
	    */
	    static new(port, ipv4, ipv6) {
	        let ptr0 = 0;
	        if (!isLikeNone(ipv4)) {
	            _assertClass(ipv4, Ipv4);
	            ptr0 = ipv4.ptr;
	            ipv4.ptr = 0;
	        }
	        let ptr1 = 0;
	        if (!isLikeNone(ipv6)) {
	            _assertClass(ipv6, Ipv6);
	            ptr1 = ipv6.ptr;
	            ipv6.ptr = 0;
	        }
	        var ret = wasm.singlehostaddr_new(isLikeNone(port) ? 0xFFFFFF : port, ptr0, ptr1);
	        return SingleHostAddr.__wrap(ret);
	    }
	}
	module.exports.SingleHostAddr = SingleHostAddr;
	/**
	*/
	class SingleHostName {

	    static __wrap(ptr) {
	        const obj = Object.create(SingleHostName.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_singlehostname_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.singlehostname_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {SingleHostName}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.singlehostname_from_bytes(ptr0, len0);
	        return SingleHostName.__wrap(ret);
	    }
	    /**
	    * @returns {number | undefined}
	    */
	    port() {
	        var ret = wasm.singlehostname_port(this.ptr);
	        return ret === 0xFFFFFF ? undefined : ret;
	    }
	    /**
	    * @returns {DNSRecordAorAAAA}
	    */
	    dns_name() {
	        var ret = wasm.singlehostname_dns_name(this.ptr);
	        return DNSRecordAorAAAA.__wrap(ret);
	    }
	    /**
	    * @param {number | undefined} port
	    * @param {DNSRecordAorAAAA} dns_name
	    * @returns {SingleHostName}
	    */
	    static new(port, dns_name) {
	        _assertClass(dns_name, DNSRecordAorAAAA);
	        var ret = wasm.singlehostname_new(isLikeNone(port) ? 0xFFFFFF : port, dns_name.ptr);
	        return SingleHostName.__wrap(ret);
	    }
	}
	module.exports.SingleHostName = SingleHostName;
	/**
	*/
	class StakeCredential {

	    static __wrap(ptr) {
	        const obj = Object.create(StakeCredential.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_stakecredential_free(ptr);
	    }
	    /**
	    * @param {Ed25519KeyHash} hash
	    * @returns {StakeCredential}
	    */
	    static from_keyhash(hash) {
	        _assertClass(hash, Ed25519KeyHash);
	        var ret = wasm.stakecredential_from_keyhash(hash.ptr);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @param {ScriptHash} hash
	    * @returns {StakeCredential}
	    */
	    static from_scripthash(hash) {
	        _assertClass(hash, ScriptHash);
	        var ret = wasm.stakecredential_from_scripthash(hash.ptr);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @returns {Ed25519KeyHash | undefined}
	    */
	    to_keyhash() {
	        var ret = wasm.stakecredential_to_keyhash(this.ptr);
	        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
	    }
	    /**
	    * @returns {ScriptHash | undefined}
	    */
	    to_scripthash() {
	        var ret = wasm.stakecredential_to_scripthash(this.ptr);
	        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    kind() {
	        var ret = wasm.stakecredential_kind(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.stakecredential_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {StakeCredential}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.stakecredential_from_bytes(ptr0, len0);
	        return StakeCredential.__wrap(ret);
	    }
	}
	module.exports.StakeCredential = StakeCredential;
	/**
	*/
	class StakeCredentials {

	    static __wrap(ptr) {
	        const obj = Object.create(StakeCredentials.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_stakecredentials_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.stakecredentials_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {StakeCredentials}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.stakecredentials_from_bytes(ptr0, len0);
	        return StakeCredentials.__wrap(ret);
	    }
	    /**
	    * @returns {StakeCredentials}
	    */
	    static new() {
	        var ret = wasm.stakecredentials_new();
	        return StakeCredentials.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.stakecredentials_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {StakeCredential}
	    */
	    get(index) {
	        var ret = wasm.stakecredentials_get(this.ptr, index);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @param {StakeCredential} elem
	    */
	    add(elem) {
	        _assertClass(elem, StakeCredential);
	        wasm.stakecredentials_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.StakeCredentials = StakeCredentials;
	/**
	*/
	class StakeDelegation {

	    static __wrap(ptr) {
	        const obj = Object.create(StakeDelegation.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_stakedelegation_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.stakedelegation_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {StakeDelegation}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.stakedelegation_from_bytes(ptr0, len0);
	        return StakeDelegation.__wrap(ret);
	    }
	    /**
	    * @returns {StakeCredential}
	    */
	    stake_credential() {
	        var ret = wasm.stakedelegation_stake_credential(this.ptr);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @returns {Ed25519KeyHash}
	    */
	    pool_keyhash() {
	        var ret = wasm.stakedelegation_pool_keyhash(this.ptr);
	        return Ed25519KeyHash.__wrap(ret);
	    }
	    /**
	    * @param {StakeCredential} stake_credential
	    * @param {Ed25519KeyHash} pool_keyhash
	    * @returns {StakeDelegation}
	    */
	    static new(stake_credential, pool_keyhash) {
	        _assertClass(stake_credential, StakeCredential);
	        _assertClass(pool_keyhash, Ed25519KeyHash);
	        var ret = wasm.stakedelegation_new(stake_credential.ptr, pool_keyhash.ptr);
	        return StakeDelegation.__wrap(ret);
	    }
	}
	module.exports.StakeDelegation = StakeDelegation;
	/**
	*/
	class StakeDeregistration {

	    static __wrap(ptr) {
	        const obj = Object.create(StakeDeregistration.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_stakederegistration_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.stakederegistration_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {StakeDeregistration}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.stakederegistration_from_bytes(ptr0, len0);
	        return StakeDeregistration.__wrap(ret);
	    }
	    /**
	    * @returns {StakeCredential}
	    */
	    stake_credential() {
	        var ret = wasm.stakederegistration_stake_credential(this.ptr);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @param {StakeCredential} stake_credential
	    * @returns {StakeDeregistration}
	    */
	    static new(stake_credential) {
	        _assertClass(stake_credential, StakeCredential);
	        var ret = wasm.stakederegistration_new(stake_credential.ptr);
	        return StakeDeregistration.__wrap(ret);
	    }
	}
	module.exports.StakeDeregistration = StakeDeregistration;
	/**
	*/
	class StakeRegistration {

	    static __wrap(ptr) {
	        const obj = Object.create(StakeRegistration.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_stakeregistration_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.stakeregistration_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {StakeRegistration}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.stakeregistration_from_bytes(ptr0, len0);
	        return StakeRegistration.__wrap(ret);
	    }
	    /**
	    * @returns {StakeCredential}
	    */
	    stake_credential() {
	        var ret = wasm.stakeregistration_stake_credential(this.ptr);
	        return StakeCredential.__wrap(ret);
	    }
	    /**
	    * @param {StakeCredential} stake_credential
	    * @returns {StakeRegistration}
	    */
	    static new(stake_credential) {
	        _assertClass(stake_credential, StakeCredential);
	        var ret = wasm.stakeregistration_new(stake_credential.ptr);
	        return StakeRegistration.__wrap(ret);
	    }
	}
	module.exports.StakeRegistration = StakeRegistration;
	/**
	*/
	class Strings {

	    static __wrap(ptr) {
	        const obj = Object.create(Strings.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_strings_free(ptr);
	    }
	    /**
	    * @returns {Strings}
	    */
	    static new() {
	        var ret = wasm.strings_new();
	        return Strings.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.strings_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {string}
	    */
	    get(index) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.strings_get(retptr, this.ptr, index);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} elem
	    */
	    add(elem) {
	        var ptr0 = passStringToWasm0(elem, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        wasm.strings_add(this.ptr, ptr0, len0);
	    }
	}
	module.exports.Strings = Strings;
	/**
	*/
	class TimelockExpiry {

	    static __wrap(ptr) {
	        const obj = Object.create(TimelockExpiry.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_timelockexpiry_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.timelockexpiry_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TimelockExpiry}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.timelockexpiry_from_bytes(ptr0, len0);
	        return TimelockExpiry.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    slot() {
	        var ret = wasm.timelockexpiry_slot(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {BigNum}
	    */
	    slot_bignum() {
	        var ret = wasm.timelockexpiry_slot_bignum(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * This constructor uses outdated slot number format.
	    * Use `.new_timelockexpiry` instead
	    * @param {number} slot
	    * @returns {TimelockExpiry}
	    */
	    static new(slot) {
	        var ret = wasm.timelockexpiry_new(slot);
	        return TimelockExpiry.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} slot
	    * @returns {TimelockExpiry}
	    */
	    static new_timelockexpiry(slot) {
	        _assertClass(slot, BigNum);
	        var ret = wasm.timelockexpiry_new_timelockexpiry(slot.ptr);
	        return TimelockExpiry.__wrap(ret);
	    }
	}
	module.exports.TimelockExpiry = TimelockExpiry;
	/**
	*/
	class TimelockStart {

	    static __wrap(ptr) {
	        const obj = Object.create(TimelockStart.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_timelockstart_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.timelockstart_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TimelockStart}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.timelockstart_from_bytes(ptr0, len0);
	        return TimelockStart.__wrap(ret);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.
	    * Otherwise will just raise an error.
	    * Use `.slot_bignum` instead
	    * @returns {number}
	    */
	    slot() {
	        var ret = wasm.timelockstart_slot(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {BigNum}
	    */
	    slot_bignum() {
	        var ret = wasm.timelockstart_slot_bignum(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * This constructor uses outdated slot number format.
	    * Use `.new_timelockstart` instead.
	    * @param {number} slot
	    * @returns {TimelockStart}
	    */
	    static new(slot) {
	        var ret = wasm.timelockstart_new(slot);
	        return TimelockStart.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} slot
	    * @returns {TimelockStart}
	    */
	    static new_timelockstart(slot) {
	        _assertClass(slot, BigNum);
	        var ret = wasm.timelockstart_new_timelockstart(slot.ptr);
	        return TimelockStart.__wrap(ret);
	    }
	}
	module.exports.TimelockStart = TimelockStart;
	/**
	*/
	class Transaction {

	    static __wrap(ptr) {
	        const obj = Object.create(Transaction.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transaction_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transaction_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Transaction}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transaction_from_bytes(ptr0, len0);
	        return Transaction.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionBody}
	    */
	    body() {
	        var ret = wasm.transaction_body(this.ptr);
	        return TransactionBody.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionWitnessSet}
	    */
	    witness_set() {
	        var ret = wasm.transaction_witness_set(this.ptr);
	        return TransactionWitnessSet.__wrap(ret);
	    }
	    /**
	    * @returns {boolean}
	    */
	    is_valid() {
	        var ret = wasm.transaction_is_valid(this.ptr);
	        return ret !== 0;
	    }
	    /**
	    * @returns {AuxiliaryData | undefined}
	    */
	    auxiliary_data() {
	        var ret = wasm.transaction_auxiliary_data(this.ptr);
	        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
	    }
	    /**
	    * @param {boolean} valid
	    */
	    set_is_valid(valid) {
	        wasm.transaction_set_is_valid(this.ptr, valid);
	    }
	    /**
	    * @param {TransactionBody} body
	    * @param {TransactionWitnessSet} witness_set
	    * @param {AuxiliaryData | undefined} auxiliary_data
	    * @returns {Transaction}
	    */
	    static new(body, witness_set, auxiliary_data) {
	        _assertClass(body, TransactionBody);
	        _assertClass(witness_set, TransactionWitnessSet);
	        let ptr0 = 0;
	        if (!isLikeNone(auxiliary_data)) {
	            _assertClass(auxiliary_data, AuxiliaryData);
	            ptr0 = auxiliary_data.ptr;
	            auxiliary_data.ptr = 0;
	        }
	        var ret = wasm.transaction_new(body.ptr, witness_set.ptr, ptr0);
	        return Transaction.__wrap(ret);
	    }
	}
	module.exports.Transaction = Transaction;
	/**
	*/
	class TransactionBodies {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionBodies.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionbodies_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionbodies_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionBodies}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionbodies_from_bytes(ptr0, len0);
	        return TransactionBodies.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionBodies}
	    */
	    static new() {
	        var ret = wasm.transactionbodies_new();
	        return TransactionBodies.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.transactionbodies_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {TransactionBody}
	    */
	    get(index) {
	        var ret = wasm.transactionbodies_get(this.ptr, index);
	        return TransactionBody.__wrap(ret);
	    }
	    /**
	    * @param {TransactionBody} elem
	    */
	    add(elem) {
	        _assertClass(elem, TransactionBody);
	        wasm.transactionbodies_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.TransactionBodies = TransactionBodies;
	/**
	*/
	class TransactionBody {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionBody.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionbody_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionbody_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionBody}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionbody_from_bytes(ptr0, len0);
	        return TransactionBody.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionInputs}
	    */
	    inputs() {
	        var ret = wasm.transactionbody_inputs(this.ptr);
	        return TransactionInputs.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionOutputs}
	    */
	    outputs() {
	        var ret = wasm.transactionbody_outputs(this.ptr);
	        return TransactionOutputs.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    fee() {
	        var ret = wasm.transactionbody_fee(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.
	    * Otherwise will just raise an error.
	    * @returns {number | undefined}
	    */
	    ttl() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionbody_ttl(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1 >>> 0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    ttl_bignum() {
	        var ret = wasm.transactionbody_ttl_bignum(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} ttl
	    */
	    set_ttl(ttl) {
	        _assertClass(ttl, BigNum);
	        wasm.transactionbody_set_ttl(this.ptr, ttl.ptr);
	    }
	    /**
	    */
	    remove_ttl() {
	        wasm.transactionbody_remove_ttl(this.ptr);
	    }
	    /**
	    * @param {Certificates} certs
	    */
	    set_certs(certs) {
	        _assertClass(certs, Certificates);
	        wasm.transactionbody_set_certs(this.ptr, certs.ptr);
	    }
	    /**
	    * @returns {Certificates | undefined}
	    */
	    certs() {
	        var ret = wasm.transactionbody_certs(this.ptr);
	        return ret === 0 ? undefined : Certificates.__wrap(ret);
	    }
	    /**
	    * @param {Withdrawals} withdrawals
	    */
	    set_withdrawals(withdrawals) {
	        _assertClass(withdrawals, Withdrawals);
	        wasm.transactionbody_set_withdrawals(this.ptr, withdrawals.ptr);
	    }
	    /**
	    * @returns {Withdrawals | undefined}
	    */
	    withdrawals() {
	        var ret = wasm.transactionbody_withdrawals(this.ptr);
	        return ret === 0 ? undefined : Withdrawals.__wrap(ret);
	    }
	    /**
	    * @param {Update} update
	    */
	    set_update(update) {
	        _assertClass(update, Update);
	        wasm.transactionbody_set_update(this.ptr, update.ptr);
	    }
	    /**
	    * @returns {Update | undefined}
	    */
	    update() {
	        var ret = wasm.transactionbody_update(this.ptr);
	        return ret === 0 ? undefined : Update.__wrap(ret);
	    }
	    /**
	    * @param {AuxiliaryDataHash} auxiliary_data_hash
	    */
	    set_auxiliary_data_hash(auxiliary_data_hash) {
	        _assertClass(auxiliary_data_hash, AuxiliaryDataHash);
	        wasm.transactionbody_set_auxiliary_data_hash(this.ptr, auxiliary_data_hash.ptr);
	    }
	    /**
	    * @returns {AuxiliaryDataHash | undefined}
	    */
	    auxiliary_data_hash() {
	        var ret = wasm.transactionbody_auxiliary_data_hash(this.ptr);
	        return ret === 0 ? undefined : AuxiliaryDataHash.__wrap(ret);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * Uses outdated slot number format.
	    * @param {number} validity_start_interval
	    */
	    set_validity_start_interval(validity_start_interval) {
	        wasm.transactionbody_set_validity_start_interval(this.ptr, validity_start_interval);
	    }
	    /**
	    * @param {BigNum} validity_start_interval
	    */
	    set_validity_start_interval_bignum(validity_start_interval) {
	        _assertClass(validity_start_interval, BigNum);
	        var ptr0 = validity_start_interval.ptr;
	        validity_start_interval.ptr = 0;
	        wasm.transactionbody_set_validity_start_interval_bignum(this.ptr, ptr0);
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    validity_start_interval_bignum() {
	        var ret = wasm.transactionbody_validity_start_interval_bignum(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * Returns a Option<Slot32> (u32) value in case the underlying original Option<BigNum> (u64) value is within the limits.
	    * Otherwise will just raise an error.
	    * Use `.validity_start_interval_bignum` instead.
	    * @returns {number | undefined}
	    */
	    validity_start_interval() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionbody_validity_start_interval(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return r0 === 0 ? undefined : r1 >>> 0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Mint} mint
	    */
	    set_mint(mint) {
	        _assertClass(mint, Mint);
	        wasm.transactionbody_set_mint(this.ptr, mint.ptr);
	    }
	    /**
	    * @returns {Mint | undefined}
	    */
	    mint() {
	        var ret = wasm.transactionbody_mint(this.ptr);
	        return ret === 0 ? undefined : Mint.__wrap(ret);
	    }
	    /**
	    * This function returns the mint value of the transaction
	    * Use `.mint()` instead.
	    * @returns {Mint | undefined}
	    */
	    multiassets() {
	        var ret = wasm.transactionbody_multiassets(this.ptr);
	        return ret === 0 ? undefined : Mint.__wrap(ret);
	    }
	    /**
	    * @param {ScriptDataHash} script_data_hash
	    */
	    set_script_data_hash(script_data_hash) {
	        _assertClass(script_data_hash, ScriptDataHash);
	        wasm.transactionbody_set_script_data_hash(this.ptr, script_data_hash.ptr);
	    }
	    /**
	    * @returns {ScriptDataHash | undefined}
	    */
	    script_data_hash() {
	        var ret = wasm.transactionbody_script_data_hash(this.ptr);
	        return ret === 0 ? undefined : ScriptDataHash.__wrap(ret);
	    }
	    /**
	    * @param {TransactionInputs} collateral
	    */
	    set_collateral(collateral) {
	        _assertClass(collateral, TransactionInputs);
	        wasm.transactionbody_set_collateral(this.ptr, collateral.ptr);
	    }
	    /**
	    * @returns {TransactionInputs | undefined}
	    */
	    collateral() {
	        var ret = wasm.transactionbody_collateral(this.ptr);
	        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);
	    }
	    /**
	    * @param {Ed25519KeyHashes} required_signers
	    */
	    set_required_signers(required_signers) {
	        _assertClass(required_signers, Ed25519KeyHashes);
	        wasm.transactionbody_set_required_signers(this.ptr, required_signers.ptr);
	    }
	    /**
	    * @returns {Ed25519KeyHashes | undefined}
	    */
	    required_signers() {
	        var ret = wasm.transactionbody_required_signers(this.ptr);
	        return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);
	    }
	    /**
	    * @param {NetworkId} network_id
	    */
	    set_network_id(network_id) {
	        _assertClass(network_id, NetworkId);
	        wasm.transactionbody_set_network_id(this.ptr, network_id.ptr);
	    }
	    /**
	    * @returns {NetworkId | undefined}
	    */
	    network_id() {
	        var ret = wasm.transactionbody_network_id(this.ptr);
	        return ret === 0 ? undefined : NetworkId.__wrap(ret);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * This constructor uses outdated slot number format for the ttl value.
	    * Use `.new_tx_body` and then `.set_ttl` instead
	    * @param {TransactionInputs} inputs
	    * @param {TransactionOutputs} outputs
	    * @param {BigNum} fee
	    * @param {number | undefined} ttl
	    * @returns {TransactionBody}
	    */
	    static new(inputs, outputs, fee, ttl) {
	        _assertClass(inputs, TransactionInputs);
	        _assertClass(outputs, TransactionOutputs);
	        _assertClass(fee, BigNum);
	        var ret = wasm.transactionbody_new(inputs.ptr, outputs.ptr, fee.ptr, !isLikeNone(ttl), isLikeNone(ttl) ? 0 : ttl);
	        return TransactionBody.__wrap(ret);
	    }
	    /**
	    * Returns a new TransactionBody.
	    * In the new version of "new" we removed optional ttl for support it by wasm_bingen.
	    * Your can use "set_ttl" and "remove_ttl" to set a new value for ttl or set it as None.
	    * @param {TransactionInputs} inputs
	    * @param {TransactionOutputs} outputs
	    * @param {BigNum} fee
	    * @returns {TransactionBody}
	    */
	    static new_tx_body(inputs, outputs, fee) {
	        _assertClass(inputs, TransactionInputs);
	        _assertClass(outputs, TransactionOutputs);
	        _assertClass(fee, BigNum);
	        var ret = wasm.transactionbody_new_tx_body(inputs.ptr, outputs.ptr, fee.ptr);
	        return TransactionBody.__wrap(ret);
	    }
	}
	module.exports.TransactionBody = TransactionBody;
	/**
	*/
	class TransactionBuilder {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionBuilder.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionbuilder_free(ptr);
	    }
	    /**
	    * This automatically selects and adds inputs from {inputs} consisting of just enough to cover
	    * the outputs that have already been added.
	    * This should be called after adding all certs/outputs/etc and will be an error otherwise.
	    * Uses CIP2: https://github.com/cardano-foundation/CIPs/blob/master/CIP-0002/CIP-0002.md
	    * Adding a change output must be called after via TransactionBuilder::add_change_if_needed()
	    * This function, diverging from CIP2, takes into account fees and will attempt to add additional
	    * inputs to cover the minimum fees. This does not, however, set the txbuilder's fee.
	    * @param {TransactionUnspentOutputs} inputs
	    * @param {number} strategy
	    */
	    add_inputs_from(inputs, strategy) {
	        _assertClass(inputs, TransactionUnspentOutputs);
	        wasm.transactionbuilder_add_inputs_from(this.ptr, inputs.ptr, strategy);
	    }
	    /**
	    * @param {TxInputsBuilder} inputs
	    */
	    set_inputs(inputs) {
	        _assertClass(inputs, TxInputsBuilder);
	        wasm.transactionbuilder_set_inputs(this.ptr, inputs.ptr);
	    }
	    /**
	    * @param {TxInputsBuilder} collateral
	    */
	    set_collateral(collateral) {
	        _assertClass(collateral, TxInputsBuilder);
	        wasm.transactionbuilder_set_collateral(this.ptr, collateral.ptr);
	    }
	    /**
	    * We have to know what kind of inputs these are to know what kind of mock witnesses to create since
	    * 1) mock witnesses have different lengths depending on the type which changes the expecting fee
	    * 2) Witnesses are a set so we need to get rid of duplicates to avoid over-estimating the fee
	    * @param {Ed25519KeyHash} hash
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_key_input(hash, input, amount) {
	        _assertClass(hash, Ed25519KeyHash);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.transactionbuilder_add_key_input(this.ptr, hash.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * This method adds the input to the builder BUT leaves a missing spot for the witness native script
	    *
	    * After adding the input with this method, use `.add_required_native_input_scripts`
	    * and `.add_required_plutus_input_scripts` to add the witness scripts
	    *
	    * Or instead use `.add_native_script_input` and `.add_plutus_script_input`
	    * to add inputs right along with the script, instead of the script hash
	    * @param {ScriptHash} hash
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_script_input(hash, input, amount) {
	        _assertClass(hash, ScriptHash);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.transactionbuilder_add_script_input(this.ptr, hash.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * This method will add the input to the builder and also register the required native script witness
	    * @param {NativeScript} script
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_native_script_input(script, input, amount) {
	        _assertClass(script, NativeScript);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.transactionbuilder_add_native_script_input(this.ptr, script.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * This method will add the input to the builder and also register the required plutus witness
	    * @param {PlutusWitness} witness
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_plutus_script_input(witness, input, amount) {
	        _assertClass(witness, PlutusWitness);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.transactionbuilder_add_plutus_script_input(this.ptr, witness.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * @param {ByronAddress} hash
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_bootstrap_input(hash, input, amount) {
	        _assertClass(hash, ByronAddress);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.transactionbuilder_add_bootstrap_input(this.ptr, hash.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * Note that for script inputs this method will use underlying generic `.add_script_input`
	    * which leaves a required empty spot for the script witness (or witnesses in case of Plutus).
	    * You can use `.add_native_script_input` or `.add_plutus_script_input` directly to register the input along with the witness.
	    * @param {Address} address
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_input(address, input, amount) {
	        _assertClass(address, Address);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.transactionbuilder_add_input(this.ptr, address.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * Returns the number of still missing input scripts (either native or plutus)
	    * Use `.add_required_native_input_scripts` or `.add_required_plutus_input_scripts` to add the missing scripts
	    * @returns {number}
	    */
	    count_missing_input_scripts() {
	        var ret = wasm.transactionbuilder_count_missing_input_scripts(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs
	    * Any scripts that don't match any of the previously added inputs will be ignored
	    * Returns the number of remaining required missing witness scripts
	    * Use `.count_missing_input_scripts` to find the number of still missing scripts
	    * @param {NativeScripts} scripts
	    * @returns {number}
	    */
	    add_required_native_input_scripts(scripts) {
	        _assertClass(scripts, NativeScripts);
	        var ret = wasm.transactionbuilder_add_required_native_input_scripts(this.ptr, scripts.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs
	    * Any scripts that don't match any of the previously added inputs will be ignored
	    * Returns the number of remaining required missing witness scripts
	    * Use `.count_missing_input_scripts` to find the number of still missing scripts
	    * @param {PlutusWitnesses} scripts
	    * @returns {number}
	    */
	    add_required_plutus_input_scripts(scripts) {
	        _assertClass(scripts, PlutusWitnesses);
	        var ret = wasm.transactionbuilder_add_required_plutus_input_scripts(this.ptr, scripts.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * Returns a copy of the current script input witness scripts in the builder
	    * @returns {NativeScripts | undefined}
	    */
	    get_native_input_scripts() {
	        var ret = wasm.transactionbuilder_get_native_input_scripts(this.ptr);
	        return ret === 0 ? undefined : NativeScripts.__wrap(ret);
	    }
	    /**
	    * Returns a copy of the current plutus input witness scripts in the builder.
	    * NOTE: each plutus witness will be cloned with a specific corresponding input index
	    * @returns {PlutusWitnesses | undefined}
	    */
	    get_plutus_input_scripts() {
	        var ret = wasm.transactionbuilder_get_plutus_input_scripts(this.ptr);
	        return ret === 0 ? undefined : PlutusWitnesses.__wrap(ret);
	    }
	    /**
	    * calculates how much the fee would increase if you added a given output
	    * @param {Address} address
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    * @returns {BigNum}
	    */
	    fee_for_input(address, input, amount) {
	        _assertClass(address, Address);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        var ret = wasm.transactionbuilder_fee_for_input(this.ptr, address.ptr, input.ptr, amount.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * Add explicit output via a TransactionOutput object
	    * @param {TransactionOutput} output
	    */
	    add_output(output) {
	        _assertClass(output, TransactionOutput);
	        wasm.transactionbuilder_add_output(this.ptr, output.ptr);
	    }
	    /**
	    * calculates how much the fee would increase if you added a given output
	    * @param {TransactionOutput} output
	    * @returns {BigNum}
	    */
	    fee_for_output(output) {
	        _assertClass(output, TransactionOutput);
	        var ret = wasm.transactionbuilder_fee_for_output(this.ptr, output.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} fee
	    */
	    set_fee(fee) {
	        _assertClass(fee, BigNum);
	        wasm.transactionbuilder_set_fee(this.ptr, fee.ptr);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * Set ttl value.
	    * @param {number} ttl
	    */
	    set_ttl(ttl) {
	        wasm.transactionbuilder_set_ttl(this.ptr, ttl);
	    }
	    /**
	    * @param {BigNum} ttl
	    */
	    set_ttl_bignum(ttl) {
	        _assertClass(ttl, BigNum);
	        wasm.transactionbuilder_set_ttl_bignum(this.ptr, ttl.ptr);
	    }
	    /**
	    * !!! DEPRECATED !!!
	    * Uses outdated slot number format.
	    * @param {number} validity_start_interval
	    */
	    set_validity_start_interval(validity_start_interval) {
	        wasm.transactionbuilder_set_validity_start_interval(this.ptr, validity_start_interval);
	    }
	    /**
	    * @param {BigNum} validity_start_interval
	    */
	    set_validity_start_interval_bignum(validity_start_interval) {
	        _assertClass(validity_start_interval, BigNum);
	        var ptr0 = validity_start_interval.ptr;
	        validity_start_interval.ptr = 0;
	        wasm.transactionbuilder_set_validity_start_interval_bignum(this.ptr, ptr0);
	    }
	    /**
	    * @param {Certificates} certs
	    */
	    set_certs(certs) {
	        _assertClass(certs, Certificates);
	        wasm.transactionbuilder_set_certs(this.ptr, certs.ptr);
	    }
	    /**
	    * @param {Withdrawals} withdrawals
	    */
	    set_withdrawals(withdrawals) {
	        _assertClass(withdrawals, Withdrawals);
	        wasm.transactionbuilder_set_withdrawals(this.ptr, withdrawals.ptr);
	    }
	    /**
	    * @returns {AuxiliaryData | undefined}
	    */
	    get_auxiliary_data() {
	        var ret = wasm.transactionbuilder_get_auxiliary_data(this.ptr);
	        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
	    }
	    /**
	    * Set explicit auxiliary data via an AuxiliaryData object
	    * It might contain some metadata plus native or Plutus scripts
	    * @param {AuxiliaryData} auxiliary_data
	    */
	    set_auxiliary_data(auxiliary_data) {
	        _assertClass(auxiliary_data, AuxiliaryData);
	        wasm.transactionbuilder_set_auxiliary_data(this.ptr, auxiliary_data.ptr);
	    }
	    /**
	    * Set metadata using a GeneralTransactionMetadata object
	    * It will be set to the existing or new auxiliary data in this builder
	    * @param {GeneralTransactionMetadata} metadata
	    */
	    set_metadata(metadata) {
	        _assertClass(metadata, GeneralTransactionMetadata);
	        wasm.transactionbuilder_set_metadata(this.ptr, metadata.ptr);
	    }
	    /**
	    * Add a single metadatum using TransactionMetadatumLabel and TransactionMetadatum objects
	    * It will be securely added to existing or new metadata in this builder
	    * @param {BigNum} key
	    * @param {TransactionMetadatum} val
	    */
	    add_metadatum(key, val) {
	        _assertClass(key, BigNum);
	        _assertClass(val, TransactionMetadatum);
	        wasm.transactionbuilder_add_metadatum(this.ptr, key.ptr, val.ptr);
	    }
	    /**
	    * Add a single JSON metadatum using a TransactionMetadatumLabel and a String
	    * It will be securely added to existing or new metadata in this builder
	    * @param {BigNum} key
	    * @param {string} val
	    */
	    add_json_metadatum(key, val) {
	        _assertClass(key, BigNum);
	        var ptr0 = passStringToWasm0(val, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        wasm.transactionbuilder_add_json_metadatum(this.ptr, key.ptr, ptr0, len0);
	    }
	    /**
	    * Add a single JSON metadatum using a TransactionMetadatumLabel, a String, and a MetadataJsonSchema object
	    * It will be securely added to existing or new metadata in this builder
	    * @param {BigNum} key
	    * @param {string} val
	    * @param {number} schema
	    */
	    add_json_metadatum_with_schema(key, val, schema) {
	        _assertClass(key, BigNum);
	        var ptr0 = passStringToWasm0(val, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        wasm.transactionbuilder_add_json_metadatum_with_schema(this.ptr, key.ptr, ptr0, len0, schema);
	    }
	    /**
	    * Set explicit Mint object and the required witnesses to this builder
	    * it will replace any previously existing mint and mint scripts
	    * NOTE! Error will be returned in case a mint policy does not have a matching script
	    * @param {Mint} mint
	    * @param {NativeScripts} mint_scripts
	    */
	    set_mint(mint, mint_scripts) {
	        _assertClass(mint, Mint);
	        _assertClass(mint_scripts, NativeScripts);
	        wasm.transactionbuilder_set_mint(this.ptr, mint.ptr, mint_scripts.ptr);
	    }
	    /**
	    * Returns a copy of the current mint state in the builder
	    * @returns {Mint | undefined}
	    */
	    get_mint() {
	        var ret = wasm.transactionbuilder_get_mint(this.ptr);
	        return ret === 0 ? undefined : Mint.__wrap(ret);
	    }
	    /**
	    * Returns a copy of the current mint witness scripts in the builder
	    * @returns {NativeScripts | undefined}
	    */
	    get_mint_scripts() {
	        var ret = wasm.transactionbuilder_get_mint_scripts(this.ptr);
	        return ret === 0 ? undefined : NativeScripts.__wrap(ret);
	    }
	    /**
	    * Add a mint entry to this builder using a PolicyID and MintAssets object
	    * It will be securely added to existing or new Mint in this builder
	    * It will replace any existing mint assets with the same PolicyID
	    * @param {NativeScript} policy_script
	    * @param {MintAssets} mint_assets
	    */
	    set_mint_asset(policy_script, mint_assets) {
	        _assertClass(policy_script, NativeScript);
	        _assertClass(mint_assets, MintAssets);
	        wasm.transactionbuilder_set_mint_asset(this.ptr, policy_script.ptr, mint_assets.ptr);
	    }
	    /**
	    * Add a mint entry to this builder using a PolicyID, AssetName, and Int object for amount
	    * It will be securely added to existing or new Mint in this builder
	    * It will replace any previous existing amount same PolicyID and AssetName
	    * @param {NativeScript} policy_script
	    * @param {AssetName} asset_name
	    * @param {Int} amount
	    */
	    add_mint_asset(policy_script, asset_name, amount) {
	        _assertClass(policy_script, NativeScript);
	        _assertClass(asset_name, AssetName);
	        _assertClass(amount, Int);
	        var ptr0 = amount.ptr;
	        amount.ptr = 0;
	        wasm.transactionbuilder_add_mint_asset(this.ptr, policy_script.ptr, asset_name.ptr, ptr0);
	    }
	    /**
	    * Add a mint entry together with an output to this builder
	    * Using a PolicyID, AssetName, Int for amount, Address, and Coin (BigNum) objects
	    * The asset will be securely added to existing or new Mint in this builder
	    * A new output will be added with the specified Address, the Coin value, and the minted asset
	    * @param {NativeScript} policy_script
	    * @param {AssetName} asset_name
	    * @param {Int} amount
	    * @param {TransactionOutputAmountBuilder} output_builder
	    * @param {BigNum} output_coin
	    */
	    add_mint_asset_and_output(policy_script, asset_name, amount, output_builder, output_coin) {
	        _assertClass(policy_script, NativeScript);
	        _assertClass(asset_name, AssetName);
	        _assertClass(amount, Int);
	        var ptr0 = amount.ptr;
	        amount.ptr = 0;
	        _assertClass(output_builder, TransactionOutputAmountBuilder);
	        _assertClass(output_coin, BigNum);
	        wasm.transactionbuilder_add_mint_asset_and_output(this.ptr, policy_script.ptr, asset_name.ptr, ptr0, output_builder.ptr, output_coin.ptr);
	    }
	    /**
	    * Add a mint entry together with an output to this builder
	    * Using a PolicyID, AssetName, Int for amount, and Address objects
	    * The asset will be securely added to existing or new Mint in this builder
	    * A new output will be added with the specified Address and the minted asset
	    * The output will be set to contain the minimum required amount of Coin
	    * @param {NativeScript} policy_script
	    * @param {AssetName} asset_name
	    * @param {Int} amount
	    * @param {TransactionOutputAmountBuilder} output_builder
	    */
	    add_mint_asset_and_output_min_required_coin(policy_script, asset_name, amount, output_builder) {
	        _assertClass(policy_script, NativeScript);
	        _assertClass(asset_name, AssetName);
	        _assertClass(amount, Int);
	        var ptr0 = amount.ptr;
	        amount.ptr = 0;
	        _assertClass(output_builder, TransactionOutputAmountBuilder);
	        wasm.transactionbuilder_add_mint_asset_and_output_min_required_coin(this.ptr, policy_script.ptr, asset_name.ptr, ptr0, output_builder.ptr);
	    }
	    /**
	    * @param {TransactionBuilderConfig} cfg
	    * @returns {TransactionBuilder}
	    */
	    static new(cfg) {
	        _assertClass(cfg, TransactionBuilderConfig);
	        var ret = wasm.transactionbuilder_new(cfg.ptr);
	        return TransactionBuilder.__wrap(ret);
	    }
	    /**
	    * does not include refunds or withdrawals
	    * @returns {Value}
	    */
	    get_explicit_input() {
	        var ret = wasm.transactionbuilder_get_explicit_input(this.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * withdrawals and refunds
	    * @returns {Value}
	    */
	    get_implicit_input() {
	        var ret = wasm.transactionbuilder_get_implicit_input(this.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * Return explicit input plus implicit input plus mint
	    * @returns {Value}
	    */
	    get_total_input() {
	        var ret = wasm.transactionbuilder_get_total_input(this.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * Return explicit output plus deposit plus burn
	    * @returns {Value}
	    */
	    get_total_output() {
	        var ret = wasm.transactionbuilder_get_total_output(this.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * does not include fee
	    * @returns {Value}
	    */
	    get_explicit_output() {
	        var ret = wasm.transactionbuilder_get_explicit_output(this.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    get_deposit() {
	        var ret = wasm.transactionbuilder_get_deposit(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum | undefined}
	    */
	    get_fee_if_set() {
	        var ret = wasm.transactionbuilder_get_fee_if_set(this.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * Warning: this function will mutate the /fee/ field
	    * Make sure to call this function last after setting all other tx-body properties
	    * Editing inputs, outputs, mint, etc. after change been calculated
	    * might cause a mismatch in calculated fee versus the required fee
	    * @param {Address} address
	    * @returns {boolean}
	    */
	    add_change_if_needed(address) {
	        _assertClass(address, Address);
	        var ret = wasm.transactionbuilder_add_change_if_needed(this.ptr, address.ptr);
	        return ret !== 0;
	    }
	    /**
	    * This method will calculate the script hash data
	    * using the plutus datums and redeemers already present in the builder
	    * along with the provided cost model, and will register the calculated value
	    * in the builder to be used when building the tx body.
	    * In case there are no plutus input witnesses present - nothing will change
	    * You can set specific hash value using `.set_script_data_hash`
	    * @param {Costmdls} cost_models
	    */
	    calc_script_data_hash(cost_models) {
	        _assertClass(cost_models, Costmdls);
	        wasm.transactionbuilder_calc_script_data_hash(this.ptr, cost_models.ptr);
	    }
	    /**
	    * Sets the specified hash value.
	    * Alternatively you can use `.calc_script_data_hash` to calculate the hash automatically.
	    * Or use `.remove_script_data_hash` to delete the previously set value
	    * @param {ScriptDataHash} hash
	    */
	    set_script_data_hash(hash) {
	        _assertClass(hash, ScriptDataHash);
	        wasm.transactionbuilder_set_script_data_hash(this.ptr, hash.ptr);
	    }
	    /**
	    * Deletes any previously set plutus data hash value.
	    * Use `.set_script_data_hash` or `.calc_script_data_hash` to set it.
	    */
	    remove_script_data_hash() {
	        wasm.transactionbuilder_remove_script_data_hash(this.ptr);
	    }
	    /**
	    * @param {Ed25519KeyHash} key
	    */
	    add_required_signer(key) {
	        _assertClass(key, Ed25519KeyHash);
	        wasm.transactionbuilder_add_required_signer(this.ptr, key.ptr);
	    }
	    /**
	    * @returns {number}
	    */
	    full_size() {
	        var ret = wasm.transactionbuilder_full_size(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {Uint32Array}
	    */
	    output_sizes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionbuilder_output_sizes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU32FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 4);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * Returns object the body of the new transaction
	    * Auxiliary data itself is not included
	    * You can use `get_auxiliary_data` or `build_tx`
	    * @returns {TransactionBody}
	    */
	    build() {
	        var ret = wasm.transactionbuilder_build(this.ptr);
	        return TransactionBody.__wrap(ret);
	    }
	    /**
	    * Returns full Transaction object with the body and the auxiliary data
	    * NOTE: witness_set will contain all mint_scripts if any been added or set
	    * NOTE: is_valid set to true
	    * NOTE: Will fail in case there are any script inputs added with no corresponding witness
	    * @returns {Transaction}
	    */
	    build_tx() {
	        var ret = wasm.transactionbuilder_build_tx(this.ptr);
	        return Transaction.__wrap(ret);
	    }
	    /**
	    * Similar to `.build_tx()` but will NOT fail in case there are missing script witnesses
	    * @returns {Transaction}
	    */
	    build_tx_unsafe() {
	        var ret = wasm.transactionbuilder_build_tx_unsafe(this.ptr);
	        return Transaction.__wrap(ret);
	    }
	    /**
	    * warning: sum of all parts of a transaction must equal 0. You cannot just set the fee to the min value and forget about it
	    * warning: min_fee may be slightly larger than the actual minimum fee (ex: a few lovelaces)
	    * this is done to simplify the library code, but can be fixed later
	    * @returns {BigNum}
	    */
	    min_fee() {
	        var ret = wasm.transactionbuilder_min_fee(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	}
	module.exports.TransactionBuilder = TransactionBuilder;
	/**
	*/
	class TransactionBuilderConfig {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionBuilderConfig.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionbuilderconfig_free(ptr);
	    }
	}
	module.exports.TransactionBuilderConfig = TransactionBuilderConfig;
	/**
	*/
	class TransactionBuilderConfigBuilder {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionBuilderConfigBuilder.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionbuilderconfigbuilder_free(ptr);
	    }
	    /**
	    * @returns {TransactionBuilderConfigBuilder}
	    */
	    static new() {
	        var ret = wasm.transactionbuilderconfigbuilder_new();
	        return TransactionBuilderConfigBuilder.__wrap(ret);
	    }
	    /**
	    * @param {LinearFee} fee_algo
	    * @returns {TransactionBuilderConfigBuilder}
	    */
	    fee_algo(fee_algo) {
	        _assertClass(fee_algo, LinearFee);
	        var ret = wasm.transactionbuilderconfigbuilder_fee_algo(this.ptr, fee_algo.ptr);
	        return TransactionBuilderConfigBuilder.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} coins_per_utxo_word
	    * @returns {TransactionBuilderConfigBuilder}
	    */
	    coins_per_utxo_word(coins_per_utxo_word) {
	        _assertClass(coins_per_utxo_word, BigNum);
	        var ret = wasm.transactionbuilderconfigbuilder_coins_per_utxo_word(this.ptr, coins_per_utxo_word.ptr);
	        return TransactionBuilderConfigBuilder.__wrap(ret);
	    }
	    /**
	    * @param {ExUnitPrices} ex_unit_prices
	    * @returns {TransactionBuilderConfigBuilder}
	    */
	    ex_unit_prices(ex_unit_prices) {
	        _assertClass(ex_unit_prices, ExUnitPrices);
	        var ret = wasm.transactionbuilderconfigbuilder_ex_unit_prices(this.ptr, ex_unit_prices.ptr);
	        return TransactionBuilderConfigBuilder.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} pool_deposit
	    * @returns {TransactionBuilderConfigBuilder}
	    */
	    pool_deposit(pool_deposit) {
	        _assertClass(pool_deposit, BigNum);
	        var ret = wasm.transactionbuilderconfigbuilder_pool_deposit(this.ptr, pool_deposit.ptr);
	        return TransactionBuilderConfigBuilder.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} key_deposit
	    * @returns {TransactionBuilderConfigBuilder}
	    */
	    key_deposit(key_deposit) {
	        _assertClass(key_deposit, BigNum);
	        var ret = wasm.transactionbuilderconfigbuilder_key_deposit(this.ptr, key_deposit.ptr);
	        return TransactionBuilderConfigBuilder.__wrap(ret);
	    }
	    /**
	    * @param {number} max_value_size
	    * @returns {TransactionBuilderConfigBuilder}
	    */
	    max_value_size(max_value_size) {
	        var ret = wasm.transactionbuilderconfigbuilder_max_value_size(this.ptr, max_value_size);
	        return TransactionBuilderConfigBuilder.__wrap(ret);
	    }
	    /**
	    * @param {number} max_tx_size
	    * @returns {TransactionBuilderConfigBuilder}
	    */
	    max_tx_size(max_tx_size) {
	        var ret = wasm.transactionbuilderconfigbuilder_max_tx_size(this.ptr, max_tx_size);
	        return TransactionBuilderConfigBuilder.__wrap(ret);
	    }
	    /**
	    * @param {boolean} prefer_pure_change
	    * @returns {TransactionBuilderConfigBuilder}
	    */
	    prefer_pure_change(prefer_pure_change) {
	        var ret = wasm.transactionbuilderconfigbuilder_prefer_pure_change(this.ptr, prefer_pure_change);
	        return TransactionBuilderConfigBuilder.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionBuilderConfig}
	    */
	    build() {
	        var ret = wasm.transactionbuilderconfigbuilder_build(this.ptr);
	        return TransactionBuilderConfig.__wrap(ret);
	    }
	}
	module.exports.TransactionBuilderConfigBuilder = TransactionBuilderConfigBuilder;
	/**
	*/
	class TransactionHash {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionhash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionhash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.transactionhash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {TransactionHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionhash_from_bech32(ptr0, len0);
	        return TransactionHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionhash_from_bytes(ptr0, len0);
	        return TransactionHash.__wrap(ret);
	    }
	}
	module.exports.TransactionHash = TransactionHash;
	/**
	*/
	class TransactionInput {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionInput.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactioninput_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactioninput_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionInput}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactioninput_from_bytes(ptr0, len0);
	        return TransactionInput.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionHash}
	    */
	    transaction_id() {
	        var ret = wasm.transactioninput_transaction_id(this.ptr);
	        return TransactionHash.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    index() {
	        var ret = wasm.transactioninput_index(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {TransactionHash} transaction_id
	    * @param {number} index
	    * @returns {TransactionInput}
	    */
	    static new(transaction_id, index) {
	        _assertClass(transaction_id, TransactionHash);
	        var ret = wasm.transactioninput_new(transaction_id.ptr, index);
	        return TransactionInput.__wrap(ret);
	    }
	}
	module.exports.TransactionInput = TransactionInput;
	/**
	*/
	class TransactionInputs {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionInputs.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactioninputs_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactioninputs_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionInputs}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactioninputs_from_bytes(ptr0, len0);
	        return TransactionInputs.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionInputs}
	    */
	    static new() {
	        var ret = wasm.transactioninputs_new();
	        return TransactionInputs.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.transactioninputs_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {TransactionInput}
	    */
	    get(index) {
	        var ret = wasm.transactioninputs_get(this.ptr, index);
	        return TransactionInput.__wrap(ret);
	    }
	    /**
	    * @param {TransactionInput} elem
	    */
	    add(elem) {
	        _assertClass(elem, TransactionInput);
	        wasm.transactioninputs_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.TransactionInputs = TransactionInputs;
	/**
	*/
	class TransactionMetadatum {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionMetadatum.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionmetadatum_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionmetadatum_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionMetadatum}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionmetadatum_from_bytes(ptr0, len0);
	        return TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {MetadataMap} map
	    * @returns {TransactionMetadatum}
	    */
	    static new_map(map) {
	        _assertClass(map, MetadataMap);
	        var ret = wasm.transactionmetadatum_new_map(map.ptr);
	        return TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {MetadataList} list
	    * @returns {TransactionMetadatum}
	    */
	    static new_list(list) {
	        _assertClass(list, MetadataList);
	        var ret = wasm.transactionmetadatum_new_list(list.ptr);
	        return TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {Int} int
	    * @returns {TransactionMetadatum}
	    */
	    static new_int(int) {
	        _assertClass(int, Int);
	        var ret = wasm.transactionmetadatum_new_int(int.ptr);
	        return TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionMetadatum}
	    */
	    static new_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionmetadatum_new_bytes(ptr0, len0);
	        return TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @param {string} text
	    * @returns {TransactionMetadatum}
	    */
	    static new_text(text) {
	        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionmetadatum_new_text(ptr0, len0);
	        return TransactionMetadatum.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    kind() {
	        var ret = wasm.transactionmetadatum_kind(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @returns {MetadataMap}
	    */
	    as_map() {
	        var ret = wasm.transactionmetadatum_as_map(this.ptr);
	        return MetadataMap.__wrap(ret);
	    }
	    /**
	    * @returns {MetadataList}
	    */
	    as_list() {
	        var ret = wasm.transactionmetadatum_as_list(this.ptr);
	        return MetadataList.__wrap(ret);
	    }
	    /**
	    * @returns {Int}
	    */
	    as_int() {
	        var ret = wasm.transactionmetadatum_as_int(this.ptr);
	        return Int.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    as_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionmetadatum_as_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @returns {string}
	    */
	    as_text() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionmetadatum_as_text(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	}
	module.exports.TransactionMetadatum = TransactionMetadatum;
	/**
	*/
	class TransactionMetadatumLabels {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionMetadatumLabels.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionmetadatumlabels_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionmetadatumlabels_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionMetadatumLabels}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionmetadatumlabels_from_bytes(ptr0, len0);
	        return TransactionMetadatumLabels.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionMetadatumLabels}
	    */
	    static new() {
	        var ret = wasm.transactionmetadatumlabels_new();
	        return TransactionMetadatumLabels.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.transactionmetadatumlabels_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {BigNum}
	    */
	    get(index) {
	        var ret = wasm.transactionmetadatumlabels_get(this.ptr, index);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} elem
	    */
	    add(elem) {
	        _assertClass(elem, BigNum);
	        wasm.transactionmetadatumlabels_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.TransactionMetadatumLabels = TransactionMetadatumLabels;
	/**
	*/
	class TransactionOutput {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionOutput.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionoutput_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionoutput_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionOutput}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionoutput_from_bytes(ptr0, len0);
	        return TransactionOutput.__wrap(ret);
	    }
	    /**
	    * @returns {Address}
	    */
	    address() {
	        var ret = wasm.transactionoutput_address(this.ptr);
	        return Address.__wrap(ret);
	    }
	    /**
	    * @returns {Value}
	    */
	    amount() {
	        var ret = wasm.transactionoutput_amount(this.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * @returns {DataHash | undefined}
	    */
	    data_hash() {
	        var ret = wasm.transactionoutput_data_hash(this.ptr);
	        return ret === 0 ? undefined : DataHash.__wrap(ret);
	    }
	    /**
	    * @param {DataHash} data_hash
	    */
	    set_data_hash(data_hash) {
	        _assertClass(data_hash, DataHash);
	        wasm.transactionoutput_set_data_hash(this.ptr, data_hash.ptr);
	    }
	    /**
	    * @param {Address} address
	    * @param {Value} amount
	    * @returns {TransactionOutput}
	    */
	    static new(address, amount) {
	        _assertClass(address, Address);
	        _assertClass(amount, Value);
	        var ret = wasm.transactionoutput_new(address.ptr, amount.ptr);
	        return TransactionOutput.__wrap(ret);
	    }
	}
	module.exports.TransactionOutput = TransactionOutput;
	/**
	*/
	class TransactionOutputAmountBuilder {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionOutputAmountBuilder.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionoutputamountbuilder_free(ptr);
	    }
	    /**
	    * @param {Value} amount
	    * @returns {TransactionOutputAmountBuilder}
	    */
	    with_value(amount) {
	        _assertClass(amount, Value);
	        var ret = wasm.transactionoutputamountbuilder_with_value(this.ptr, amount.ptr);
	        return TransactionOutputAmountBuilder.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} coin
	    * @returns {TransactionOutputAmountBuilder}
	    */
	    with_coin(coin) {
	        _assertClass(coin, BigNum);
	        var ret = wasm.transactionoutputamountbuilder_with_coin(this.ptr, coin.ptr);
	        return TransactionOutputAmountBuilder.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} coin
	    * @param {MultiAsset} multiasset
	    * @returns {TransactionOutputAmountBuilder}
	    */
	    with_coin_and_asset(coin, multiasset) {
	        _assertClass(coin, BigNum);
	        _assertClass(multiasset, MultiAsset);
	        var ret = wasm.transactionoutputamountbuilder_with_coin_and_asset(this.ptr, coin.ptr, multiasset.ptr);
	        return TransactionOutputAmountBuilder.__wrap(ret);
	    }
	    /**
	    * @param {MultiAsset} multiasset
	    * @param {BigNum} coins_per_utxo_word
	    * @returns {TransactionOutputAmountBuilder}
	    */
	    with_asset_and_min_required_coin(multiasset, coins_per_utxo_word) {
	        _assertClass(multiasset, MultiAsset);
	        _assertClass(coins_per_utxo_word, BigNum);
	        var ret = wasm.transactionoutputamountbuilder_with_asset_and_min_required_coin(this.ptr, multiasset.ptr, coins_per_utxo_word.ptr);
	        return TransactionOutputAmountBuilder.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionOutput}
	    */
	    build() {
	        var ret = wasm.transactionoutputamountbuilder_build(this.ptr);
	        return TransactionOutput.__wrap(ret);
	    }
	}
	module.exports.TransactionOutputAmountBuilder = TransactionOutputAmountBuilder;
	/**
	* We introduce a builder-pattern format for creating transaction outputs
	* This is because:
	* 1. Some fields (i.e. data hash) are optional, and we can't easily expose Option<> in WASM
	* 2. Some fields like amounts have many ways it could be set (some depending on other field values being known)
	* 3. Easier to adapt as the output format gets more complicated in future Cardano releases
	*/
	class TransactionOutputBuilder {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionOutputBuilder.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionoutputbuilder_free(ptr);
	    }
	    /**
	    * @returns {TransactionOutputBuilder}
	    */
	    static new() {
	        var ret = wasm.transactionoutputbuilder_new();
	        return TransactionOutputBuilder.__wrap(ret);
	    }
	    /**
	    * @param {Address} address
	    * @returns {TransactionOutputBuilder}
	    */
	    with_address(address) {
	        _assertClass(address, Address);
	        var ret = wasm.transactionoutputbuilder_with_address(this.ptr, address.ptr);
	        return TransactionOutputBuilder.__wrap(ret);
	    }
	    /**
	    * @param {DataHash} data_hash
	    * @returns {TransactionOutputBuilder}
	    */
	    with_data_hash(data_hash) {
	        _assertClass(data_hash, DataHash);
	        var ret = wasm.transactionoutputbuilder_with_data_hash(this.ptr, data_hash.ptr);
	        return TransactionOutputBuilder.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionOutputAmountBuilder}
	    */
	    next() {
	        var ret = wasm.transactionoutputbuilder_next(this.ptr);
	        return TransactionOutputAmountBuilder.__wrap(ret);
	    }
	}
	module.exports.TransactionOutputBuilder = TransactionOutputBuilder;
	/**
	*/
	class TransactionOutputs {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionOutputs.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionoutputs_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionoutputs_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionOutputs}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionoutputs_from_bytes(ptr0, len0);
	        return TransactionOutputs.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionOutputs}
	    */
	    static new() {
	        var ret = wasm.transactionoutputs_new();
	        return TransactionOutputs.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.transactionoutputs_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {TransactionOutput}
	    */
	    get(index) {
	        var ret = wasm.transactionoutputs_get(this.ptr, index);
	        return TransactionOutput.__wrap(ret);
	    }
	    /**
	    * @param {TransactionOutput} elem
	    */
	    add(elem) {
	        _assertClass(elem, TransactionOutput);
	        wasm.transactionoutputs_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.TransactionOutputs = TransactionOutputs;
	/**
	*/
	class TransactionUnspentOutput {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionUnspentOutput.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionunspentoutput_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionunspentoutput_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionUnspentOutput}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionunspentoutput_from_bytes(ptr0, len0);
	        return TransactionUnspentOutput.__wrap(ret);
	    }
	    /**
	    * @param {TransactionInput} input
	    * @param {TransactionOutput} output
	    * @returns {TransactionUnspentOutput}
	    */
	    static new(input, output) {
	        _assertClass(input, TransactionInput);
	        _assertClass(output, TransactionOutput);
	        var ret = wasm.transactionunspentoutput_new(input.ptr, output.ptr);
	        return TransactionUnspentOutput.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionInput}
	    */
	    input() {
	        var ret = wasm.transactionunspentoutput_input(this.ptr);
	        return TransactionInput.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionOutput}
	    */
	    output() {
	        var ret = wasm.transactionunspentoutput_output(this.ptr);
	        return TransactionOutput.__wrap(ret);
	    }
	}
	module.exports.TransactionUnspentOutput = TransactionUnspentOutput;
	/**
	*/
	class TransactionUnspentOutputs {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionUnspentOutputs.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionunspentoutputs_free(ptr);
	    }
	    /**
	    * @returns {TransactionUnspentOutputs}
	    */
	    static new() {
	        var ret = wasm.transactionunspentoutputs_new();
	        return TransactionUnspentOutputs.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.transactionunspentoutputs_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {TransactionUnspentOutput}
	    */
	    get(index) {
	        var ret = wasm.transactionunspentoutputs_get(this.ptr, index);
	        return TransactionUnspentOutput.__wrap(ret);
	    }
	    /**
	    * @param {TransactionUnspentOutput} elem
	    */
	    add(elem) {
	        _assertClass(elem, TransactionUnspentOutput);
	        wasm.transactionunspentoutputs_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.TransactionUnspentOutputs = TransactionUnspentOutputs;
	/**
	*/
	class TransactionWitnessSet {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionWitnessSet.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionwitnessset_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionwitnessset_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionWitnessSet}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionwitnessset_from_bytes(ptr0, len0);
	        return TransactionWitnessSet.__wrap(ret);
	    }
	    /**
	    * @param {Vkeywitnesses} vkeys
	    */
	    set_vkeys(vkeys) {
	        _assertClass(vkeys, Vkeywitnesses);
	        wasm.transactionwitnessset_set_vkeys(this.ptr, vkeys.ptr);
	    }
	    /**
	    * @returns {Vkeywitnesses | undefined}
	    */
	    vkeys() {
	        var ret = wasm.transactionwitnessset_vkeys(this.ptr);
	        return ret === 0 ? undefined : Vkeywitnesses.__wrap(ret);
	    }
	    /**
	    * @param {NativeScripts} native_scripts
	    */
	    set_native_scripts(native_scripts) {
	        _assertClass(native_scripts, NativeScripts);
	        wasm.transactionwitnessset_set_native_scripts(this.ptr, native_scripts.ptr);
	    }
	    /**
	    * @returns {NativeScripts | undefined}
	    */
	    native_scripts() {
	        var ret = wasm.transactionwitnessset_native_scripts(this.ptr);
	        return ret === 0 ? undefined : NativeScripts.__wrap(ret);
	    }
	    /**
	    * @param {BootstrapWitnesses} bootstraps
	    */
	    set_bootstraps(bootstraps) {
	        _assertClass(bootstraps, BootstrapWitnesses);
	        wasm.transactionwitnessset_set_bootstraps(this.ptr, bootstraps.ptr);
	    }
	    /**
	    * @returns {BootstrapWitnesses | undefined}
	    */
	    bootstraps() {
	        var ret = wasm.transactionwitnessset_bootstraps(this.ptr);
	        return ret === 0 ? undefined : BootstrapWitnesses.__wrap(ret);
	    }
	    /**
	    * @param {PlutusScripts} plutus_scripts
	    */
	    set_plutus_scripts(plutus_scripts) {
	        _assertClass(plutus_scripts, PlutusScripts);
	        wasm.transactionwitnessset_set_plutus_scripts(this.ptr, plutus_scripts.ptr);
	    }
	    /**
	    * @returns {PlutusScripts | undefined}
	    */
	    plutus_scripts() {
	        var ret = wasm.transactionwitnessset_plutus_scripts(this.ptr);
	        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);
	    }
	    /**
	    * @param {PlutusList} plutus_data
	    */
	    set_plutus_data(plutus_data) {
	        _assertClass(plutus_data, PlutusList);
	        wasm.transactionwitnessset_set_plutus_data(this.ptr, plutus_data.ptr);
	    }
	    /**
	    * @returns {PlutusList | undefined}
	    */
	    plutus_data() {
	        var ret = wasm.transactionwitnessset_plutus_data(this.ptr);
	        return ret === 0 ? undefined : PlutusList.__wrap(ret);
	    }
	    /**
	    * @param {Redeemers} redeemers
	    */
	    set_redeemers(redeemers) {
	        _assertClass(redeemers, Redeemers);
	        wasm.transactionwitnessset_set_redeemers(this.ptr, redeemers.ptr);
	    }
	    /**
	    * @returns {Redeemers | undefined}
	    */
	    redeemers() {
	        var ret = wasm.transactionwitnessset_redeemers(this.ptr);
	        return ret === 0 ? undefined : Redeemers.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionWitnessSet}
	    */
	    static new() {
	        var ret = wasm.transactionwitnessset_new();
	        return TransactionWitnessSet.__wrap(ret);
	    }
	}
	module.exports.TransactionWitnessSet = TransactionWitnessSet;
	/**
	*/
	class TransactionWitnessSets {

	    static __wrap(ptr) {
	        const obj = Object.create(TransactionWitnessSets.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_transactionwitnesssets_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.transactionwitnesssets_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {TransactionWitnessSets}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.transactionwitnesssets_from_bytes(ptr0, len0);
	        return TransactionWitnessSets.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionWitnessSets}
	    */
	    static new() {
	        var ret = wasm.transactionwitnesssets_new();
	        return TransactionWitnessSets.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.transactionwitnesssets_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {TransactionWitnessSet}
	    */
	    get(index) {
	        var ret = wasm.transactionwitnesssets_get(this.ptr, index);
	        return TransactionWitnessSet.__wrap(ret);
	    }
	    /**
	    * @param {TransactionWitnessSet} elem
	    */
	    add(elem) {
	        _assertClass(elem, TransactionWitnessSet);
	        wasm.transactionwitnesssets_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.TransactionWitnessSets = TransactionWitnessSets;
	/**
	*/
	class TxBuilderConstants {

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_txbuilderconstants_free(ptr);
	    }
	    /**
	    * @returns {Costmdls}
	    */
	    static plutus_default_cost_models() {
	        var ret = wasm.txbuilderconstants_plutus_default_cost_models();
	        return Costmdls.__wrap(ret);
	    }
	}
	module.exports.TxBuilderConstants = TxBuilderConstants;
	/**
	*/
	class TxInputsBuilder {

	    static __wrap(ptr) {
	        const obj = Object.create(TxInputsBuilder.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_txinputsbuilder_free(ptr);
	    }
	    /**
	    * @returns {TxInputsBuilder}
	    */
	    static new() {
	        var ret = wasm.txinputsbuilder_new();
	        return TxInputsBuilder.__wrap(ret);
	    }
	    /**
	    * We have to know what kind of inputs these are to know what kind of mock witnesses to create since
	    * 1) mock witnesses have different lengths depending on the type which changes the expecting fee
	    * 2) Witnesses are a set so we need to get rid of duplicates to avoid over-estimating the fee
	    * @param {Ed25519KeyHash} hash
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_key_input(hash, input, amount) {
	        _assertClass(hash, Ed25519KeyHash);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.txinputsbuilder_add_key_input(this.ptr, hash.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * This method adds the input to the builder BUT leaves a missing spot for the witness native script
	    *
	    * After adding the input with this method, use `.add_required_native_input_scripts`
	    * and `.add_required_plutus_input_scripts` to add the witness scripts
	    *
	    * Or instead use `.add_native_script_input` and `.add_plutus_script_input`
	    * to add inputs right along with the script, instead of the script hash
	    * @param {ScriptHash} hash
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_script_input(hash, input, amount) {
	        _assertClass(hash, ScriptHash);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.txinputsbuilder_add_script_input(this.ptr, hash.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * This method will add the input to the builder and also register the required native script witness
	    * @param {NativeScript} script
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_native_script_input(script, input, amount) {
	        _assertClass(script, NativeScript);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.txinputsbuilder_add_native_script_input(this.ptr, script.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * This method will add the input to the builder and also register the required plutus witness
	    * @param {PlutusWitness} witness
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_plutus_script_input(witness, input, amount) {
	        _assertClass(witness, PlutusWitness);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.txinputsbuilder_add_plutus_script_input(this.ptr, witness.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * @param {ByronAddress} hash
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_bootstrap_input(hash, input, amount) {
	        _assertClass(hash, ByronAddress);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.txinputsbuilder_add_bootstrap_input(this.ptr, hash.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * Note that for script inputs this method will use underlying generic `.add_script_input`
	    * which leaves a required empty spot for the script witness (or witnesses in case of Plutus).
	    * You can use `.add_native_script_input` or `.add_plutus_script_input` directly to register the input along with the witness.
	    * @param {Address} address
	    * @param {TransactionInput} input
	    * @param {Value} amount
	    */
	    add_input(address, input, amount) {
	        _assertClass(address, Address);
	        _assertClass(input, TransactionInput);
	        _assertClass(amount, Value);
	        wasm.txinputsbuilder_add_input(this.ptr, address.ptr, input.ptr, amount.ptr);
	    }
	    /**
	    * Returns the number of still missing input scripts (either native or plutus)
	    * Use `.add_required_native_input_scripts` or `.add_required_plutus_input_scripts` to add the missing scripts
	    * @returns {number}
	    */
	    count_missing_input_scripts() {
	        var ret = wasm.txinputsbuilder_count_missing_input_scripts(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs
	    * Any scripts that don't match any of the previously added inputs will be ignored
	    * Returns the number of remaining required missing witness scripts
	    * Use `.count_missing_input_scripts` to find the number of still missing scripts
	    * @param {NativeScripts} scripts
	    * @returns {number}
	    */
	    add_required_native_input_scripts(scripts) {
	        _assertClass(scripts, NativeScripts);
	        var ret = wasm.txinputsbuilder_add_required_native_input_scripts(this.ptr, scripts.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs
	    * Any scripts that don't match any of the previously added inputs will be ignored
	    * Returns the number of remaining required missing witness scripts
	    * Use `.count_missing_input_scripts` to find the number of still missing scripts
	    * @param {PlutusWitnesses} scripts
	    * @returns {number}
	    */
	    add_required_plutus_input_scripts(scripts) {
	        _assertClass(scripts, PlutusWitnesses);
	        var ret = wasm.txinputsbuilder_add_required_plutus_input_scripts(this.ptr, scripts.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * Returns a copy of the current script input witness scripts in the builder
	    * @returns {NativeScripts | undefined}
	    */
	    get_native_input_scripts() {
	        var ret = wasm.txinputsbuilder_get_native_input_scripts(this.ptr);
	        return ret === 0 ? undefined : NativeScripts.__wrap(ret);
	    }
	    /**
	    * Returns a copy of the current plutus input witness scripts in the builder.
	    * NOTE: each plutus witness will be cloned with a specific corresponding input index
	    * @returns {PlutusWitnesses | undefined}
	    */
	    get_plutus_input_scripts() {
	        var ret = wasm.txinputsbuilder_get_plutus_input_scripts(this.ptr);
	        return ret === 0 ? undefined : PlutusWitnesses.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.txinputsbuilder_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {Ed25519KeyHash} key
	    */
	    add_required_signer(key) {
	        _assertClass(key, Ed25519KeyHash);
	        wasm.txinputsbuilder_add_required_signer(this.ptr, key.ptr);
	    }
	    /**
	    * @param {Ed25519KeyHashes} keys
	    */
	    add_required_signers(keys) {
	        _assertClass(keys, Ed25519KeyHashes);
	        wasm.txinputsbuilder_add_required_signers(this.ptr, keys.ptr);
	    }
	    /**
	    * @returns {TransactionInputs}
	    */
	    inputs() {
	        var ret = wasm.txinputsbuilder_inputs(this.ptr);
	        return TransactionInputs.__wrap(ret);
	    }
	    /**
	    * @returns {TransactionInputs | undefined}
	    */
	    inputs_option() {
	        var ret = wasm.txinputsbuilder_inputs_option(this.ptr);
	        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);
	    }
	}
	module.exports.TxInputsBuilder = TxInputsBuilder;
	/**
	*/
	class URL {

	    static __wrap(ptr) {
	        const obj = Object.create(URL.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_url_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.url_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {URL}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.url_from_bytes(ptr0, len0);
	        return URL.__wrap(ret);
	    }
	    /**
	    * @param {string} url
	    * @returns {URL}
	    */
	    static new(url) {
	        var ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.url_new(ptr0, len0);
	        return URL.__wrap(ret);
	    }
	    /**
	    * @returns {string}
	    */
	    url() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.url_url(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	}
	module.exports.URL = URL;
	/**
	*/
	class UnitInterval {

	    static __wrap(ptr) {
	        const obj = Object.create(UnitInterval.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_unitinterval_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.unitinterval_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {UnitInterval}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.unitinterval_from_bytes(ptr0, len0);
	        return UnitInterval.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    numerator() {
	        var ret = wasm.unitinterval_numerator(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {BigNum}
	    */
	    denominator() {
	        var ret = wasm.unitinterval_denominator(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} numerator
	    * @param {BigNum} denominator
	    * @returns {UnitInterval}
	    */
	    static new(numerator, denominator) {
	        _assertClass(numerator, BigNum);
	        _assertClass(denominator, BigNum);
	        var ret = wasm.unitinterval_new(numerator.ptr, denominator.ptr);
	        return UnitInterval.__wrap(ret);
	    }
	}
	module.exports.UnitInterval = UnitInterval;
	/**
	*/
	class Update {

	    static __wrap(ptr) {
	        const obj = Object.create(Update.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_update_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.update_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Update}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.update_from_bytes(ptr0, len0);
	        return Update.__wrap(ret);
	    }
	    /**
	    * @returns {ProposedProtocolParameterUpdates}
	    */
	    proposed_protocol_parameter_updates() {
	        var ret = wasm.update_proposed_protocol_parameter_updates(this.ptr);
	        return ProposedProtocolParameterUpdates.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    epoch() {
	        var ret = wasm.update_epoch(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {ProposedProtocolParameterUpdates} proposed_protocol_parameter_updates
	    * @param {number} epoch
	    * @returns {Update}
	    */
	    static new(proposed_protocol_parameter_updates, epoch) {
	        _assertClass(proposed_protocol_parameter_updates, ProposedProtocolParameterUpdates);
	        var ret = wasm.update_new(proposed_protocol_parameter_updates.ptr, epoch);
	        return Update.__wrap(ret);
	    }
	}
	module.exports.Update = Update;
	/**
	*/
	class VRFCert {

	    static __wrap(ptr) {
	        const obj = Object.create(VRFCert.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_vrfcert_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.vrfcert_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {VRFCert}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.vrfcert_from_bytes(ptr0, len0);
	        return VRFCert.__wrap(ret);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    output() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.vrfcert_output(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    proof() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.vrfcert_proof(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} output
	    * @param {Uint8Array} proof
	    * @returns {VRFCert}
	    */
	    static new(output, proof) {
	        var ptr0 = passArray8ToWasm0(output, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ptr1 = passArray8ToWasm0(proof, wasm.__wbindgen_malloc);
	        var len1 = WASM_VECTOR_LEN;
	        var ret = wasm.vrfcert_new(ptr0, len0, ptr1, len1);
	        return VRFCert.__wrap(ret);
	    }
	}
	module.exports.VRFCert = VRFCert;
	/**
	*/
	class VRFKeyHash {

	    static __wrap(ptr) {
	        const obj = Object.create(VRFKeyHash.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_vrfkeyhash_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.vrfkeyhash_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.vrfkeyhash_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {VRFKeyHash}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.vrfkeyhash_from_bech32(ptr0, len0);
	        return VRFKeyHash.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {VRFKeyHash}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.vrfkeyhash_from_bytes(ptr0, len0);
	        return VRFKeyHash.__wrap(ret);
	    }
	}
	module.exports.VRFKeyHash = VRFKeyHash;
	/**
	*/
	class VRFVKey {

	    static __wrap(ptr) {
	        const obj = Object.create(VRFVKey.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_vrfvkey_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.vrfvkey_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {string} prefix
	    * @returns {string}
	    */
	    to_bech32(prefix) {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	            var len0 = WASM_VECTOR_LEN;
	            wasm.vrfvkey_to_bech32(retptr, this.ptr, ptr0, len0);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            return getStringFromWasm0(r0, r1);
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	            wasm.__wbindgen_free(r0, r1);
	        }
	    }
	    /**
	    * @param {string} bech_str
	    * @returns {VRFVKey}
	    */
	    static from_bech32(bech_str) {
	        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.vrfvkey_from_bech32(ptr0, len0);
	        return VRFVKey.__wrap(ret);
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {VRFVKey}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.vrfvkey_from_bytes(ptr0, len0);
	        return VRFVKey.__wrap(ret);
	    }
	}
	module.exports.VRFVKey = VRFVKey;
	/**
	*/
	class Value {

	    static __wrap(ptr) {
	        const obj = Object.create(Value.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_value_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.value_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Value}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.value_from_bytes(ptr0, len0);
	        return Value.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} coin
	    * @returns {Value}
	    */
	    static new(coin) {
	        _assertClass(coin, BigNum);
	        var ret = wasm.value_new(coin.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * @param {MultiAsset} multiasset
	    * @returns {Value}
	    */
	    static new_from_assets(multiasset) {
	        _assertClass(multiasset, MultiAsset);
	        var ret = wasm.value_new_from_assets(multiasset.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * @returns {Value}
	    */
	    static zero() {
	        var ret = wasm.value_zero();
	        return Value.__wrap(ret);
	    }
	    /**
	    * @returns {boolean}
	    */
	    is_zero() {
	        var ret = wasm.value_is_zero(this.ptr);
	        return ret !== 0;
	    }
	    /**
	    * @returns {BigNum}
	    */
	    coin() {
	        var ret = wasm.value_coin(this.ptr);
	        return BigNum.__wrap(ret);
	    }
	    /**
	    * @param {BigNum} coin
	    */
	    set_coin(coin) {
	        _assertClass(coin, BigNum);
	        wasm.value_set_coin(this.ptr, coin.ptr);
	    }
	    /**
	    * @returns {MultiAsset | undefined}
	    */
	    multiasset() {
	        var ret = wasm.value_multiasset(this.ptr);
	        return ret === 0 ? undefined : MultiAsset.__wrap(ret);
	    }
	    /**
	    * @param {MultiAsset} multiasset
	    */
	    set_multiasset(multiasset) {
	        _assertClass(multiasset, MultiAsset);
	        wasm.value_set_multiasset(this.ptr, multiasset.ptr);
	    }
	    /**
	    * @param {Value} rhs
	    * @returns {Value}
	    */
	    checked_add(rhs) {
	        _assertClass(rhs, Value);
	        var ret = wasm.value_checked_add(this.ptr, rhs.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * @param {Value} rhs_value
	    * @returns {Value}
	    */
	    checked_sub(rhs_value) {
	        _assertClass(rhs_value, Value);
	        var ret = wasm.value_checked_sub(this.ptr, rhs_value.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * @param {Value} rhs_value
	    * @returns {Value}
	    */
	    clamped_sub(rhs_value) {
	        _assertClass(rhs_value, Value);
	        var ret = wasm.value_clamped_sub(this.ptr, rhs_value.ptr);
	        return Value.__wrap(ret);
	    }
	    /**
	    * note: values are only partially comparable
	    * @param {Value} rhs_value
	    * @returns {number | undefined}
	    */
	    compare(rhs_value) {
	        _assertClass(rhs_value, Value);
	        var ret = wasm.value_compare(this.ptr, rhs_value.ptr);
	        return ret === 0xFFFFFF ? undefined : ret;
	    }
	}
	module.exports.Value = Value;
	/**
	*/
	class Vkey {

	    static __wrap(ptr) {
	        const obj = Object.create(Vkey.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_vkey_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.vkey_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Vkey}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.vkey_from_bytes(ptr0, len0);
	        return Vkey.__wrap(ret);
	    }
	    /**
	    * @param {PublicKey} pk
	    * @returns {Vkey}
	    */
	    static new(pk) {
	        _assertClass(pk, PublicKey);
	        var ret = wasm.vkey_new(pk.ptr);
	        return Vkey.__wrap(ret);
	    }
	    /**
	    * @returns {PublicKey}
	    */
	    public_key() {
	        var ret = wasm.vkey_public_key(this.ptr);
	        return PublicKey.__wrap(ret);
	    }
	}
	module.exports.Vkey = Vkey;
	/**
	*/
	class Vkeys {

	    static __wrap(ptr) {
	        const obj = Object.create(Vkeys.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_vkeys_free(ptr);
	    }
	    /**
	    * @returns {Vkeys}
	    */
	    static new() {
	        var ret = wasm.vkeys_new();
	        return Vkeys.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.vkeys_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {Vkey}
	    */
	    get(index) {
	        var ret = wasm.vkeys_get(this.ptr, index);
	        return Vkey.__wrap(ret);
	    }
	    /**
	    * @param {Vkey} elem
	    */
	    add(elem) {
	        _assertClass(elem, Vkey);
	        wasm.vkeys_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.Vkeys = Vkeys;
	/**
	*/
	class Vkeywitness {

	    static __wrap(ptr) {
	        const obj = Object.create(Vkeywitness.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_vkeywitness_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.vkeywitness_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Vkeywitness}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.vkeywitness_from_bytes(ptr0, len0);
	        return Vkeywitness.__wrap(ret);
	    }
	    /**
	    * @param {Vkey} vkey
	    * @param {Ed25519Signature} signature
	    * @returns {Vkeywitness}
	    */
	    static new(vkey, signature) {
	        _assertClass(vkey, Vkey);
	        _assertClass(signature, Ed25519Signature);
	        var ret = wasm.vkeywitness_new(vkey.ptr, signature.ptr);
	        return Vkeywitness.__wrap(ret);
	    }
	    /**
	    * @returns {Vkey}
	    */
	    vkey() {
	        var ret = wasm.vkeywitness_vkey(this.ptr);
	        return Vkey.__wrap(ret);
	    }
	    /**
	    * @returns {Ed25519Signature}
	    */
	    signature() {
	        var ret = wasm.vkeywitness_signature(this.ptr);
	        return Ed25519Signature.__wrap(ret);
	    }
	}
	module.exports.Vkeywitness = Vkeywitness;
	/**
	*/
	class Vkeywitnesses {

	    static __wrap(ptr) {
	        const obj = Object.create(Vkeywitnesses.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_vkeywitnesses_free(ptr);
	    }
	    /**
	    * @returns {Vkeywitnesses}
	    */
	    static new() {
	        var ret = wasm.vkeywitnesses_new();
	        return Vkeywitnesses.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.vkeywitnesses_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {number} index
	    * @returns {Vkeywitness}
	    */
	    get(index) {
	        var ret = wasm.vkeywitnesses_get(this.ptr, index);
	        return Vkeywitness.__wrap(ret);
	    }
	    /**
	    * @param {Vkeywitness} elem
	    */
	    add(elem) {
	        _assertClass(elem, Vkeywitness);
	        wasm.vkeywitnesses_add(this.ptr, elem.ptr);
	    }
	}
	module.exports.Vkeywitnesses = Vkeywitnesses;
	/**
	*/
	class Withdrawals {

	    static __wrap(ptr) {
	        const obj = Object.create(Withdrawals.prototype);
	        obj.ptr = ptr;

	        return obj;
	    }

	    __destroy_into_raw() {
	        const ptr = this.ptr;
	        this.ptr = 0;

	        return ptr;
	    }

	    free() {
	        const ptr = this.__destroy_into_raw();
	        wasm.__wbg_withdrawals_free(ptr);
	    }
	    /**
	    * @returns {Uint8Array}
	    */
	    to_bytes() {
	        try {
	            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
	            wasm.withdrawals_to_bytes(retptr, this.ptr);
	            var r0 = getInt32Memory0()[retptr / 4 + 0];
	            var r1 = getInt32Memory0()[retptr / 4 + 1];
	            var v0 = getArrayU8FromWasm0(r0, r1).slice();
	            wasm.__wbindgen_free(r0, r1 * 1);
	            return v0;
	        } finally {
	            wasm.__wbindgen_add_to_stack_pointer(16);
	        }
	    }
	    /**
	    * @param {Uint8Array} bytes
	    * @returns {Withdrawals}
	    */
	    static from_bytes(bytes) {
	        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
	        var len0 = WASM_VECTOR_LEN;
	        var ret = wasm.withdrawals_from_bytes(ptr0, len0);
	        return Withdrawals.__wrap(ret);
	    }
	    /**
	    * @returns {Withdrawals}
	    */
	    static new() {
	        var ret = wasm.withdrawals_new();
	        return Withdrawals.__wrap(ret);
	    }
	    /**
	    * @returns {number}
	    */
	    len() {
	        var ret = wasm.withdrawals_len(this.ptr);
	        return ret >>> 0;
	    }
	    /**
	    * @param {RewardAddress} key
	    * @param {BigNum} value
	    * @returns {BigNum | undefined}
	    */
	    insert(key, value) {
	        _assertClass(key, RewardAddress);
	        _assertClass(value, BigNum);
	        var ret = wasm.withdrawals_insert(this.ptr, key.ptr, value.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @param {RewardAddress} key
	    * @returns {BigNum | undefined}
	    */
	    get(key) {
	        _assertClass(key, RewardAddress);
	        var ret = wasm.withdrawals_get(this.ptr, key.ptr);
	        return ret === 0 ? undefined : BigNum.__wrap(ret);
	    }
	    /**
	    * @returns {RewardAddresses}
	    */
	    keys() {
	        var ret = wasm.withdrawals_keys(this.ptr);
	        return RewardAddresses.__wrap(ret);
	    }
	}
	module.exports.Withdrawals = Withdrawals;

	module.exports.__wbindgen_object_drop_ref = function(arg0) {
	    takeObject(arg0);
	};

	module.exports.__wbindgen_string_new = function(arg0, arg1) {
	    var ret = getStringFromWasm0(arg0, arg1);
	    return addHeapObject(ret);
	};

	module.exports.__wbindgen_string_get = function(arg0, arg1) {
	    const obj = getObject(arg1);
	    var ret = typeof(obj) === 'string' ? obj : undefined;
	    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	    var len0 = WASM_VECTOR_LEN;
	    getInt32Memory0()[arg0 / 4 + 1] = len0;
	    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
	};

	module.exports.__wbg_getRandomValues_98117e9a7e993920 = function() { return handleError(function (arg0, arg1) {
	    getObject(arg0).getRandomValues(getObject(arg1));
	}, arguments) };

	module.exports.__wbg_randomFillSync_64cc7d048f228ca8 = function() { return handleError(function (arg0, arg1, arg2) {
	    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
	}, arguments) };

	module.exports.__wbg_process_2f24d6544ea7b200 = function(arg0) {
	    var ret = getObject(arg0).process;
	    return addHeapObject(ret);
	};

	module.exports.__wbindgen_is_object = function(arg0) {
	    const val = getObject(arg0);
	    var ret = typeof(val) === 'object' && val !== null;
	    return ret;
	};

	module.exports.__wbg_versions_6164651e75405d4a = function(arg0) {
	    var ret = getObject(arg0).versions;
	    return addHeapObject(ret);
	};

	module.exports.__wbg_node_4b517d861cbcb3bc = function(arg0) {
	    var ret = getObject(arg0).node;
	    return addHeapObject(ret);
	};

	module.exports.__wbindgen_is_string = function(arg0) {
	    var ret = typeof(getObject(arg0)) === 'string';
	    return ret;
	};

	module.exports.__wbg_crypto_98fc271021c7d2ad = function(arg0) {
	    var ret = getObject(arg0).crypto;
	    return addHeapObject(ret);
	};

	module.exports.__wbg_msCrypto_a2cdb043d2bfe57f = function(arg0) {
	    var ret = getObject(arg0).msCrypto;
	    return addHeapObject(ret);
	};

	module.exports.__wbg_modulerequire_3440a4bcf44437db = function() { return handleError(function (arg0, arg1) {
	    var ret = commonjsRequire(getStringFromWasm0(arg0, arg1));
	    return addHeapObject(ret);
	}, arguments) };

	module.exports.__wbg_newnoargs_9fdd8f3961dd1bee = function(arg0, arg1) {
	    var ret = new Function(getStringFromWasm0(arg0, arg1));
	    return addHeapObject(ret);
	};

	module.exports.__wbg_call_ba36642bd901572b = function() { return handleError(function (arg0, arg1) {
	    var ret = getObject(arg0).call(getObject(arg1));
	    return addHeapObject(ret);
	}, arguments) };

	module.exports.__wbg_self_bb69a836a72ec6e9 = function() { return handleError(function () {
	    var ret = self.self;
	    return addHeapObject(ret);
	}, arguments) };

	module.exports.__wbg_window_3304fc4b414c9693 = function() { return handleError(function () {
	    var ret = window.window;
	    return addHeapObject(ret);
	}, arguments) };

	module.exports.__wbg_globalThis_e0d21cabc6630763 = function() { return handleError(function () {
	    var ret = globalThis.globalThis;
	    return addHeapObject(ret);
	}, arguments) };

	module.exports.__wbg_global_8463719227271676 = function() { return handleError(function () {
	    var ret = commonjsGlobal.global;
	    return addHeapObject(ret);
	}, arguments) };

	module.exports.__wbindgen_is_undefined = function(arg0) {
	    var ret = getObject(arg0) === undefined;
	    return ret;
	};

	module.exports.__wbg_buffer_9e184d6f785de5ed = function(arg0) {
	    var ret = getObject(arg0).buffer;
	    return addHeapObject(ret);
	};

	module.exports.__wbg_new_e8101319e4cf95fc = function(arg0) {
	    var ret = new Uint8Array(getObject(arg0));
	    return addHeapObject(ret);
	};

	module.exports.__wbg_set_e8ae7b27314e8b98 = function(arg0, arg1, arg2) {
	    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
	};

	module.exports.__wbg_length_2d56cb37075fcfb1 = function(arg0) {
	    var ret = getObject(arg0).length;
	    return ret;
	};

	module.exports.__wbg_newwithlength_a8d1dbcbe703a5c6 = function(arg0) {
	    var ret = new Uint8Array(arg0 >>> 0);
	    return addHeapObject(ret);
	};

	module.exports.__wbg_subarray_901ede8318da52a6 = function(arg0, arg1, arg2) {
	    var ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
	    return addHeapObject(ret);
	};

	module.exports.__wbindgen_object_clone_ref = function(arg0) {
	    var ret = getObject(arg0);
	    return addHeapObject(ret);
	};

	module.exports.__wbg_new_3a746f2619705add = function(arg0, arg1) {
	    var ret = new Function(getStringFromWasm0(arg0, arg1));
	    return addHeapObject(ret);
	};

	module.exports.__wbg_call_f54d3a6dadb199ca = function(arg0, arg1) {
	    var ret = getObject(arg0).call(getObject(arg1));
	    return addHeapObject(ret);
	};

	module.exports.__wbindgen_jsval_eq = function(arg0, arg1) {
	    var ret = getObject(arg0) === getObject(arg1);
	    return ret;
	};

	module.exports.__wbg_self_ac379e780a0d8b94 = function(arg0) {
	    var ret = getObject(arg0).self;
	    return addHeapObject(ret);
	};

	module.exports.__wbg_crypto_1e4302b85d4f64a2 = function(arg0) {
	    var ret = getObject(arg0).crypto;
	    return addHeapObject(ret);
	};

	module.exports.__wbg_getRandomValues_1b4ba144162a5c9e = function(arg0) {
	    var ret = getObject(arg0).getRandomValues;
	    return addHeapObject(ret);
	};

	module.exports.__wbg_require_6461b1e9a0d7c34a = function(arg0, arg1) {
	    var ret = commonjsRequire(getStringFromWasm0(arg0, arg1));
	    return addHeapObject(ret);
	};

	module.exports.__wbg_randomFillSync_1b52c8482374c55b = function(arg0, arg1, arg2) {
	    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
	};

	module.exports.__wbg_getRandomValues_1ef11e888e5228e9 = function(arg0, arg1, arg2) {
	    getObject(arg0).getRandomValues(getArrayU8FromWasm0(arg1, arg2));
	};

	module.exports.__wbindgen_debug_string = function(arg0, arg1) {
	    var ret = debugString(getObject(arg1));
	    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
	    var len0 = WASM_VECTOR_LEN;
	    getInt32Memory0()[arg0 / 4 + 1] = len0;
	    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
	};

	module.exports.__wbindgen_throw = function(arg0, arg1) {
	    throw new Error(getStringFromWasm0(arg0, arg1));
	};

	module.exports.__wbindgen_rethrow = function(arg0) {
	    throw takeObject(arg0);
	};

	module.exports.__wbindgen_memory = function() {
	    var ret = wasm.memory;
	    return addHeapObject(ret);
	};

	const path = require$$1$4.join(__dirname, 'cardano_serialization_lib_bg.wasm');
	const bytes = require$$2$2.readFileSync(path);

	const wasmModule = new WebAssembly.Module(bytes);
	const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
	wasm = wasmInstance.exports;
	module.exports.__wasm = wasm; 
} (cardano_serialization_lib));

var cardano_serialization_libExports = cardano_serialization_lib.exports;

var cip14Js = {};

var blake2b$1 = {exports: {}};

assert$2.notEqual = notEqual;
assert$2.notOk = notOk;
assert$2.equal = equal;
assert$2.ok = assert$2;

var nanoassert = assert$2;

function equal (a, b, m) {
  assert$2(a == b, m); // eslint-disable-line eqeqeq
}

function notEqual (a, b, m) {
  assert$2(a != b, m); // eslint-disable-line eqeqeq
}

function notOk (t, m) {
  assert$2(!t, m);
}

function assert$2 (t, m) {
  if (!t) throw new Error(m || 'AssertionError')
}

var blake2bWasm = {exports: {}};

var blake2b = loadWebAssembly;

loadWebAssembly.supported = typeof WebAssembly !== 'undefined';

function loadWebAssembly (opts) {
  if (!loadWebAssembly.supported) return null

  var imp = opts && opts.imports;
  var wasm = toUint8Array('AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL');
  var ready = null;

  var mod = {
    buffer: wasm,
    memory: null,
    exports: null,
    realloc: realloc,
    onload: onload
  };

  onload(function () {});

  return mod

  function realloc (size) {
    mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536));
    mod.memory = new Uint8Array(mod.exports.memory.buffer);
  }

  function onload (cb) {
    if (mod.exports) return cb()

    if (ready) {
      ready.then(cb.bind(null, null)).catch(cb);
      return
    }

    try {
      if (opts && opts.async) throw new Error('async')
      setup({instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)});
    } catch (err) {
      ready = WebAssembly.instantiate(wasm, imp).then(setup);
    }

    onload(cb);
  }

  function setup (w) {
    mod.exports = w.instance.exports;
    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
  }
}

function toUint8Array (s) {
  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt))
  return new (commonjsRequire('buf' + 'fer').Buffer)(s, 'base64')
}

function charCodeAt (c) {
  return c.charCodeAt(0)
}

var assert$1 = nanoassert;
var wasm = blake2b();

var head = 64;
var freeList = [];

blake2bWasm.exports = Blake2b$1;
var BYTES_MIN$1 = blake2bWasm.exports.BYTES_MIN = 16;
var BYTES_MAX$1 = blake2bWasm.exports.BYTES_MAX = 64;
blake2bWasm.exports.BYTES = 32;
var KEYBYTES_MIN$1 = blake2bWasm.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX$1 = blake2bWasm.exports.KEYBYTES_MAX = 64;
blake2bWasm.exports.KEYBYTES = 32;
var SALTBYTES$1 = blake2bWasm.exports.SALTBYTES = 16;
var PERSONALBYTES$1 = blake2bWasm.exports.PERSONALBYTES = 16;

function Blake2b$1 (digestLength, key, salt, personal, noAssert) {
  if (!(this instanceof Blake2b$1)) return new Blake2b$1(digestLength, key, salt, personal, noAssert)
  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)')
  if (!digestLength) digestLength = 32;

  if (noAssert !== true) {
    assert$1(digestLength >= BYTES_MIN$1, 'digestLength must be at least ' + BYTES_MIN$1 + ', was given ' + digestLength);
    assert$1(digestLength <= BYTES_MAX$1, 'digestLength must be at most ' + BYTES_MAX$1 + ', was given ' + digestLength);
    if (key != null) assert$1(key.length >= KEYBYTES_MIN$1, 'key must be at least ' + KEYBYTES_MIN$1 + ', was given ' + key.length);
    if (key != null) assert$1(key.length <= KEYBYTES_MAX$1, 'key must be at least ' + KEYBYTES_MAX$1 + ', was given ' + key.length);
    if (salt != null) assert$1(salt.length === SALTBYTES$1, 'salt must be exactly ' + SALTBYTES$1 + ', was given ' + salt.length);
    if (personal != null) assert$1(personal.length === PERSONALBYTES$1, 'personal must be exactly ' + PERSONALBYTES$1 + ', was given ' + personal.length);
  }

  if (!freeList.length) {
    freeList.push(head);
    head += 216;
  }

  this.digestLength = digestLength;
  this.finalized = false;
  this.pointer = freeList.pop();

  wasm.memory.fill(0, 0, 64);
  wasm.memory[0] = this.digestLength;
  wasm.memory[1] = key ? key.length : 0;
  wasm.memory[2] = 1; // fanout
  wasm.memory[3] = 1; // depth

  if (salt) wasm.memory.set(salt, 32);
  if (personal) wasm.memory.set(personal, 48);

  if (this.pointer + 216 > wasm.memory.length) wasm.realloc(this.pointer + 216); // we need 216 bytes for the state
  wasm.exports.blake2b_init(this.pointer, this.digestLength);

  if (key) {
    this.update(key);
    wasm.memory.fill(0, head, head + key.length); // whiteout key
    wasm.memory[this.pointer + 200] = 128;
  }
}


Blake2b$1.prototype.update = function (input) {
  assert$1(this.finalized === false, 'Hash instance finalized');
  assert$1(input, 'input must be TypedArray or Buffer');

  if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length);
  wasm.memory.set(input, head);
  wasm.exports.blake2b_update(this.pointer, head, head + input.length);
  return this
};

Blake2b$1.prototype.digest = function (enc) {
  assert$1(this.finalized === false, 'Hash instance finalized');
  this.finalized = true;

  freeList.push(this.pointer);
  wasm.exports.blake2b_final(this.pointer);

  if (!enc || enc === 'binary') {
    return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength)
  }

  if (enc === 'hex') {
    return hexSlice$1(wasm.memory, this.pointer + 128, this.digestLength)
  }

  assert$1(enc.length >= this.digestLength, 'input must be TypedArray or Buffer');
  for (var i = 0; i < this.digestLength; i++) {
    enc[i] = wasm.memory[this.pointer + 128 + i];
  }

  return enc
};

// libsodium compat
Blake2b$1.prototype.final = Blake2b$1.prototype.digest;

Blake2b$1.WASM = wasm && wasm.buffer;
Blake2b$1.SUPPORTED = typeof WebAssembly !== 'undefined';

Blake2b$1.ready = function (cb) {
  if (!cb) cb = noop;
  if (!wasm) return cb(new Error('WebAssembly not supported'))

  // backwards compat, can be removed in a new major
  var p = new Promise(function (reject, resolve) {
    wasm.onload(function (err) {
      if (err) resolve();
      else reject();
      cb(err);
    });
  });

  return p
};

Blake2b$1.prototype.ready = Blake2b$1.ready;

function noop () {}

function hexSlice$1 (buf, start, len) {
  var str = '';
  for (var i = 0; i < len; i++) str += toHex$1(buf[start + i]);
  return str
}

function toHex$1 (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

var blake2bWasmExports = blake2bWasm.exports;

var assert = nanoassert;
var b2wasm = blake2bWasmExports;

// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA (v, a, b) {
  var o0 = v[a] + v[b];
  var o1 = v[a + 1] + v[b + 1];
  if (o0 >= 0x100000000) {
    o1++;
  }
  v[a] = o0;
  v[a + 1] = o1;
}

// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC (v, a, b0, b1) {
  var o0 = v[a] + b0;
  if (b0 < 0) {
    o0 += 0x100000000;
  }
  var o1 = v[a + 1] + b1;
  if (o0 >= 0x100000000) {
    o1++;
  }
  v[a] = o0;
  v[a + 1] = o1;
}

// Little-endian byte access
function B2B_GET32 (arr, i) {
  return (arr[i] ^
  (arr[i + 1] << 8) ^
  (arr[i + 2] << 16) ^
  (arr[i + 3] << 24))
}

// G Mixing function
// The ROTRs are inlined for speed
function B2B_G (a, b, c, d, ix, iy) {
  var x0 = m[ix];
  var x1 = m[ix + 1];
  var y0 = m[iy];
  var y1 = m[iy + 1];

  ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
  ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
  var xor0 = v[d] ^ v[a];
  var xor1 = v[d + 1] ^ v[a + 1];
  v[d] = xor1;
  v[d + 1] = xor0;

  ADD64AA(v, c, d);

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = (xor0 >>> 24) ^ (xor1 << 8);
  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8);

  ADD64AA(v, a, b);
  ADD64AC(v, a, y0, y1);

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
  xor0 = v[d] ^ v[a];
  xor1 = v[d + 1] ^ v[a + 1];
  v[d] = (xor0 >>> 16) ^ (xor1 << 16);
  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16);

  ADD64AA(v, c, d);

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = (xor1 >>> 31) ^ (xor0 << 1);
  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1);
}

// Initialization Vector
var BLAKE2B_IV32 = new Uint32Array([
  0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85,
  0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A,
  0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C,
  0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19
]);

var SIGMA8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,
  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,
  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3
];

// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
var SIGMA82 = new Uint8Array(SIGMA8.map(function (x) { return x * 2 }));

// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
var v = new Uint32Array(32);
var m = new Uint32Array(32);
function blake2bCompress (ctx, last) {
  var i = 0;

  // init work variables
  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i];
    v[i + 16] = BLAKE2B_IV32[i];
  }

  // low 64 bits of offset
  v[24] = v[24] ^ ctx.t;
  v[25] = v[25] ^ (ctx.t / 0x100000000);
  // high 64 bits not supported, offset may not be higher than 2**53-1

  // last block flag set ?
  if (last) {
    v[28] = ~v[28];
    v[29] = ~v[29];
  }

  // get little-endian words
  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i);
  }

  // twelve rounds of mixing
  for (i = 0; i < 12; i++) {
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
  }

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
  }
}

// reusable parameter_block
var parameter_block = new Uint8Array([
  0, 0, 0, 0,      //  0: outlen, keylen, fanout, depth
  0, 0, 0, 0,      //  4: leaf length, sequential mode
  0, 0, 0, 0,      //  8: node offset
  0, 0, 0, 0,      // 12: node offset
  0, 0, 0, 0,      // 16: node depth, inner length, rfu
  0, 0, 0, 0,      // 20: rfu
  0, 0, 0, 0,      // 24: rfu
  0, 0, 0, 0,      // 28: rfu
  0, 0, 0, 0,      // 32: salt
  0, 0, 0, 0,      // 36: salt
  0, 0, 0, 0,      // 40: salt
  0, 0, 0, 0,      // 44: salt
  0, 0, 0, 0,      // 48: personal
  0, 0, 0, 0,      // 52: personal
  0, 0, 0, 0,      // 56: personal
  0, 0, 0, 0       // 60: personal
]);

// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
function Blake2b (outlen, key, salt, personal) {
  // zero out parameter_block before usage
  parameter_block.fill(0);
  // state, 'param block'

  this.b = new Uint8Array(128);
  this.h = new Uint32Array(16);
  this.t = 0; // input count
  this.c = 0; // pointer within buffer
  this.outlen = outlen; // output length in bytes

  parameter_block[0] = outlen;
  if (key) parameter_block[1] = key.length;
  parameter_block[2] = 1; // fanout
  parameter_block[3] = 1; // depth

  if (salt) parameter_block.set(salt, 32);
  if (personal) parameter_block.set(personal, 48);

  // initialize hash state
  for (var i = 0; i < 16; i++) {
    this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4);
  }

  // key the hash, if applicable
  if (key) {
    blake2bUpdate(this, key);
    // at the end
    this.c = 128;
  }
}

Blake2b.prototype.update = function (input) {
  assert(input != null, 'input must be Uint8Array or Buffer');
  blake2bUpdate(this, input);
  return this
};

Blake2b.prototype.digest = function (out) {
  var buf = (!out || out === 'binary' || out === 'hex') ? new Uint8Array(this.outlen) : out;
  assert(buf.length >= this.outlen, 'out must have at least outlen bytes of space');
  blake2bFinal(this, buf);
  if (out === 'hex') return hexSlice(buf)
  return buf
};

Blake2b.prototype.final = Blake2b.prototype.digest;

Blake2b.ready = function (cb) {
  b2wasm.ready(function () {
    cb(); // ignore the error
  });
};

// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate (ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 128) { // buffer full ?
      ctx.t += ctx.c; // add counters
      blake2bCompress(ctx, false); // compress (not last)
      ctx.c = 0; // counter to zero
    }
    ctx.b[ctx.c++] = input[i];
  }
}

// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal (ctx, out) {
  ctx.t += ctx.c; // mark last block offset

  while (ctx.c < 128) { // fill up with zeros
    ctx.b[ctx.c++] = 0;
  }
  blake2bCompress(ctx, true); // final block flag = 1

  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> (8 * (i & 3));
  }
  return out
}

function hexSlice (buf) {
  var str = '';
  for (var i = 0; i < buf.length; i++) str += toHex(buf[i]);
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

var Proto = Blake2b;

blake2b$1.exports = function createHash (outlen, key, salt, personal, noAssert) {
  if (noAssert !== true) {
    assert(outlen >= BYTES_MIN, 'outlen must be at least ' + BYTES_MIN + ', was given ' + outlen);
    assert(outlen <= BYTES_MAX, 'outlen must be at most ' + BYTES_MAX + ', was given ' + outlen);
    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at most ' + KEYBYTES_MAX + ', was given ' + key.length);
    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
  }

  return new Proto(outlen, key, salt, personal)
};

blake2b$1.exports.ready = function (cb) {
  b2wasm.ready(function () { // ignore errors
    cb();
  });
};

blake2b$1.exports.WASM_SUPPORTED = b2wasm.SUPPORTED;
blake2b$1.exports.WASM_LOADED = false;

var BYTES_MIN = blake2b$1.exports.BYTES_MIN = 16;
var BYTES_MAX = blake2b$1.exports.BYTES_MAX = 64;
blake2b$1.exports.BYTES = 32;
var KEYBYTES_MIN = blake2b$1.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = blake2b$1.exports.KEYBYTES_MAX = 64;
blake2b$1.exports.KEYBYTES = 32;
var SALTBYTES = blake2b$1.exports.SALTBYTES = 16;
var PERSONALBYTES = blake2b$1.exports.PERSONALBYTES = 16;

b2wasm.ready(function (err) {
  if (!err) {
    blake2b$1.exports.WASM_LOADED = true;
    Proto = b2wasm;
  }
});

var blake2bExports = blake2b$1.exports;

var dist = {};

Object.defineProperty(dist, "__esModule", { value: true });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (((pre & 0x1ffffff) << 5) ^
        (-((b >> 0) & 1) & 0x3b6a57b2) ^
        (-((b >> 1) & 1) & 0x26508e6d) ^
        (-((b >> 2) & 1) & 0x1ea119fa) ^
        (-((b >> 3) & 1) & 0x3d4233dd) ^
        (-((b >> 4) & 1) & 0x2a1462b3));
}
function prefixChk(prefix) {
    let chk = 1;
    for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ (c >> 5);
    }
    chk = polymodStep(chk);
    for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ (v & 0x1f);
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i = 0; i < data.length; ++i) {
        value = (value << inBits) | data[i];
        bits += inBits;
        while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push((value << (outBits - bits)) & maxV);
        }
    }
    else {
        if (bits >= inBits)
            return 'Excess padding';
        if ((value << (outBits - bits)) & maxV)
            return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    }
    else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            throw new Error(chk);
        let result = prefix + '1';
        for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
                throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
            const v = (chk >> ((5 - i) * 5)) & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
            return str + ' too short';
        if (str.length > LIMIT)
            return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
            return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1)
            return 'No separator character for ' + str;
        if (split === 0)
            return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
            return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined)
                return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length)
                continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST)
            return 'Invalid checksum for ' + str;
        return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords,
    };
}
dist.bech32 = getLibraryFromEncoding('bech32');
dist.bech32m = getLibraryFromEncoding('bech32m');

var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(cip14Js, "__esModule", { value: true });
const blake2b_1 = __importDefault(blake2bExports);
const bech32_1 = dist;
/// note: this function can't be inverted due to the hash
const DATA = "asset";
class AssetFingerprint {
    constructor(hashBuf) {
        this.hashBuf = hashBuf;
    }
    static fromHash(hash) {
        return new AssetFingerprint(hash);
    }
    static fromParts(policyId, assetName) {
        // see https://github.com/cardano-foundation/CIPs/pull/64
        const hashBuf = (0, blake2b_1.default)(20)
            .update(new Uint8Array([...policyId, ...assetName]))
            .digest("binary");
        return AssetFingerprint.fromHash(hashBuf);
    }
    static fromBech32(fingerprint) {
        const { prefix, words } = bech32_1.bech32.decode(fingerprint);
        if (prefix !== DATA) {
            throw new Error("Invalid asset fingerprint");
        }
        const hashBuf = Buffer.from(bech32_1.bech32.fromWords(words));
        return AssetFingerprint.fromHash(hashBuf);
    }
    fingerprint() {
        const words = bech32_1.bech32.toWords(this.hashBuf);
        return bech32_1.bech32.encode(DATA, words);
    }
    hash() {
        return Buffer.from(this.hashBuf).toString("hex");
    }
    prefix() {
        return DATA;
    }
    // The last six characters of the data part form a checksum and contain no information
    checksum() {
        return this.fingerprint().slice(-6);
    }
}
cip14Js.default = AssetFingerprint;

(function (exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.verifyWebhookSignature = exports.parseAsset = exports.getFingerprint = exports.hexToString = exports.deriveAddress = void 0;
	const crypto_1 = require$$0$8;
	const cardano_serialization_lib_nodejs_1 = cardano_serialization_libExports;
	const cip14_js_1 = __importDefault(cip14Js);
	const errors_1 = errors$1;
	/**
	 * Derives an address with derivation path m/1852'/1815'/account'/role/addressIndex
	 * If role === 2 then it returns a stake address (m/1852'/1815'/account'/2/addressIndex)
	 *
	 * @Returns {address: string, path: number[] } An object with bech32 address and corresponding partial derivation path {address: string, path: [role, addressIndex]}
	 * */
	const deriveAddress = (accountPublicKey, role, addressIndex, isTestnet, isByron) => {
	    const accountKey = cardano_serialization_lib_nodejs_1.Bip32PublicKey.from_bytes(Buffer.from(accountPublicKey, 'hex'));
	    const utxoPubKey = accountKey.derive(role).derive(addressIndex);
	    const mainStakeKey = accountKey.derive(2).derive(0);
	    const testnetNetworkInfo = cardano_serialization_lib_nodejs_1.NetworkInfo.testnet();
	    const mainnetNetworkInfo = cardano_serialization_lib_nodejs_1.NetworkInfo.mainnet();
	    const networkId = isTestnet
	        ? testnetNetworkInfo.network_id()
	        : mainnetNetworkInfo.network_id();
	    const utxoPubKeyHash = utxoPubKey.to_raw_key().hash();
	    const mainStakeKeyHash = mainStakeKey.to_raw_key().hash();
	    const utxoStakeCred = cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(utxoPubKeyHash);
	    const mainStakeCred = cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(mainStakeKeyHash);
	    const baseAddr = cardano_serialization_lib_nodejs_1.BaseAddress.new(networkId, utxoStakeCred, mainStakeCred);
	    utxoStakeCred.free();
	    mainStakeCred.free();
	    mainStakeKeyHash.free();
	    utxoPubKeyHash.free();
	    const baseAddrBech32 = baseAddr.to_address().to_bech32();
	    baseAddr.free();
	    if (role === 2 && !isByron) {
	        const addressSpecificStakeKey = accountKey.derive(2).derive(addressIndex);
	        const stakeKeyHash = addressSpecificStakeKey.to_raw_key().hash();
	        const stakeCred = cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(stakeKeyHash);
	        // always return stake address
	        const rewardAddr = cardano_serialization_lib_nodejs_1.RewardAddress.new(networkId, stakeCred);
	        const rewardAddrBech32 = rewardAddr.to_address().to_bech32();
	        rewardAddr.free();
	        addressSpecificStakeKey.free();
	        stakeKeyHash.free();
	        stakeCred.free();
	        return {
	            address: rewardAddrBech32,
	            path: [role, addressIndex],
	        };
	    }
	    if (isByron) {
	        const protocolMagic = isTestnet
	            ? testnetNetworkInfo.protocol_magic()
	            : mainnetNetworkInfo.protocol_magic();
	        const byronAddress = cardano_serialization_lib_nodejs_1.ByronAddress.icarus_from_key(utxoPubKey, protocolMagic);
	        const byronAddrBase58 = byronAddress.to_base58();
	        byronAddress.free();
	        return {
	            address: byronAddrBase58,
	            path: [role, addressIndex],
	        };
	    }
	    mainStakeKey.free();
	    utxoPubKey.free();
	    accountKey.free();
	    testnetNetworkInfo.free();
	    mainnetNetworkInfo.free();
	    return {
	        address: baseAddrBech32,
	        path: [role, addressIndex],
	    };
	};
	exports.deriveAddress = deriveAddress;
	const hexToString = (input) => {
	    const hex = input.toString();
	    let str = '';
	    for (let n = 0; n < hex.length; n += 2) {
	        str += String.fromCharCode(parseInt(hex.substr(n, 2), 16));
	    }
	    return str;
	};
	exports.hexToString = hexToString;
	const getFingerprint = (policyId, assetName) => cip14_js_1.default.fromParts(Uint8Array.from(Buffer.from(policyId, 'hex')), Uint8Array.from(Buffer.from(assetName || '', 'hex'))).fingerprint();
	exports.getFingerprint = getFingerprint;
	const parseAsset = (hex) => {
	    const policyIdSize = 56;
	    const policyId = hex.slice(0, policyIdSize);
	    const assetNameHex = hex.slice(policyIdSize);
	    const assetName = (0, exports.hexToString)(assetNameHex);
	    const fingerprint = (0, exports.getFingerprint)(policyId, assetNameHex);
	    return {
	        policyId,
	        assetName,
	        assetNameHex,
	        fingerprint,
	    };
	};
	exports.parseAsset = parseAsset;
	/**
	 * Verifies webhook signature
	 *
	 * @param {string|Buffer} webhookPayload Buffer or stringified payload of the webhook request.
	 * @param {string|Buffer} signatureHeader Blockfrost-Signature header.
	 * @param {string} secret Auth token for the webhook.
	 * @param {number} [timestampToleranceSeconds=600] Time tolerance affecting signature validity. By default signatures older than 600s are considered invalid.
	 * @returns {boolean} Whether the signature is valid.
	 * */
	const verifyWebhookSignature = (webhookPayload, signatureHeader, secret, timestampToleranceSeconds = 600) => {
	    let timestamp;
	    if (Array.isArray(signatureHeader)) {
	        throw new errors_1.SignatureVerificationError('Unexpected: An array was passed as a Blockfrost-Signature header');
	    }
	    const decodedWebhookPayload = Buffer.isBuffer(webhookPayload)
	        ? webhookPayload.toString('utf8')
	        : webhookPayload;
	    const decodedSignatureHeader = Buffer.isBuffer(signatureHeader)
	        ? signatureHeader.toString('utf8')
	        : signatureHeader;
	    // Parse signature header (example: t=1648550558,v1=162381a59040c97d9b323cdfec02facdfce0968490ec1732f5d938334c1eed4e,v1=...)
	    const signatures = [];
	    const tokens = decodedSignatureHeader.split(',');
	    for (const token of tokens) {
	        const [key, value] = token.split('=');
	        switch (key) {
	            case 't':
	                timestamp = Number(value);
	                break;
	            case 'v1':
	                signatures.push(value);
	                break;
	            default:
	                console.warn(`Cannot parse part of the signature header, key "${key}" is not supported by this version of Blockfrost SDK.`);
	        }
	    }
	    if (!timestamp || tokens.length < 2) {
	        // timestamp and at least one signature must be present
	        throw new errors_1.SignatureVerificationError('Invalid signature header format.', {
	            signatureHeader: decodedSignatureHeader,
	            webhookPayload: decodedWebhookPayload,
	        });
	    }
	    if (signatures.length === 0) {
	        throw new errors_1.SignatureVerificationError('No signatures with supported version scheme.', {
	            signatureHeader: decodedSignatureHeader,
	            webhookPayload: decodedWebhookPayload,
	        });
	    }
	    let hasValidSignature = false;
	    for (const signature of signatures) {
	        // Recreate signature by concatenating timestamp with stringified payload,
	        // then compute HMAC using sha256 and provided secret (auth token)
	        const signaturePayload = `${timestamp}.${decodedWebhookPayload}`;
	        const hmac = (0, crypto_1.createHmac)('sha256', secret)
	            .update(signaturePayload)
	            .digest('hex');
	        // computed hmac should match signature parsed from a signature header
	        if (hmac === signature) {
	            hasValidSignature = true;
	        }
	    }
	    if (!hasValidSignature) {
	        throw new errors_1.SignatureVerificationError('No signature matches the expected signature for the payload.', {
	            signatureHeader: decodedSignatureHeader,
	            webhookPayload: decodedWebhookPayload,
	        });
	    }
	    const currentTimestamp = Math.floor(new Date().getTime() / 1000);
	    if (currentTimestamp - timestamp > timestampToleranceSeconds) {
	        // Event is older than timestamp_tolerance_seconds
	        throw new errors_1.SignatureVerificationError("Signature's timestamp is outside of the time tolerance", {
	            signatureHeader: decodedSignatureHeader,
	            webhookPayload: decodedWebhookPayload,
	        });
	    }
	    else {
	        // Successfully validate the signature only if it is within timestamp_tolerance_seconds tolerance
	        return true;
	    }
	};
	exports.verifyWebhookSignature = verifyWebhookSignature; 
} (helpers));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.verifyWebhookSignature = exports.deriveAddress = exports.getFingerprint = exports.parseAsset = exports.SignatureVerificationError = exports.BlockfrostServerError = exports.BlockfrostClientError = exports.BlockFrostIPFS = exports.BlockFrostAPI = void 0;
	const BlockFrostAPI_1 = BlockFrostAPI$1;
	Object.defineProperty(exports, "BlockFrostAPI", { enumerable: true, get: function () { return BlockFrostAPI_1.BlockFrostAPI; } });
	const BlockFrostIPFS_1 = BlockFrostIPFS$1;
	Object.defineProperty(exports, "BlockFrostIPFS", { enumerable: true, get: function () { return BlockFrostIPFS_1.BlockFrostIPFS; } });
	const helpers_1 = helpers;
	Object.defineProperty(exports, "deriveAddress", { enumerable: true, get: function () { return helpers_1.deriveAddress; } });
	Object.defineProperty(exports, "getFingerprint", { enumerable: true, get: function () { return helpers_1.getFingerprint; } });
	Object.defineProperty(exports, "parseAsset", { enumerable: true, get: function () { return helpers_1.parseAsset; } });
	Object.defineProperty(exports, "verifyWebhookSignature", { enumerable: true, get: function () { return helpers_1.verifyWebhookSignature; } });
	const errors_1 = errors$1;
	Object.defineProperty(exports, "BlockfrostClientError", { enumerable: true, get: function () { return errors_1.BlockfrostClientError; } });
	Object.defineProperty(exports, "BlockfrostServerError", { enumerable: true, get: function () { return errors_1.BlockfrostServerError; } });
	Object.defineProperty(exports, "SignatureVerificationError", { enumerable: true, get: function () { return errors_1.SignatureVerificationError; } }); 
} (lib$1));

var _Array = {};

var Apply = {};

var _function = {};

(function (exports) {
	var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.dual = exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
	// -------------------------------------------------------------------------------------
	// instances
	// -------------------------------------------------------------------------------------
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	var getBooleanAlgebra = function (B) {
	    return function () { return ({
	        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },
	        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },
	        zero: function () { return B.zero; },
	        one: function () { return B.one; },
	        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },
	        not: function (x) { return function (a) { return B.not(x(a)); }; }
	    }); };
	};
	exports.getBooleanAlgebra = getBooleanAlgebra;
	/**
	 * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.
	 *
	 * @example
	 * import { Predicate, getSemigroup } from 'fp-ts/function'
	 * import * as B from 'fp-ts/boolean'
	 *
	 * const f: Predicate<number> = (n) => n <= 2
	 * const g: Predicate<number> = (n) => n >= 0
	 *
	 * const S1 = getSemigroup(B.SemigroupAll)<number>()
	 *
	 * assert.deepStrictEqual(S1.concat(f, g)(1), true)
	 * assert.deepStrictEqual(S1.concat(f, g)(3), false)
	 *
	 * const S2 = getSemigroup(B.SemigroupAny)<number>()
	 *
	 * assert.deepStrictEqual(S2.concat(f, g)(1), true)
	 * assert.deepStrictEqual(S2.concat(f, g)(3), true)
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	var getSemigroup = function (S) {
	    return function () { return ({
	        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }
	    }); };
	};
	exports.getSemigroup = getSemigroup;
	/**
	 * Unary functions form a monoid as long as you can provide a monoid for the codomain.
	 *
	 * @example
	 * import { Predicate } from 'fp-ts/Predicate'
	 * import { getMonoid } from 'fp-ts/function'
	 * import * as B from 'fp-ts/boolean'
	 *
	 * const f: Predicate<number> = (n) => n <= 2
	 * const g: Predicate<number> = (n) => n >= 0
	 *
	 * const M1 = getMonoid(B.MonoidAll)<number>()
	 *
	 * assert.deepStrictEqual(M1.concat(f, g)(1), true)
	 * assert.deepStrictEqual(M1.concat(f, g)(3), false)
	 *
	 * const M2 = getMonoid(B.MonoidAny)<number>()
	 *
	 * assert.deepStrictEqual(M2.concat(f, g)(1), true)
	 * assert.deepStrictEqual(M2.concat(f, g)(3), true)
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	var getMonoid = function (M) {
	    var getSemigroupM = (0, exports.getSemigroup)(M);
	    return function () { return ({
	        concat: getSemigroupM().concat,
	        empty: function () { return M.empty; }
	    }); };
	};
	exports.getMonoid = getMonoid;
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	var getSemiring = function (S) { return ({
	    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },
	    zero: function () { return S.zero; },
	    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },
	    one: function () { return S.one; }
	}); };
	exports.getSemiring = getSemiring;
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	var getRing = function (R) {
	    var S = (0, exports.getSemiring)(R);
	    return {
	        add: S.add,
	        mul: S.mul,
	        one: S.one,
	        zero: S.zero,
	        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }
	    };
	};
	exports.getRing = getRing;
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * @since 2.11.0
	 */
	var apply = function (a) {
	    return function (f) {
	        return f(a);
	    };
	};
	exports.apply = apply;
	/**
	 * @since 2.0.0
	 */
	function identity(a) {
	    return a;
	}
	exports.identity = identity;
	/**
	 * @since 2.0.0
	 */
	exports.unsafeCoerce = identity;
	/**
	 * @since 2.0.0
	 */
	function constant(a) {
	    return function () { return a; };
	}
	exports.constant = constant;
	/**
	 * A thunk that returns always `true`.
	 *
	 * @since 2.0.0
	 */
	exports.constTrue = constant(true);
	/**
	 * A thunk that returns always `false`.
	 *
	 * @since 2.0.0
	 */
	exports.constFalse = constant(false);
	/**
	 * A thunk that returns always `null`.
	 *
	 * @since 2.0.0
	 */
	exports.constNull = constant(null);
	/**
	 * A thunk that returns always `undefined`.
	 *
	 * @since 2.0.0
	 */
	exports.constUndefined = constant(undefined);
	/**
	 * A thunk that returns always `void`.
	 *
	 * @since 2.0.0
	 */
	exports.constVoid = exports.constUndefined;
	function flip(f) {
	    return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (args.length > 1) {
	            return f(args[1], args[0]);
	        }
	        return function (a) { return f(a)(args[0]); };
	    };
	}
	exports.flip = flip;
	function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
	    switch (arguments.length) {
	        case 1:
	            return ab;
	        case 2:
	            return function () {
	                return bc(ab.apply(this, arguments));
	            };
	        case 3:
	            return function () {
	                return cd(bc(ab.apply(this, arguments)));
	            };
	        case 4:
	            return function () {
	                return de(cd(bc(ab.apply(this, arguments))));
	            };
	        case 5:
	            return function () {
	                return ef(de(cd(bc(ab.apply(this, arguments)))));
	            };
	        case 6:
	            return function () {
	                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
	            };
	        case 7:
	            return function () {
	                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
	            };
	        case 8:
	            return function () {
	                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
	            };
	        case 9:
	            return function () {
	                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
	            };
	    }
	    return;
	}
	exports.flow = flow;
	/**
	 * @since 2.0.0
	 */
	function tuple() {
	    var t = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        t[_i] = arguments[_i];
	    }
	    return t;
	}
	exports.tuple = tuple;
	/**
	 * @since 2.0.0
	 */
	function increment(n) {
	    return n + 1;
	}
	exports.increment = increment;
	/**
	 * @since 2.0.0
	 */
	function decrement(n) {
	    return n - 1;
	}
	exports.decrement = decrement;
	/**
	 * @since 2.0.0
	 */
	function absurd(_) {
	    throw new Error('Called `absurd` function which should be uncallable');
	}
	exports.absurd = absurd;
	/**
	 * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.
	 *
	 * @example
	 * import { tupled } from 'fp-ts/function'
	 *
	 * const add = tupled((x: number, y: number): number => x + y)
	 *
	 * assert.strictEqual(add([1, 2]), 3)
	 *
	 * @since 2.4.0
	 */
	function tupled(f) {
	    return function (a) { return f.apply(void 0, a); };
	}
	exports.tupled = tupled;
	/**
	 * Inverse function of `tupled`
	 *
	 * @since 2.4.0
	 */
	function untupled(f) {
	    return function () {
	        var a = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            a[_i] = arguments[_i];
	        }
	        return f(a);
	    };
	}
	exports.untupled = untupled;
	function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
	    switch (arguments.length) {
	        case 1:
	            return a;
	        case 2:
	            return ab(a);
	        case 3:
	            return bc(ab(a));
	        case 4:
	            return cd(bc(ab(a)));
	        case 5:
	            return de(cd(bc(ab(a))));
	        case 6:
	            return ef(de(cd(bc(ab(a)))));
	        case 7:
	            return fg(ef(de(cd(bc(ab(a))))));
	        case 8:
	            return gh(fg(ef(de(cd(bc(ab(a)))))));
	        case 9:
	            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
	        default: {
	            var ret = arguments[0];
	            for (var i = 1; i < arguments.length; i++) {
	                ret = arguments[i](ret);
	            }
	            return ret;
	        }
	    }
	}
	exports.pipe = pipe;
	/**
	 * Type hole simulation
	 *
	 * @since 2.7.0
	 */
	exports.hole = absurd;
	/**
	 * @since 2.11.0
	 */
	var SK = function (_, b) { return b; };
	exports.SK = SK;
	/**
	 * Use `Predicate` module instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	function not(predicate) {
	    return function (a) { return !predicate(a); };
	}
	exports.not = not;
	/**
	 * Use `Endomorphism` module instead.
	 *
	 * @category zone of death
	 * @since 2.10.0
	 * @deprecated
	 */
	var getEndomorphismMonoid = function () { return ({
	    concat: function (first, second) { return flow(first, second); },
	    empty: identity
	}); };
	exports.getEndomorphismMonoid = getEndomorphismMonoid;
	/** @internal */
	var dual = function (arity, body) {
	    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;
	    return function () {
	        var args = Array.from(arguments);
	        if (isDataFirst(arguments)) {
	            return body.apply(this, args);
	        }
	        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };
	    };
	};
	exports.dual = dual; 
} (_function));

var internal = {};

(function (exports) {
	var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
	var function_1 = _function;
	// -------------------------------------------------------------------------------------
	// Option
	// -------------------------------------------------------------------------------------
	/** @internal */
	var isNone = function (fa) { return fa._tag === 'None'; };
	exports.isNone = isNone;
	/** @internal */
	var isSome = function (fa) { return fa._tag === 'Some'; };
	exports.isSome = isSome;
	/** @internal */
	exports.none = { _tag: 'None' };
	/** @internal */
	var some = function (a) { return ({ _tag: 'Some', value: a }); };
	exports.some = some;
	// -------------------------------------------------------------------------------------
	// Either
	// -------------------------------------------------------------------------------------
	/** @internal */
	var isLeft = function (ma) { return ma._tag === 'Left'; };
	exports.isLeft = isLeft;
	/** @internal */
	var isRight = function (ma) { return ma._tag === 'Right'; };
	exports.isRight = isRight;
	/** @internal */
	var left = function (e) { return ({ _tag: 'Left', left: e }); };
	exports.left = left;
	/** @internal */
	var right = function (a) { return ({ _tag: 'Right', right: a }); };
	exports.right = right;
	// -------------------------------------------------------------------------------------
	// ReadonlyNonEmptyArray
	// -------------------------------------------------------------------------------------
	/** @internal */
	var singleton = function (a) { return [a]; };
	exports.singleton = singleton;
	/** @internal */
	var isNonEmpty = function (as) { return as.length > 0; };
	exports.isNonEmpty = isNonEmpty;
	/** @internal */
	var head = function (as) { return as[0]; };
	exports.head = head;
	/** @internal */
	var tail = function (as) { return as.slice(1); };
	exports.tail = tail;
	// -------------------------------------------------------------------------------------
	// empty
	// -------------------------------------------------------------------------------------
	/** @internal */
	exports.emptyReadonlyArray = [];
	/** @internal */
	exports.emptyRecord = {};
	// -------------------------------------------------------------------------------------
	// Record
	// -------------------------------------------------------------------------------------
	/** @internal */
	exports.has = Object.prototype.hasOwnProperty;
	// -------------------------------------------------------------------------------------
	// NonEmptyArray
	// -------------------------------------------------------------------------------------
	/** @internal */
	var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };
	exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;
	/** @internal */
	var liftNullable = function (F) {
	    return function (f, onNullable) {
	        return function () {
	            var a = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                a[_i] = arguments[_i];
	            }
	            var o = f.apply(void 0, a);
	            return F.fromEither(o == null ? (0, exports.left)(onNullable.apply(void 0, a)) : (0, exports.right)(o));
	        };
	    };
	};
	exports.liftNullable = liftNullable;
	/** @internal */
	var liftOption = function (F) {
	    return function (f, onNone) {
	        return function () {
	            var a = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                a[_i] = arguments[_i];
	            }
	            var o = f.apply(void 0, a);
	            return F.fromEither((0, exports.isNone)(o) ? (0, exports.left)(onNone.apply(void 0, a)) : (0, exports.right)(o.value));
	        };
	    };
	};
	exports.liftOption = liftOption;
	/** @internal */
	var flatMapNullable = function (F, M) {
	     return (0, function_1.dual)(3, function (self, f, onNullable) {
	        return M.flatMap(self, (0, exports.liftNullable)(F)(f, onNullable));
	    });
	};
	exports.flatMapNullable = flatMapNullable;
	/** @internal */
	var flatMapOption = function (F, M) {
	     return (0, function_1.dual)(3, function (self, f, onNone) { return M.flatMap(self, (0, exports.liftOption)(F)(f, onNone)); });
	};
	exports.flatMapOption = flatMapOption;
	/** @internal */
	var flatMapEither = function (F, M) {
	     return (0, function_1.dual)(2, function (self, f) {
	        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });
	    });
	};
	exports.flatMapEither = flatMapEither;
	/** @internal */
	var flatMapIO = function (F, M) {
	     return (0, function_1.dual)(2, function (self, f) {
	        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });
	    });
	};
	exports.flatMapIO = flatMapIO;
	/** @internal */
	var flatMapTask = function (F, M) {
	     return (0, function_1.dual)(2, function (self, f) {
	        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });
	    });
	};
	exports.flatMapTask = flatMapTask;
	/** @internal */
	var flatMapReader = function (F, M) {
	     return (0, function_1.dual)(2, function (self, f) {
	        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });
	    });
	};
	exports.flatMapReader = flatMapReader; 
} (internal));

var __createBinding$4 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$4 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$4 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$4(result, mod, k);
    __setModuleDefault$4(result, mod);
    return result;
};
Object.defineProperty(Apply, "__esModule", { value: true });
Apply.sequenceS = Apply.sequenceT = Apply.getApplySemigroup = Apply.apS = Apply.apSecond = Apply.apFirst = Apply.ap = void 0;
/**
 * The `Apply` class provides the `ap` which is used to apply a function to an argument under a type constructor.
 *
 * `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor
 * `f`.
 *
 * Instances must satisfy the following law in addition to the `Functor` laws:
 *
 * 1. Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`
 *
 * Formally, `Apply` represents a strong lax semi-monoidal endofunctor.
 *
 * @example
 * import * as O from 'fp-ts/Option'
 * import { pipe } from 'fp-ts/function'
 *
 * const f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)
 * const fa: O.Option<string> = O.some('s')
 * const fb: O.Option<number> = O.some(1)
 * const fc: O.Option<boolean> = O.some(true)
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     // lift a function
 *     O.some(f),
 *     // apply the first argument
 *     O.ap(fa),
 *     // apply the second argument
 *     O.ap(fb),
 *     // apply the third argument
 *     O.ap(fc)
 *   ),
 *   O.some('s1true')
 * )
 *
 * @since 2.0.0
 */
var function_1$8 = _function;
var _$2 = __importStar$4(internal);
function ap$1(F, G) {
    return function (fa) {
        return function (fab) {
            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);
        };
    };
}
Apply.ap = ap$1;
function apFirst(A) {
    return function (second) { return function (first) {
        return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);
    }; };
}
Apply.apFirst = apFirst;
function apSecond(A) {
    return function (second) {
        return function (first) {
            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);
        };
    };
}
Apply.apSecond = apSecond;
function apS(F) {
    return function (name, fb) {
        return function (fa) {
            return F.ap(F.map(fa, function (a) { return function (b) {
                var _a;
                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            }; }), fb);
        };
    };
}
Apply.apS = apS;
function getApplySemigroup(F) {
    return function (S) { return ({
        concat: function (first, second) {
            return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);
        }
    }); };
}
Apply.getApplySemigroup = getApplySemigroup;
function curried(f, n, acc) {
    return function (x) {
        var combined = Array(acc.length + 1);
        for (var i = 0; i < acc.length; i++) {
            combined[i] = acc[i];
        }
        combined[acc.length] = x;
        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
    };
}
var tupleConstructors = {
    1: function (a) { return [a]; },
    2: function (a) { return function (b) { return [a, b]; }; },
    3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },
    4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },
    5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }
};
function getTupleConstructor(len) {
    if (!_$2.has.call(tupleConstructors, len)) {
        tupleConstructors[len] = curried(function_1$8.tuple, len - 1, []);
    }
    return tupleConstructors[len];
}
function sequenceT(F) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var len = args.length;
        var f = getTupleConstructor(len);
        var fas = F.map(args[0], f);
        for (var i = 1; i < len; i++) {
            fas = F.ap(fas, args[i]);
        }
        return fas;
    };
}
Apply.sequenceT = sequenceT;
function getRecordConstructor(keys) {
    var len = keys.length;
    switch (len) {
        case 1:
            return function (a) {
                var _a;
                return (_a = {}, _a[keys[0]] = a, _a);
            };
        case 2:
            return function (a) { return function (b) {
                var _a;
                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);
            }; };
        case 3:
            return function (a) { return function (b) { return function (c) {
                var _a;
                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);
            }; }; };
        case 4:
            return function (a) { return function (b) { return function (c) { return function (d) {
                var _a;
                return (_a = {},
                    _a[keys[0]] = a,
                    _a[keys[1]] = b,
                    _a[keys[2]] = c,
                    _a[keys[3]] = d,
                    _a);
            }; }; }; };
        case 5:
            return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {
                var _a;
                return (_a = {},
                    _a[keys[0]] = a,
                    _a[keys[1]] = b,
                    _a[keys[2]] = c,
                    _a[keys[3]] = d,
                    _a[keys[4]] = e,
                    _a);
            }; }; }; }; };
        default:
            return curried(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var r = {};
                for (var i = 0; i < len; i++) {
                    r[keys[i]] = args[i];
                }
                return r;
            }, len - 1, []);
    }
}
function sequenceS(F) {
    return function (r) {
        var keys = Object.keys(r);
        var len = keys.length;
        var f = getRecordConstructor(keys);
        var fr = F.map(r[keys[0]], f);
        for (var i = 1; i < len; i++) {
            fr = F.ap(fr, r[keys[i]]);
        }
        return fr;
    };
}
Apply.sequenceS = sequenceS;

var Chain = {};

Object.defineProperty(Chain, "__esModule", { value: true });
Chain.bind = Chain.tap = Chain.chainFirst = void 0;
function chainFirst(M) {
    var tapM = tap(M);
    return function (f) { return function (first) { return tapM(first, f); }; };
}
Chain.chainFirst = chainFirst;
/** @internal */
function tap(M) {
    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };
}
Chain.tap = tap;
function bind(M) {
    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {
        var _a;
        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
    }); }); }; };
}
Chain.bind = bind;

var FromEither = {};

/**
 * The `FromEither` type class represents those data types which support errors.
 *
 * @since 2.10.0
 */
var __createBinding$3 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$3 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$3 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
    __setModuleDefault$3(result, mod);
    return result;
};
Object.defineProperty(FromEither, "__esModule", { value: true });
FromEither.tapEither = FromEither.filterOrElse = FromEither.chainFirstEitherK = FromEither.chainEitherK = FromEither.fromEitherK = FromEither.chainOptionK = FromEither.fromOptionK = FromEither.fromPredicate = FromEither.fromOption = void 0;
var Chain_1$2 = Chain;
var function_1$7 = _function;
var _$1 = __importStar$3(internal);
function fromOption(F) {
    return function (onNone) { return function (ma) { return F.fromEither(_$1.isNone(ma) ? _$1.left(onNone()) : _$1.right(ma.value)); }; };
}
FromEither.fromOption = fromOption;
function fromPredicate(F) {
    return function (predicate, onFalse) {
        return function (a) {
            return F.fromEither(predicate(a) ? _$1.right(a) : _$1.left(onFalse(a)));
        };
    };
}
FromEither.fromPredicate = fromPredicate;
function fromOptionK(F) {
    var fromOptionF = fromOption(F);
    return function (onNone) {
        var from = fromOptionF(onNone);
        return function (f) { return (0, function_1$7.flow)(f, from); };
    };
}
FromEither.fromOptionK = fromOptionK;
function chainOptionK(F, M) {
    var fromOptionKF = fromOptionK(F);
    return function (onNone) {
        var from = fromOptionKF(onNone);
        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };
    };
}
FromEither.chainOptionK = chainOptionK;
function fromEitherK(F) {
    return function (f) { return (0, function_1$7.flow)(f, F.fromEither); };
}
FromEither.fromEitherK = fromEitherK;
function chainEitherK(F, M) {
    var fromEitherKF = fromEitherK(F);
    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };
}
FromEither.chainEitherK = chainEitherK;
function chainFirstEitherK(F, M) {
    var tapEitherM = tapEither(F, M);
    return function (f) { return function (ma) { return tapEitherM(ma, f); }; };
}
FromEither.chainFirstEitherK = chainFirstEitherK;
function filterOrElse(F, M) {
    return function (predicate, onFalse) {
        return function (ma) {
            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _$1.right(a) : _$1.left(onFalse(a))); });
        };
    };
}
FromEither.filterOrElse = filterOrElse;
/** @internal */
function tapEither(F, M) {
    var fromEither = fromEitherK(F);
    var tapM = (0, Chain_1$2.tap)(M);
    return function (self, f) { return tapM(self, fromEither(f)); };
}
FromEither.tapEither = tapEither;

var Functor = {};

Object.defineProperty(Functor, "__esModule", { value: true });
Functor.asUnit = Functor.as = Functor.getFunctorComposition = Functor.let = Functor.bindTo = Functor.flap = Functor.map = void 0;
/**
 * A `Functor` is a type constructor which supports a mapping operation `map`.
 *
 * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type
 * constructor `f` to represent some computational context.
 *
 * Instances must satisfy the following laws:
 *
 * 1. Identity: `F.map(fa, a => a) <-> fa`
 * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`
 *
 * @since 2.0.0
 */
var function_1$6 = _function;
function map$1(F, G) {
    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };
}
Functor.map = map$1;
function flap(F) {
    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };
}
Functor.flap = flap;
function bindTo(F) {
    return function (name) { return function (fa) { return F.map(fa, function (a) {
        var _a;
        return (_a = {}, _a[name] = a, _a);
    }); }; };
}
Functor.bindTo = bindTo;
function let_(F) {
    return function (name, f) { return function (fa) { return F.map(fa, function (a) {
        var _a;
        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));
    }); }; };
}
Functor.let = let_;
/** @deprecated */
function getFunctorComposition(F, G) {
    var _map = map$1(F, G);
    return {
        map: function (fga, f) { return (0, function_1$6.pipe)(fga, _map(f)); }
    };
}
Functor.getFunctorComposition = getFunctorComposition;
/** @internal */
function as(F) {
    return function (self, b) { return F.map(self, function () { return b; }); };
}
Functor.as = as;
/** @internal */
function asUnit(F) {
    var asM = as(F);
    return function (self) { return asM(self, undefined); };
}
Functor.asUnit = asUnit;

var NonEmptyArray = {};

var Ord = {};

var Eq = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.eqDate = exports.eqNumber = exports.eqString = exports.eqBoolean = exports.eq = exports.strictEqual = exports.getStructEq = exports.getTupleEq = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.eqStrict = exports.URI = exports.contramap = exports.tuple = exports.struct = exports.fromEquals = void 0;
	var function_1 = _function;
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	var fromEquals = function (equals) { return ({
	    equals: function (x, y) { return x === y || equals(x, y); }
	}); };
	exports.fromEquals = fromEquals;
	// -------------------------------------------------------------------------------------
	// combinators
	// -------------------------------------------------------------------------------------
	/**
	 * @since 2.10.0
	 */
	var struct = function (eqs) {
	    return (0, exports.fromEquals)(function (first, second) {
	        for (var key in eqs) {
	            if (!eqs[key].equals(first[key], second[key])) {
	                return false;
	            }
	        }
	        return true;
	    });
	};
	exports.struct = struct;
	/**
	 * Given a tuple of `Eq`s returns a `Eq` for the tuple
	 *
	 * @example
	 * import { tuple } from 'fp-ts/Eq'
	 * import * as S from 'fp-ts/string'
	 * import * as N from 'fp-ts/number'
	 * import * as B from 'fp-ts/boolean'
	 *
	 * const E = tuple(S.Eq, N.Eq, B.Eq)
	 * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)
	 * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)
	 * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)
	 * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)
	 *
	 * @since 2.10.0
	 */
	var tuple = function () {
	    var eqs = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        eqs[_i] = arguments[_i];
	    }
	    return (0, exports.fromEquals)(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });
	};
	exports.tuple = tuple;
	/* istanbul ignore next */
	var contramap_ = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.contramap)(f)); };
	/**
	 * A typical use case for `contramap` would be like, given some `User` type, to construct an `Eq<User>`.
	 *
	 * We can do so with a function from `User -> X` where `X` is some value that we know how to compare
	 * for equality (meaning we have an `Eq<X>`)
	 *
	 * For example, given the following `User` type, we want to construct an `Eq<User>` that just looks at the `key` field
	 * for each user (since it's known to be unique).
	 *
	 * If we have a way of comparing `UUID`s for equality (`eqUUID: Eq<UUID>`) and we know how to go from `User -> UUID`,
	 * using `contramap` we can do this
	 *
	 * @example
	 * import { contramap, Eq } from 'fp-ts/Eq'
	 * import { pipe } from 'fp-ts/function'
	 * import * as S from 'fp-ts/string'
	 *
	 * type UUID = string
	 *
	 * interface User {
	 *   readonly key: UUID
	 *   readonly firstName: string
	 *   readonly lastName: string
	 * }
	 *
	 * const eqUUID: Eq<UUID> = S.Eq
	 *
	 * const eqUserByKey: Eq<User> = pipe(
	 *   eqUUID,
	 *   contramap((user) => user.key)
	 * )
	 *
	 * assert.deepStrictEqual(
	 *   eqUserByKey.equals(
	 *     { key: 'k1', firstName: 'a1', lastName: 'b1' },
	 *     { key: 'k2', firstName: 'a1', lastName: 'b1' }
	 *   ),
	 *   false
	 * )
	 * assert.deepStrictEqual(
	 *   eqUserByKey.equals(
	 *     { key: 'k1', firstName: 'a1', lastName: 'b1' },
	 *     { key: 'k1', firstName: 'a2', lastName: 'b1' }
	 *   ),
	 *   true
	 * )
	 *
	 * @since 2.0.0
	 */
	var contramap = function (f) { return function (fa) {
	    return (0, exports.fromEquals)(function (x, y) { return fa.equals(f(x), f(y)); });
	}; };
	exports.contramap = contramap;
	/**
	 * @category type lambdas
	 * @since 2.0.0
	 */
	exports.URI = 'Eq';
	/**
	 * @category instances
	 * @since 2.5.0
	 */
	exports.eqStrict = {
	    equals: function (a, b) { return a === b; }
	};
	var empty = {
	    equals: function () { return true; }
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	var getSemigroup = function () { return ({
	    concat: function (x, y) { return (0, exports.fromEquals)(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }
	}); };
	exports.getSemigroup = getSemigroup;
	/**
	 * @category instances
	 * @since 2.6.0
	 */
	var getMonoid = function () { return ({
	    concat: (0, exports.getSemigroup)().concat,
	    empty: empty
	}); };
	exports.getMonoid = getMonoid;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Contravariant = {
	    URI: exports.URI,
	    contramap: contramap_
	};
	// -------------------------------------------------------------------------------------
	// deprecated
	// -------------------------------------------------------------------------------------
	/**
	 * Use [`tuple`](#tuple) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getTupleEq = exports.tuple;
	/**
	 * Use [`struct`](#struct) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getStructEq = exports.struct;
	/**
	 * Use [`eqStrict`](#eqstrict) instead
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.strictEqual = exports.eqStrict.equals;
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Contravariant` instance, pass `E.Contravariant` instead of `E.eq`
	 * (where `E` is from `import E from 'fp-ts/Eq'`)
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.eq = exports.Contravariant;
	/**
	 * Use [`Eq`](./boolean.ts.html#eq) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.eqBoolean = exports.eqStrict;
	/**
	 * Use [`Eq`](./string.ts.html#eq) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.eqString = exports.eqStrict;
	/**
	 * Use [`Eq`](./number.ts.html#eq) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.eqNumber = exports.eqStrict;
	/**
	 * Use [`Eq`](./Date.ts.html#eq) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.eqDate = {
	    equals: function (first, second) { return first.valueOf() === second.valueOf(); }
	}; 
} (Eq));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ordDate = exports.ordNumber = exports.ordString = exports.ordBoolean = exports.ord = exports.getDualOrd = exports.getTupleOrd = exports.between = exports.clamp = exports.max = exports.min = exports.geq = exports.leq = exports.gt = exports.lt = exports.equals = exports.trivial = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.URI = exports.contramap = exports.reverse = exports.tuple = exports.fromCompare = exports.equalsDefault = void 0;
	var Eq_1 = Eq;
	var function_1 = _function;
	// -------------------------------------------------------------------------------------
	// defaults
	// -------------------------------------------------------------------------------------
	/**
	 * @category defaults
	 * @since 2.10.0
	 */
	var equalsDefault = function (compare) {
	    return function (first, second) {
	        return first === second || compare(first, second) === 0;
	    };
	};
	exports.equalsDefault = equalsDefault;
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	var fromCompare = function (compare) { return ({
	    equals: (0, exports.equalsDefault)(compare),
	    compare: function (first, second) { return (first === second ? 0 : compare(first, second)); }
	}); };
	exports.fromCompare = fromCompare;
	// -------------------------------------------------------------------------------------
	// combinators
	// -------------------------------------------------------------------------------------
	/**
	 * Given a tuple of `Ord`s returns an `Ord` for the tuple.
	 *
	 * @example
	 * import { tuple } from 'fp-ts/Ord'
	 * import * as B from 'fp-ts/boolean'
	 * import * as S from 'fp-ts/string'
	 * import * as N from 'fp-ts/number'
	 *
	 * const O = tuple(S.Ord, N.Ord, B.Ord)
	 * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)
	 * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)
	 * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)
	 *
	 * @since 2.10.0
	 */
	var tuple = function () {
	    var ords = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        ords[_i] = arguments[_i];
	    }
	    return (0, exports.fromCompare)(function (first, second) {
	        var i = 0;
	        for (; i < ords.length - 1; i++) {
	            var r = ords[i].compare(first[i], second[i]);
	            if (r !== 0) {
	                return r;
	            }
	        }
	        return ords[i].compare(first[i], second[i]);
	    });
	};
	exports.tuple = tuple;
	/**
	 * @since 2.10.0
	 */
	var reverse = function (O) { return (0, exports.fromCompare)(function (first, second) { return O.compare(second, first); }); };
	exports.reverse = reverse;
	/* istanbul ignore next */
	var contramap_ = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.contramap)(f)); };
	/**
	 * A typical use case for `contramap` would be like, given some `User` type, to construct an `Ord<User>`.
	 *
	 * We can do so with a function from `User -> X` where `X` is some value that we know how to compare
	 * for ordering (meaning we have an `Ord<X>`)
	 *
	 * For example, given the following `User` type, there are lots of possible choices for `X`,
	 * but let's say we want to sort a list of users by `lastName`.
	 *
	 * If we have a way of comparing `lastName`s for ordering (`ordLastName: Ord<string>`) and we know how to go from `User -> string`,
	 * using `contramap` we can do this
	 *
	 * @example
	 * import { pipe } from 'fp-ts/function'
	 * import { contramap, Ord } from 'fp-ts/Ord'
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import * as S from 'fp-ts/string'
	 *
	 * interface User {
	 *   readonly firstName: string
	 *   readonly lastName: string
	 * }
	 *
	 * const ordLastName: Ord<string> = S.Ord
	 *
	 * const ordByLastName: Ord<User> = pipe(
	 *   ordLastName,
	 *   contramap((user) => user.lastName)
	 * )
	 *
	 * assert.deepStrictEqual(
	 *   RA.sort(ordByLastName)([
	 *     { firstName: 'a', lastName: 'd' },
	 *     { firstName: 'c', lastName: 'b' }
	 *   ]),
	 *   [
	 *     { firstName: 'c', lastName: 'b' },
	 *     { firstName: 'a', lastName: 'd' }
	 *   ]
	 * )
	 *
	 * @since 2.0.0
	 */
	var contramap = function (f) { return function (fa) {
	    return (0, exports.fromCompare)(function (first, second) { return fa.compare(f(first), f(second)); });
	}; };
	exports.contramap = contramap;
	/**
	 * @category type lambdas
	 * @since 2.0.0
	 */
	exports.URI = 'Ord';
	/**
	 * A typical use case for the `Semigroup` instance of `Ord` is merging two or more orderings.
	 *
	 * For example the following snippet builds an `Ord` for a type `User` which
	 * sorts by `created` date descending, and **then** `lastName`
	 *
	 * @example
	 * import * as D from 'fp-ts/Date'
	 * import { pipe } from 'fp-ts/function'
	 * import { contramap, getSemigroup, Ord, reverse } from 'fp-ts/Ord'
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import * as S from 'fp-ts/string'
	 *
	 * interface User {
	 *   readonly id: string
	 *   readonly lastName: string
	 *   readonly created: Date
	 * }
	 *
	 * const ordByLastName: Ord<User> = pipe(
	 *   S.Ord,
	 *   contramap((user) => user.lastName)
	 * )
	 *
	 * const ordByCreated: Ord<User> = pipe(
	 *   D.Ord,
	 *   contramap((user) => user.created)
	 * )
	 *
	 * const ordUserByCreatedDescThenLastName = getSemigroup<User>().concat(
	 *   reverse(ordByCreated),
	 *   ordByLastName
	 * )
	 *
	 * assert.deepStrictEqual(
	 *   RA.sort(ordUserByCreatedDescThenLastName)([
	 *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) },
	 *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },
	 *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) }
	 *   ]),
	 *   [
	 *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) },
	 *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },
	 *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) }
	 *   ]
	 * )
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	var getSemigroup = function () { return ({
	    concat: function (first, second) {
	        return (0, exports.fromCompare)(function (a, b) {
	            var ox = first.compare(a, b);
	            return ox !== 0 ? ox : second.compare(a, b);
	        });
	    }
	}); };
	exports.getSemigroup = getSemigroup;
	/**
	 * Returns a `Monoid` such that:
	 *
	 * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`
	 * - its `empty` value is an `Ord` that always considers compared elements equal
	 *
	 * @example
	 * import { sort } from 'fp-ts/Array'
	 * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'
	 * import * as S from 'fp-ts/string'
	 * import * as B from 'fp-ts/boolean'
	 * import { pipe } from 'fp-ts/function'
	 * import { concatAll } from 'fp-ts/Monoid'
	 * import * as N from 'fp-ts/number'
	 *
	 * interface User {
	 *   readonly id: number
	 *   readonly name: string
	 *   readonly age: number
	 *   readonly rememberMe: boolean
	 * }
	 *
	 * const byName = pipe(
	 *   S.Ord,
	 *   contramap((p: User) => p.name)
	 * )
	 *
	 * const byAge = pipe(
	 *   N.Ord,
	 *   contramap((p: User) => p.age)
	 * )
	 *
	 * const byRememberMe = pipe(
	 *   B.Ord,
	 *   contramap((p: User) => p.rememberMe)
	 * )
	 *
	 * const M = getMonoid<User>()
	 *
	 * const users: Array<User> = [
	 *   { id: 1, name: 'Guido', age: 47, rememberMe: false },
	 *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
	 *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
	 *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }
	 * ]
	 *
	 * // sort by name, then by age, then by `rememberMe`
	 * const O1 = concatAll(M)([byName, byAge, byRememberMe])
	 * assert.deepStrictEqual(sort(O1)(users), [
	 *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
	 *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },
	 *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
	 *   { id: 1, name: 'Guido', age: 47, rememberMe: false }
	 * ])
	 *
	 * // now `rememberMe = true` first, then by name, then by age
	 * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])
	 * assert.deepStrictEqual(sort(O2)(users), [
	 *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },
	 *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
	 *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
	 *   { id: 1, name: 'Guido', age: 47, rememberMe: false }
	 * ])
	 *
	 * @category instances
	 * @since 2.4.0
	 */
	var getMonoid = function () { return ({
	    concat: (0, exports.getSemigroup)().concat,
	    empty: (0, exports.fromCompare)(function () { return 0; })
	}); };
	exports.getMonoid = getMonoid;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Contravariant = {
	    URI: exports.URI,
	    contramap: contramap_
	};
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * @since 2.11.0
	 */
	exports.trivial = {
	    equals: function_1.constTrue,
	    compare: /*#__PURE__*/ (0, function_1.constant)(0)
	};
	/**
	 * @since 2.11.0
	 */
	var equals = function (O) {
	    return function (second) {
	        return function (first) {
	            return first === second || O.compare(first, second) === 0;
	        };
	    };
	};
	exports.equals = equals;
	// TODO: curry in v3
	/**
	 * Test whether one value is _strictly less than_ another
	 *
	 * @since 2.0.0
	 */
	var lt = function (O) {
	    return function (first, second) {
	        return O.compare(first, second) === -1;
	    };
	};
	exports.lt = lt;
	// TODO: curry in v3
	/**
	 * Test whether one value is _strictly greater than_ another
	 *
	 * @since 2.0.0
	 */
	var gt = function (O) {
	    return function (first, second) {
	        return O.compare(first, second) === 1;
	    };
	};
	exports.gt = gt;
	// TODO: curry in v3
	/**
	 * Test whether one value is _non-strictly less than_ another
	 *
	 * @since 2.0.0
	 */
	var leq = function (O) {
	    return function (first, second) {
	        return O.compare(first, second) !== 1;
	    };
	};
	exports.leq = leq;
	// TODO: curry in v3
	/**
	 * Test whether one value is _non-strictly greater than_ another
	 *
	 * @since 2.0.0
	 */
	var geq = function (O) {
	    return function (first, second) {
	        return O.compare(first, second) !== -1;
	    };
	};
	exports.geq = geq;
	// TODO: curry in v3
	/**
	 * Take the minimum of two values. If they are considered equal, the first argument is chosen
	 *
	 * @since 2.0.0
	 */
	var min = function (O) {
	    return function (first, second) {
	        return first === second || O.compare(first, second) < 1 ? first : second;
	    };
	};
	exports.min = min;
	// TODO: curry in v3
	/**
	 * Take the maximum of two values. If they are considered equal, the first argument is chosen
	 *
	 * @since 2.0.0
	 */
	var max = function (O) {
	    return function (first, second) {
	        return first === second || O.compare(first, second) > -1 ? first : second;
	    };
	};
	exports.max = max;
	/**
	 * Clamp a value between a minimum and a maximum
	 *
	 * @since 2.0.0
	 */
	var clamp = function (O) {
	    var minO = (0, exports.min)(O);
	    var maxO = (0, exports.max)(O);
	    return function (low, hi) { return function (a) { return maxO(minO(a, hi), low); }; };
	};
	exports.clamp = clamp;
	/**
	 * Test whether a value is between a minimum and a maximum (inclusive)
	 *
	 * @since 2.0.0
	 */
	var between = function (O) {
	    var ltO = (0, exports.lt)(O);
	    var gtO = (0, exports.gt)(O);
	    return function (low, hi) { return function (a) { return ltO(a, low) || gtO(a, hi) ? false : true; }; };
	};
	exports.between = between;
	// -------------------------------------------------------------------------------------
	// deprecated
	// -------------------------------------------------------------------------------------
	/**
	 * Use [`tuple`](#tuple) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getTupleOrd = exports.tuple;
	/**
	 * Use [`reverse`](#reverse) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getDualOrd = exports.reverse;
	/**
	 * Use [`Contravariant`](#contravariant) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.ord = exports.Contravariant;
	// default compare for primitive types
	function compare(first, second) {
	    return first < second ? -1 : first > second ? 1 : 0;
	}
	var strictOrd = {
	    equals: Eq_1.eqStrict.equals,
	    compare: compare
	};
	/**
	 * Use [`Ord`](./boolean.ts.html#ord) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.ordBoolean = strictOrd;
	/**
	 * Use [`Ord`](./string.ts.html#ord) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.ordString = strictOrd;
	/**
	 * Use [`Ord`](./number.ts.html#ord) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.ordNumber = strictOrd;
	/**
	 * Use [`Ord`](./Date.ts.html#ord) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.ordDate = (0, function_1.pipe)(exports.ordNumber, 
	/*#__PURE__*/
	(0, exports.contramap)(function (date) { return date.valueOf(); })); 
} (Ord));

var ReadonlyNonEmptyArray = {};

var Semigroup = {};

var Magma = {};

/**
 * A `Magma` is a pair `(A, concat)` in which `A` is a non-empty set and `concat` is a binary operation on `A`
 *
 * See [Semigroup](https://gcanti.github.io/fp-ts/modules/Semigroup.ts.html) for some instances.
 *
 * @since 2.0.0
 */
Object.defineProperty(Magma, "__esModule", { value: true });
Magma.concatAll = Magma.endo = Magma.filterSecond = Magma.filterFirst = Magma.reverse = void 0;
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * The dual of a `Magma`, obtained by swapping the arguments of `concat`.
 *
 * @example
 * import { reverse, concatAll } from 'fp-ts/Magma'
 * import * as N from 'fp-ts/number'
 *
 * const subAll = concatAll(reverse(N.MagmaSub))(0)
 *
 * assert.deepStrictEqual(subAll([1, 2, 3]), 2)
 *
 * @since 2.11.0
 */
var reverse = function (M) { return ({
    concat: function (first, second) { return M.concat(second, first); }
}); };
Magma.reverse = reverse;
/**
 * @since 2.11.0
 */
var filterFirst = function (predicate) {
    return function (M) { return ({
        concat: function (first, second) { return (predicate(first) ? M.concat(first, second) : second); }
    }); };
};
Magma.filterFirst = filterFirst;
/**
 * @since 2.11.0
 */
var filterSecond = function (predicate) {
    return function (M) { return ({
        concat: function (first, second) { return (predicate(second) ? M.concat(first, second) : first); }
    }); };
};
Magma.filterSecond = filterSecond;
/**
 * @since 2.11.0
 */
var endo = function (f) {
    return function (M) { return ({
        concat: function (first, second) { return M.concat(f(first), f(second)); }
    }); };
};
Magma.endo = endo;
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * Given a sequence of `as`, concat them and return the total.
 *
 * If `as` is empty, return the provided `startWith` value.
 *
 * @example
 * import { concatAll } from 'fp-ts/Magma'
 * import * as N from 'fp-ts/number'
 *
 * const subAll = concatAll(N.MagmaSub)(0)
 *
 * assert.deepStrictEqual(subAll([1, 2, 3]), -6)
 *
 * @since 2.11.0
 */
var concatAll = function (M) {
    return function (startWith) {
        return function (as) {
            return as.reduce(function (a, acc) { return M.concat(a, acc); }, startWith);
        };
    };
};
Magma.concatAll = concatAll;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.semigroupProduct = exports.semigroupSum = exports.semigroupString = exports.getFunctionSemigroup = exports.semigroupAny = exports.semigroupAll = exports.fold = exports.getIntercalateSemigroup = exports.getMeetSemigroup = exports.getJoinSemigroup = exports.getDualSemigroup = exports.getStructSemigroup = exports.getTupleSemigroup = exports.getFirstSemigroup = exports.getLastSemigroup = exports.getObjectSemigroup = exports.semigroupVoid = exports.concatAll = exports.last = exports.first = exports.intercalate = exports.tuple = exports.struct = exports.reverse = exports.constant = exports.max = exports.min = void 0;
	/**
	 * If a type `A` can form a `Semigroup` it has an **associative** binary operation.
	 *
	 * ```ts
	 * interface Semigroup<A> {
	 *   readonly concat: (x: A, y: A) => A
	 * }
	 * ```
	 *
	 * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.
	 *
	 * ```ts
	 * concat(x, concat(y, z)) = concat(concat(x, y), z)
	 * ```
	 *
	 * A common example of a semigroup is the type `string` with the operation `+`.
	 *
	 * ```ts
	 * import { Semigroup } from 'fp-ts/Semigroup'
	 *
	 * const semigroupString: Semigroup<string> = {
	 *   concat: (x, y) => x + y
	 * }
	 *
	 * const x = 'x'
	 * const y = 'y'
	 * const z = 'z'
	 *
	 * semigroupString.concat(x, y) // 'xy'
	 *
	 * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'
	 *
	 * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'
	 * ```
	 *
	 * *Adapted from https://typelevel.org/cats*
	 *
	 * @since 2.0.0
	 */
	var function_1 = _function;
	var _ = __importStar(internal);
	var M = __importStar(Magma);
	var Or = __importStar(Ord);
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * Get a semigroup where `concat` will return the minimum, based on the provided order.
	 *
	 * @example
	 * import * as N from 'fp-ts/number'
	 * import * as S from 'fp-ts/Semigroup'
	 *
	 * const S1 = S.min(N.Ord)
	 *
	 * assert.deepStrictEqual(S1.concat(1, 2), 1)
	 *
	 * @category constructors
	 * @since 2.10.0
	 */
	var min = function (O) { return ({
	    concat: Or.min(O)
	}); };
	exports.min = min;
	/**
	 * Get a semigroup where `concat` will return the maximum, based on the provided order.
	 *
	 * @example
	 * import * as N from 'fp-ts/number'
	 * import * as S from 'fp-ts/Semigroup'
	 *
	 * const S1 = S.max(N.Ord)
	 *
	 * assert.deepStrictEqual(S1.concat(1, 2), 2)
	 *
	 * @category constructors
	 * @since 2.10.0
	 */
	var max = function (O) { return ({
	    concat: Or.max(O)
	}); };
	exports.max = max;
	/**
	 * @category constructors
	 * @since 2.10.0
	 */
	var constant = function (a) { return ({
	    concat: function () { return a; }
	}); };
	exports.constant = constant;
	// -------------------------------------------------------------------------------------
	// combinators
	// -------------------------------------------------------------------------------------
	/**
	 * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.
	 *
	 * @example
	 * import { reverse } from 'fp-ts/Semigroup'
	 * import * as S from 'fp-ts/string'
	 *
	 * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')
	 *
	 * @since 2.10.0
	 */
	exports.reverse = M.reverse;
	/**
	 * Given a struct of semigroups returns a semigroup for the struct.
	 *
	 * @example
	 * import { struct } from 'fp-ts/Semigroup'
	 * import * as N from 'fp-ts/number'
	 *
	 * interface Point {
	 *   readonly x: number
	 *   readonly y: number
	 * }
	 *
	 * const S = struct<Point>({
	 *   x: N.SemigroupSum,
	 *   y: N.SemigroupSum
	 * })
	 *
	 * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })
	 *
	 * @since 2.10.0
	 */
	var struct = function (semigroups) { return ({
	    concat: function (first, second) {
	        var r = {};
	        for (var k in semigroups) {
	            if (_.has.call(semigroups, k)) {
	                r[k] = semigroups[k].concat(first[k], second[k]);
	            }
	        }
	        return r;
	    }
	}); };
	exports.struct = struct;
	/**
	 * Given a tuple of semigroups returns a semigroup for the tuple.
	 *
	 * @example
	 * import { tuple } from 'fp-ts/Semigroup'
	 * import * as B from 'fp-ts/boolean'
	 * import * as N from 'fp-ts/number'
	 * import * as S from 'fp-ts/string'
	 *
	 * const S1 = tuple(S.Semigroup, N.SemigroupSum)
	 * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])
	 *
	 * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)
	 * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])
	 *
	 * @since 2.10.0
	 */
	var tuple = function () {
	    var semigroups = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        semigroups[_i] = arguments[_i];
	    }
	    return ({
	        concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }
	    });
	};
	exports.tuple = tuple;
	/**
	 * Between each pair of elements insert `middle`.
	 *
	 * @example
	 * import { intercalate } from 'fp-ts/Semigroup'
	 * import * as S from 'fp-ts/string'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const S1 = pipe(S.Semigroup, intercalate(' + '))
	 *
	 * assert.strictEqual(S1.concat('a', 'b'), 'a + b')
	 *
	 * @since 2.10.0
	 */
	var intercalate = function (middle) {
	    return function (S) { return ({
	        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }
	    }); };
	};
	exports.intercalate = intercalate;
	// -------------------------------------------------------------------------------------
	// instances
	// -------------------------------------------------------------------------------------
	/**
	 * Always return the first argument.
	 *
	 * @example
	 * import * as S from 'fp-ts/Semigroup'
	 *
	 * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	var first = function () { return ({ concat: function_1.identity }); };
	exports.first = first;
	/**
	 * Always return the last argument.
	 *
	 * @example
	 * import * as S from 'fp-ts/Semigroup'
	 *
	 * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	var last = function () { return ({ concat: function (_, y) { return y; } }); };
	exports.last = last;
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * Given a sequence of `as`, concat them and return the total.
	 *
	 * If `as` is empty, return the provided `startWith` value.
	 *
	 * @example
	 * import { concatAll } from 'fp-ts/Semigroup'
	 * import * as N from 'fp-ts/number'
	 *
	 * const sum = concatAll(N.SemigroupSum)(0)
	 *
	 * assert.deepStrictEqual(sum([1, 2, 3]), 6)
	 * assert.deepStrictEqual(sum([]), 0)
	 *
	 * @since 2.10.0
	 */
	exports.concatAll = M.concatAll;
	// -------------------------------------------------------------------------------------
	// deprecated
	// -------------------------------------------------------------------------------------
	/**
	 * Use `void` module instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.semigroupVoid = (0, exports.constant)(undefined);
	/**
	 * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	var getObjectSemigroup = function () { return ({
	    concat: function (first, second) { return Object.assign({}, first, second); }
	}); };
	exports.getObjectSemigroup = getObjectSemigroup;
	/**
	 * Use [`last`](#last) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getLastSemigroup = exports.last;
	/**
	 * Use [`first`](#first) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getFirstSemigroup = exports.first;
	/**
	 * Use [`tuple`](#tuple) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getTupleSemigroup = exports.tuple;
	/**
	 * Use [`struct`](#struct) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getStructSemigroup = exports.struct;
	/**
	 * Use [`reverse`](#reverse) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getDualSemigroup = exports.reverse;
	/**
	 * Use [`max`](#max) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getJoinSemigroup = exports.max;
	/**
	 * Use [`min`](#min) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getMeetSemigroup = exports.min;
	/**
	 * Use [`intercalate`](#intercalate) instead.
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	exports.getIntercalateSemigroup = exports.intercalate;
	function fold(S) {
	    var concatAllS = (0, exports.concatAll)(S);
	    return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };
	}
	exports.fold = fold;
	/**
	 * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.semigroupAll = {
	    concat: function (x, y) { return x && y; }
	};
	/**
	 * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.semigroupAny = {
	    concat: function (x, y) { return x || y; }
	};
	/**
	 * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getFunctionSemigroup = function_1.getSemigroup;
	/**
	 * Use [`Semigroup`](./string.ts.html#Semigroup) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.semigroupString = {
	    concat: function (x, y) { return x + y; }
	};
	/**
	 * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.semigroupSum = {
	    concat: function (x, y) { return x + y; }
	};
	/**
	 * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.semigroupProduct = {
	    concat: function (x, y) { return x * y; }
	}; 
} (Semigroup));

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.reduceRight = exports.foldMap = exports.reduce = exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.flatMap = exports.ap = exports.alt = exports.altW = exports.of = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.modifyAt = exports.updateAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.fromArray = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromReadonlyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = exports.empty = void 0;
	exports.groupSort = exports.chain = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = void 0;
	exports.readonlyNonEmptyArray = exports.fold = exports.prependToAll = exports.insertAt = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = exports.filterWithIndex = exports.filter = void 0;
	var Apply_1 = Apply;
	var Chain_1 = Chain;
	var Eq_1 = Eq;
	var function_1 = _function;
	var Functor_1 = Functor;
	var _ = __importStar(internal);
	var Ord_1 = Ord;
	var Se = __importStar(Semigroup);
	// -------------------------------------------------------------------------------------
	// internal
	// -------------------------------------------------------------------------------------
	/**
	 * @internal
	 */
	exports.empty = _.emptyReadonlyArray;
	/**
	 * @internal
	 */
	exports.isNonEmpty = _.isNonEmpty;
	/**
	 * @internal
	 */
	var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };
	exports.isOutOfBound = isOutOfBound;
	/**
	 * @internal
	 */
	var prependW = function (head) {
	    return function (tail) {
	        return __spreadArray([head], tail, true);
	    };
	};
	exports.prependW = prependW;
	/**
	 * @internal
	 */
	exports.prepend = exports.prependW;
	/**
	 * @internal
	 */
	var appendW = function (end) {
	    return function (init) {
	        return __spreadArray(__spreadArray([], init, true), [end], false);
	    };
	};
	exports.appendW = appendW;
	/**
	 * @internal
	 */
	exports.append = exports.appendW;
	/**
	 * @internal
	 */
	var unsafeInsertAt = function (i, a, as) {
	    if ((0, exports.isNonEmpty)(as)) {
	        var xs = _.fromReadonlyNonEmptyArray(as);
	        xs.splice(i, 0, a);
	        return xs;
	    }
	    return [a];
	};
	exports.unsafeInsertAt = unsafeInsertAt;
	/**
	 * @internal
	 */
	var unsafeUpdateAt = function (i, a, as) {
	    if (as[i] === a) {
	        return as;
	    }
	    else {
	        var xs = _.fromReadonlyNonEmptyArray(as);
	        xs[i] = a;
	        return xs;
	    }
	};
	exports.unsafeUpdateAt = unsafeUpdateAt;
	/**
	 * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.
	 *
	 * @example
	 * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'
	 * import * as N from 'fp-ts/number'
	 *
	 * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
	 *
	 * @since 2.11.0
	 */
	var uniq = function (E) {
	    return function (as) {
	        if (as.length === 1) {
	            return as;
	        }
	        var out = [(0, exports.head)(as)];
	        var rest = (0, exports.tail)(as);
	        var _loop_1 = function (a) {
	            if (out.every(function (o) { return !E.equals(o, a); })) {
	                out.push(a);
	            }
	        };
	        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
	            var a = rest_1[_i];
	            _loop_1(a);
	        }
	        return out;
	    };
	};
	exports.uniq = uniq;
	/**
	 * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
	 * etc...
	 *
	 * @example
	 * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
	 * import { contramap } from 'fp-ts/Ord'
	 * import * as S from 'fp-ts/string'
	 * import * as N from 'fp-ts/number'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * interface Person {
	 *   name: string
	 *   age: number
	 * }
	 *
	 * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
	 *
	 * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
	 *
	 * const sortByNameByAge = RNEA.sortBy([byName, byAge])
	 *
	 * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [
	 *   { name: 'a', age: 1 },
	 *   { name: 'b', age: 3 },
	 *   { name: 'c', age: 2 },
	 *   { name: 'b', age: 2 }
	 * ]
	 *
	 * assert.deepStrictEqual(sortByNameByAge(persons), [
	 *   { name: 'a', age: 1 },
	 *   { name: 'b', age: 2 },
	 *   { name: 'b', age: 3 },
	 *   { name: 'c', age: 2 }
	 * ])
	 *
	 * @since 2.11.0
	 */
	var sortBy = function (ords) {
	    if ((0, exports.isNonEmpty)(ords)) {
	        var M = (0, Ord_1.getMonoid)();
	        return (0, exports.sort)(ords.reduce(M.concat, M.empty));
	    }
	    return function_1.identity;
	};
	exports.sortBy = sortBy;
	/**
	 * @since 2.11.0
	 */
	var union = function (E) {
	    var uniqE = (0, exports.uniq)(E);
	    return function (second) { return function (first) { return uniqE((0, function_1.pipe)(first, concat(second))); }; };
	};
	exports.union = union;
	/**
	 * Rotate a `ReadonlyNonEmptyArray` by `n` steps.
	 *
	 * @example
	 * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'
	 *
	 * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
	 * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])
	 *
	 * @since 2.11.0
	 */
	var rotate = function (n) {
	    return function (as) {
	        var len = as.length;
	        var m = Math.round(n) % len;
	        if ((0, exports.isOutOfBound)(Math.abs(m), as) || m === 0) {
	            return as;
	        }
	        if (m < 0) {
	            var _a = (0, exports.splitAt)(-m)(as), f = _a[0], s = _a[1];
	            return (0, function_1.pipe)(s, concat(f));
	        }
	        else {
	            return (0, exports.rotate)(m - len)(as);
	        }
	    };
	};
	exports.rotate = rotate;
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.
	 *
	 * @category conversions
	 * @since 2.5.0
	 */
	var fromReadonlyArray = function (as) {
	    return (0, exports.isNonEmpty)(as) ? _.some(as) : _.none;
	};
	exports.fromReadonlyArray = fromReadonlyArray;
	/**
	 * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.
	 *
	 * **Note**. `n` is normalized to a natural number.
	 *
	 * @example
	 * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const double = (n: number): number => n * 2
	 * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])
	 *
	 * @category constructors
	 * @since 2.11.0
	 */
	var makeBy = function (f) {
	    return function (n) {
	        var j = Math.max(0, Math.floor(n));
	        var out = [f(0)];
	        for (var i = 1; i < j; i++) {
	            out.push(f(i));
	        }
	        return out;
	    };
	};
	exports.makeBy = makeBy;
	/**
	 * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.
	 *
	 * **Note**. `n` is normalized to a natural number.
	 *
	 * @example
	 * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])
	 *
	 * @category constructors
	 * @since 2.11.0
	 */
	var replicate = function (a) { return (0, exports.makeBy)(function () { return a; }); };
	exports.replicate = replicate;
	/**
	 * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.
	 *
	 * @example
	 * import { range } from 'fp-ts/ReadonlyNonEmptyArray'
	 *
	 * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])
	 *
	 * @category constructors
	 * @since 2.11.0
	 */
	var range = function (start, end) {
	    return start <= end ? (0, exports.makeBy)(function (i) { return start + i; })(end - start + 1) : [start];
	};
	exports.range = range;
	/**
	 * Return the tuple of the `head` and the `tail`.
	 *
	 * @example
	 * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'
	 *
	 * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])
	 *
	 * @since 2.9.0
	 */
	var unprepend = function (as) { return [(0, exports.head)(as), (0, exports.tail)(as)]; };
	exports.unprepend = unprepend;
	/**
	 * Return the tuple of the `init` and the `last`.
	 *
	 * @example
	 * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'
	 *
	 * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])
	 *
	 * @since 2.9.0
	 */
	var unappend = function (as) { return [(0, exports.init)(as), (0, exports.last)(as)]; };
	exports.unappend = unappend;
	/**
	 * @category conversions
	 * @since 2.5.0
	 */
	var fromArray = function (as) { return (0, exports.fromReadonlyArray)(as.slice()); };
	exports.fromArray = fromArray;
	function concatW(second) {
	    return function (first) { return first.concat(second); };
	}
	exports.concatW = concatW;
	function concat(x, y) {
	    return y ? x.concat(y) : function (y) { return y.concat(x); };
	}
	exports.concat = concat;
	/**
	 * @since 2.5.0
	 */
	var reverse = function (as) {
	    return as.length === 1 ? as : __spreadArray([(0, exports.last)(as)], as.slice(0, -1).reverse(), true);
	};
	exports.reverse = reverse;
	function group(E) {
	    return function (as) {
	        var len = as.length;
	        if (len === 0) {
	            return exports.empty;
	        }
	        var out = [];
	        var head = as[0];
	        var nea = [head];
	        for (var i = 1; i < len; i++) {
	            var a = as[i];
	            if (E.equals(a, head)) {
	                nea.push(a);
	            }
	            else {
	                out.push(nea);
	                head = a;
	                nea = [head];
	            }
	        }
	        out.push(nea);
	        return out;
	    };
	}
	exports.group = group;
	/**
	 * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
	 * function on each element, and grouping the results according to values returned
	 *
	 * @example
	 * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'
	 *
	 * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {
	 *   '1': ['a', 'b'],
	 *   '2': ['ab']
	 * })
	 *
	 * @since 2.5.0
	 */
	var groupBy = function (f) {
	    return function (as) {
	        var out = {};
	        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
	            var a = as_1[_i];
	            var k = f(a);
	            if (_.has.call(out, k)) {
	                out[k].push(a);
	            }
	            else {
	                out[k] = [a];
	            }
	        }
	        return out;
	    };
	};
	exports.groupBy = groupBy;
	/**
	 * @since 2.5.0
	 */
	var sort = function (O) {
	    return function (as) {
	        return as.length === 1 ? as : as.slice().sort(O.compare);
	    };
	};
	exports.sort = sort;
	/**
	 * @since 2.5.0
	 */
	var updateAt = function (i, a) {
	    return (0, exports.modifyAt)(i, function () { return a; });
	};
	exports.updateAt = updateAt;
	/**
	 * @since 2.5.0
	 */
	var modifyAt = function (i, f) {
	    return function (as) {
	        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
	    };
	};
	exports.modifyAt = modifyAt;
	/**
	 * @since 2.5.1
	 */
	var zipWith = function (as, bs, f) {
	    var cs = [f(as[0], bs[0])];
	    var len = Math.min(as.length, bs.length);
	    for (var i = 1; i < len; i++) {
	        cs[i] = f(as[i], bs[i]);
	    }
	    return cs;
	};
	exports.zipWith = zipWith;
	function zip(as, bs) {
	    if (bs === undefined) {
	        return function (bs) { return zip(bs, as); };
	    }
	    return (0, exports.zipWith)(as, bs, function (a, b) { return [a, b]; });
	}
	exports.zip = zip;
	/**
	 * @since 2.5.1
	 */
	var unzip = function (abs) {
	    var fa = [abs[0][0]];
	    var fb = [abs[0][1]];
	    for (var i = 1; i < abs.length; i++) {
	        fa[i] = abs[i][0];
	        fb[i] = abs[i][1];
	    }
	    return [fa, fb];
	};
	exports.unzip = unzip;
	/**
	 * Prepend an element to every member of a `ReadonlyNonEmptyArray`.
	 *
	 * @example
	 * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'
	 *
	 * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
	 *
	 * @since 2.10.0
	 */
	var prependAll = function (middle) {
	    return function (as) {
	        var out = [middle, as[0]];
	        for (var i = 1; i < as.length; i++) {
	            out.push(middle, as[i]);
	        }
	        return out;
	    };
	};
	exports.prependAll = prependAll;
	/**
	 * Places an element in between members of a `ReadonlyNonEmptyArray`.
	 *
	 * @example
	 * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'
	 *
	 * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
	 *
	 * @since 2.9.0
	 */
	var intersperse = function (middle) {
	    return function (as) {
	        var rest = (0, exports.tail)(as);
	        return (0, exports.isNonEmpty)(rest) ? (0, function_1.pipe)(rest, (0, exports.prependAll)(middle), (0, exports.prepend)((0, exports.head)(as))) : as;
	    };
	};
	exports.intersperse = intersperse;
	/**
	 * @category sequencing
	 * @since 2.10.0
	 */
	var chainWithIndex = function (f) {
	    return function (as) {
	        var out = _.fromReadonlyNonEmptyArray(f(0, (0, exports.head)(as)));
	        for (var i = 1; i < as.length; i++) {
	            out.push.apply(out, f(i, as[i]));
	        }
	        return out;
	    };
	};
	exports.chainWithIndex = chainWithIndex;
	/**
	 * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for "chopping" up the input
	 * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a
	 * value and the tail of the `ReadonlyNonEmptyArray`.
	 *
	 * @since 2.10.0
	 */
	var chop = function (f) {
	    return function (as) {
	        var _a = f(as), b = _a[0], rest = _a[1];
	        var out = [b];
	        var next = rest;
	        while ((0, exports.isNonEmpty)(next)) {
	            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
	            out.push(b_1);
	            next = rest_2;
	        }
	        return out;
	    };
	};
	exports.chop = chop;
	/**
	 * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.
	 *
	 * @since 2.10.0
	 */
	var splitAt = function (n) {
	    return function (as) {
	        var m = Math.max(1, n);
	        return m >= as.length ? [as, exports.empty] : [(0, function_1.pipe)(as.slice(1, m), (0, exports.prepend)((0, exports.head)(as))), as.slice(m)];
	    };
	};
	exports.splitAt = splitAt;
	/**
	 * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
	 * the `ReadonlyNonEmptyArray`.
	 *
	 * @since 2.10.0
	 */
	var chunksOf = function (n) { return (0, exports.chop)((0, exports.splitAt)(n)); };
	exports.chunksOf = chunksOf;
	var _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };
	/* istanbul ignore next */
	var _mapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f)); };
	var _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };
	/* istanbul ignore next */
	var _extend = function (wa, f) { return (0, function_1.pipe)(wa, (0, exports.extend)(f)); };
	/* istanbul ignore next */
	var _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };
	/* istanbul ignore next */
	var _foldMap = function (M) {
	    var foldMapM = (0, exports.foldMap)(M);
	    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };
	};
	/* istanbul ignore next */
	var _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };
	/* istanbul ignore next */
	var _traverse = function (F) {
	    var traverseF = (0, exports.traverse)(F);
	    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };
	};
	/* istanbul ignore next */
	var _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };
	/* istanbul ignore next */
	var _reduceWithIndex = function (fa, b, f) {
	    return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
	};
	/* istanbul ignore next */
	var _foldMapWithIndex = function (M) {
	    var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
	    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapWithIndexM(f)); };
	};
	/* istanbul ignore next */
	var _reduceRightWithIndex = function (fa, b, f) {
	    return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
	};
	/* istanbul ignore next */
	var _traverseWithIndex = function (F) {
	    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
	    return function (ta, f) { return (0, function_1.pipe)(ta, traverseWithIndexF(f)); };
	};
	/**
	 * @category constructors
	 * @since 2.5.0
	 */
	exports.of = _.singleton;
	/**
	 * Less strict version of [`alt`](#alt).
	 *
	 * The `W` suffix (short for **W**idening) means that the return types will be merged.
	 *
	 * @example
	 * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,
	 *     RNEA.altW(() => ['a', 'b'])
	 *   ),
	 *   [1, 2, 3, 'a', 'b']
	 * )
	 *
	 * @category error handling
	 * @since 2.9.0
	 */
	var altW = function (that) {
	    return function (as) {
	        return (0, function_1.pipe)(as, concatW(that()));
	    };
	};
	exports.altW = altW;
	/**
	 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
	 * types of kind `* -> *`.
	 *
	 * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.
	 *
	 * @example
	 * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     RNEA.alt(() => [4, 5])
	 *   ),
	 *   [1, 2, 3, 4, 5]
	 * )
	 *
	 * @category error handling
	 * @since 2.6.2
	 */
	exports.alt = exports.altW;
	/**
	 * @since 2.5.0
	 */
	var ap = function (as) { return (0, exports.flatMap)(function (f) { return (0, function_1.pipe)(as, (0, exports.map)(f)); }); };
	exports.ap = ap;
	/**
	 * @example
	 * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])
	 *   ),
	 *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']
	 * )
	 *
	 * @category sequencing
	 * @since 2.14.0
	 */
	exports.flatMap = (0, function_1.dual)(2, function (ma, f) {
	    return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function (i, a) { return f(a, i); }));
	});
	/**
	 * @since 2.5.0
	 */
	var extend = function (f) {
	    return function (as) {
	        var next = (0, exports.tail)(as);
	        var out = [f(as)];
	        while ((0, exports.isNonEmpty)(next)) {
	            out.push(f(next));
	            next = (0, exports.tail)(next);
	        }
	        return out;
	    };
	};
	exports.extend = extend;
	/**
	 * @since 2.5.0
	 */
	exports.duplicate = 
	/*#__PURE__*/ (0, exports.extend)(function_1.identity);
	/**
	 * @category sequencing
	 * @since 2.5.0
	 */
	exports.flatten = 
	/*#__PURE__*/ (0, exports.flatMap)(function_1.identity);
	/**
	 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
	 * use the type constructor `F` to represent some computational context.
	 *
	 * @category mapping
	 * @since 2.5.0
	 */
	var map = function (f) {
	    return (0, exports.mapWithIndex)(function (_, a) { return f(a); });
	};
	exports.map = map;
	/**
	 * @category mapping
	 * @since 2.5.0
	 */
	var mapWithIndex = function (f) {
	    return function (as) {
	        var out = [f(0, (0, exports.head)(as))];
	        for (var i = 1; i < as.length; i++) {
	            out.push(f(i, as[i]));
	        }
	        return out;
	    };
	};
	exports.mapWithIndex = mapWithIndex;
	/**
	 * @category folding
	 * @since 2.5.0
	 */
	var reduce = function (b, f) {
	    return (0, exports.reduceWithIndex)(b, function (_, b, a) { return f(b, a); });
	};
	exports.reduce = reduce;
	/**
	 * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.
	 *
	 * @category folding
	 * @since 2.5.0
	 */
	var foldMap = function (S) {
	    return function (f) {
	        return function (as) {
	            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));
	        };
	    };
	};
	exports.foldMap = foldMap;
	/**
	 * @category folding
	 * @since 2.5.0
	 */
	var reduceRight = function (b, f) {
	    return (0, exports.reduceRightWithIndex)(b, function (_, b, a) { return f(b, a); });
	};
	exports.reduceRight = reduceRight;
	/**
	 * @category folding
	 * @since 2.5.0
	 */
	var reduceWithIndex = function (b, f) {
	    return function (as) {
	        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);
	    };
	};
	exports.reduceWithIndex = reduceWithIndex;
	/**
	 * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.
	 *
	 * @category folding
	 * @since 2.5.0
	 */
	var foldMapWithIndex = function (S) {
	    return function (f) {
	        return function (as) {
	            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));
	        };
	    };
	};
	exports.foldMapWithIndex = foldMapWithIndex;
	/**
	 * @category folding
	 * @since 2.5.0
	 */
	var reduceRightWithIndex = function (b, f) {
	    return function (as) {
	        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);
	    };
	};
	exports.reduceRightWithIndex = reduceRightWithIndex;
	/**
	 * @category traversing
	 * @since 2.6.3
	 */
	var traverse = function (F) {
	    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
	    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
	};
	exports.traverse = traverse;
	/**
	 * @category traversing
	 * @since 2.6.3
	 */
	var sequence = function (F) { return (0, exports.traverseWithIndex)(F)(function_1.SK); };
	exports.sequence = sequence;
	/**
	 * @category sequencing
	 * @since 2.6.3
	 */
	var traverseWithIndex = function (F) {
	    return function (f) {
	        return function (as) {
	            var out = F.map(f(0, (0, exports.head)(as)), exports.of);
	            for (var i = 1; i < as.length; i++) {
	                out = F.ap(F.map(out, function (bs) { return function (b) { return (0, function_1.pipe)(bs, (0, exports.append)(b)); }; }), f(i, as[i]));
	            }
	            return out;
	        };
	    };
	};
	exports.traverseWithIndex = traverseWithIndex;
	/**
	 * @category Comonad
	 * @since 2.6.3
	 */
	exports.extract = _.head;
	/**
	 * @category type lambdas
	 * @since 2.5.0
	 */
	exports.URI = 'ReadonlyNonEmptyArray';
	/**
	 * @category instances
	 * @since 2.5.0
	 */
	var getShow = function (S) { return ({
	    show: function (as) { return "[".concat(as.map(S.show).join(', '), "]"); }
	}); };
	exports.getShow = getShow;
	/**
	 * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`
	 *
	 * @category instances
	 * @since 2.5.0
	 */
	var getSemigroup = function () { return ({
	    concat: concat
	}); };
	exports.getSemigroup = getSemigroup;
	/**
	 * @example
	 * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'
	 * import * as N from 'fp-ts/number'
	 *
	 * const E = getEq(N.Eq)
	 * assert.strictEqual(E.equals([1, 2], [1, 2]), true)
	 * assert.strictEqual(E.equals([1, 2], [1, 3]), false)
	 *
	 * @category instances
	 * @since 2.5.0
	 */
	var getEq = function (E) {
	    return (0, Eq_1.fromEquals)(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });
	};
	exports.getEq = getEq;
	/**
	 * @since 2.11.0
	 */
	var getUnionSemigroup = function (E) {
	    var unionE = (0, exports.union)(E);
	    return {
	        concat: function (first, second) { return unionE(second)(first); }
	    };
	};
	exports.getUnionSemigroup = getUnionSemigroup;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Functor = {
	    URI: exports.URI,
	    map: _map
	};
	/**
	 * @category mapping
	 * @since 2.10.0
	 */
	exports.flap = (0, Functor_1.flap)(exports.Functor);
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Pointed = {
	    URI: exports.URI,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.FunctorWithIndex = {
	    URI: exports.URI,
	    map: _map,
	    mapWithIndex: _mapWithIndex
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Apply = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap
	};
	/**
	 * Combine two effectful actions, keeping only the result of the first.
	 *
	 * @since 2.5.0
	 */
	exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
	/**
	 * Combine two effectful actions, keeping only the result of the second.
	 *
	 * @since 2.5.0
	 */
	exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Applicative = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Chain = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap
	};
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @example
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     RA.chainFirst(() => ['a', 'b'])
	 *   ),
	 *   [1, 1, 2, 2, 3, 3]
	 * )
	 *
	 * @category sequencing
	 * @since 2.5.0
	 */
	exports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Monad = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    chain: exports.flatMap
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Foldable = {
	    URI: exports.URI,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.FoldableWithIndex = {
	    URI: exports.URI,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Traversable = {
	    URI: exports.URI,
	    map: _map,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.TraversableWithIndex = {
	    URI: exports.URI,
	    map: _map,
	    mapWithIndex: _mapWithIndex,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex,
	    traverseWithIndex: _traverseWithIndex
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Alt = {
	    URI: exports.URI,
	    map: _map,
	    alt: _alt
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Comonad = {
	    URI: exports.URI,
	    map: _map,
	    extend: _extend,
	    extract: exports.extract
	};
	// -------------------------------------------------------------------------------------
	// do notation
	// -------------------------------------------------------------------------------------
	/**
	 * @category do notation
	 * @since 2.9.0
	 */
	exports.Do = (0, exports.of)(_.emptyRecord);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
	var let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);
	exports.let = let_;
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bind = (0, Chain_1.bind)(exports.Chain);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.apS = (0, Apply_1.apS)(exports.Apply);
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * @since 2.5.0
	 */
	exports.head = exports.extract;
	/**
	 * @since 2.5.0
	 */
	exports.tail = _.tail;
	/**
	 * @since 2.5.0
	 */
	var last = function (as) { return as[as.length - 1]; };
	exports.last = last;
	/**
	 * Get all but the last element of a non empty array, creating a new array.
	 *
	 * @example
	 * import { init } from 'fp-ts/ReadonlyNonEmptyArray'
	 *
	 * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])
	 * assert.deepStrictEqual(init([1]), [])
	 *
	 * @since 2.5.0
	 */
	var init = function (as) { return as.slice(0, -1); };
	exports.init = init;
	/**
	 * @since 2.5.0
	 */
	var min = function (O) {
	    var S = Se.min(O);
	    return function (as) { return as.reduce(S.concat); };
	};
	exports.min = min;
	/**
	 * @since 2.5.0
	 */
	var max = function (O) {
	    var S = Se.max(O);
	    return function (as) { return as.reduce(S.concat); };
	};
	exports.max = max;
	/**
	 * @since 2.10.0
	 */
	var concatAll = function (S) {
	    return function (as) {
	        return as.reduce(S.concat);
	    };
	};
	exports.concatAll = concatAll;
	/**
	 * Break a `ReadonlyArray` into its first element and remaining elements.
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	var matchLeft = function (f) {
	    return function (as) {
	        return f((0, exports.head)(as), (0, exports.tail)(as));
	    };
	};
	exports.matchLeft = matchLeft;
	/**
	 * Break a `ReadonlyArray` into its initial elements and the last element.
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	var matchRight = function (f) {
	    return function (as) {
	        return f((0, exports.init)(as), (0, exports.last)(as));
	    };
	};
	exports.matchRight = matchRight;
	/**
	 * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.
	 *
	 * @since 2.11.0
	 */
	var modifyHead = function (f) {
	    return function (as) {
	        return __spreadArray([f((0, exports.head)(as))], (0, exports.tail)(as), true);
	    };
	};
	exports.modifyHead = modifyHead;
	/**
	 * Change the head, creating a new `ReadonlyNonEmptyArray`.
	 *
	 * @since 2.11.0
	 */
	var updateHead = function (a) { return (0, exports.modifyHead)(function () { return a; }); };
	exports.updateHead = updateHead;
	/**
	 * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.
	 *
	 * @since 2.11.0
	 */
	var modifyLast = function (f) {
	    return function (as) {
	        return (0, function_1.pipe)((0, exports.init)(as), (0, exports.append)(f((0, exports.last)(as))));
	    };
	};
	exports.modifyLast = modifyLast;
	/**
	 * Change the last element, creating a new `ReadonlyNonEmptyArray`.
	 *
	 * @since 2.11.0
	 */
	var updateLast = function (a) { return (0, exports.modifyLast)(function () { return a; }); };
	exports.updateLast = updateLast;
	/**
	 * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.
	 *
	 * @example
	 * import * as S from 'fp-ts/string'
	 * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'
	 *
	 * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
	 *
	 * @since 2.12.0
	 */
	var intercalate = function (S) {
	    var concatAllS = (0, exports.concatAll)(S);
	    return function (middle) { return (0, function_1.flow)((0, exports.intersperse)(middle), concatAllS); };
	};
	exports.intercalate = intercalate;
	// -------------------------------------------------------------------------------------
	// legacy
	// -------------------------------------------------------------------------------------
	/**
	 * Alias of `flatMap`.
	 *
	 * @category legacy
	 * @since 2.5.0
	 */
	exports.chain = exports.flatMap;
	function groupSort(O) {
	    var sortO = (0, exports.sort)(O);
	    var groupO = group(O);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? groupO(sortO(as)) : exports.empty); };
	}
	exports.groupSort = groupSort;
	function filter(predicate) {
	    return (0, exports.filterWithIndex)(function (_, a) { return predicate(a); });
	}
	exports.filter = filter;
	/**
	 * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	var filterWithIndex = function (predicate) {
	    return function (as) {
	        return (0, exports.fromReadonlyArray)(as.filter(function (a, i) { return predicate(i, a); }));
	    };
	};
	exports.filterWithIndex = filterWithIndex;
	/**
	 * Use [`unprepend`](#unprepend) instead.
	 *
	 * @category zone of death
	 * @since 2.10.0
	 * @deprecated
	 */
	exports.uncons = exports.unprepend;
	/**
	 * Use [`unappend`](#unappend) instead.
	 *
	 * @category zone of death
	 * @since 2.10.0
	 * @deprecated
	 */
	exports.unsnoc = exports.unappend;
	function cons(head, tail) {
	    return tail === undefined ? (0, exports.prepend)(head) : (0, function_1.pipe)(tail, (0, exports.prepend)(head));
	}
	exports.cons = cons;
	/**
	 * Use [`append`](./ReadonlyArray.ts.html#append) instead.
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	var snoc = function (init, end) { return (0, function_1.pipe)(init, concat([end])); };
	exports.snoc = snoc;
	/**
	 * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	var insertAt = function (i, a) {
	    return function (as) {
	        return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
	    };
	};
	exports.insertAt = insertAt;
	/**
	 * Use [`prependAll`](#prependall) instead.
	 *
	 * @category zone of death
	 * @since 2.9.0
	 * @deprecated
	 */
	exports.prependToAll = exports.prependAll;
	/**
	 * Use [`concatAll`](#concatall) instead.
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	exports.fold = exports.concatAll;
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`
	 * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	exports.readonlyNonEmptyArray = {
	    URI: exports.URI,
	    of: exports.of,
	    map: _map,
	    mapWithIndex: _mapWithIndex,
	    ap: _ap,
	    chain: exports.flatMap,
	    extend: _extend,
	    extract: exports.extract,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex,
	    traverseWithIndex: _traverseWithIndex,
	    alt: _alt
	}; 
} (ReadonlyNonEmptyArray));

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.flatMap = exports.ap = exports.alt = exports.altW = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.foldMap = exports.foldMapWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.of = exports.copy = exports.modifyAt = exports.updateAt = exports.insertAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromArray = exports.fromReadonlyNonEmptyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = void 0;
	exports.chain = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = void 0;
	exports.nonEmptyArray = exports.fold = exports.prependToAll = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = exports.filterWithIndex = exports.filter = exports.groupSort = void 0;
	var Apply_1 = Apply;
	var Chain_1 = Chain;
	var function_1 = _function;
	var Functor_1 = Functor;
	var _ = __importStar(internal);
	var Ord_1 = Ord;
	var RNEA = __importStar(ReadonlyNonEmptyArray);
	// -------------------------------------------------------------------------------------
	// internal
	// -------------------------------------------------------------------------------------
	/**
	 * @internal
	 */
	var isNonEmpty = function (as) { return as.length > 0; };
	exports.isNonEmpty = isNonEmpty;
	/**
	 * @internal
	 */
	var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };
	exports.isOutOfBound = isOutOfBound;
	/**
	 * @internal
	 */
	var prependW = function (head) {
	    return function (tail) {
	        return __spreadArray([head], tail, true);
	    };
	};
	exports.prependW = prependW;
	/**
	 * @internal
	 */
	exports.prepend = exports.prependW;
	/**
	 * @internal
	 */
	var appendW = function (end) {
	    return function (init) {
	        return __spreadArray(__spreadArray([], init, true), [end], false);
	    };
	};
	exports.appendW = appendW;
	/**
	 * @internal
	 */
	exports.append = exports.appendW;
	/**
	 * @internal
	 */
	var unsafeInsertAt = function (i, a, as) {
	    if ((0, exports.isNonEmpty)(as)) {
	        var xs = (0, exports.fromReadonlyNonEmptyArray)(as);
	        xs.splice(i, 0, a);
	        return xs;
	    }
	    return [a];
	};
	exports.unsafeInsertAt = unsafeInsertAt;
	/**
	 * @internal
	 */
	var unsafeUpdateAt = function (i, a, as) {
	    var xs = (0, exports.fromReadonlyNonEmptyArray)(as);
	    xs[i] = a;
	    return xs;
	};
	exports.unsafeUpdateAt = unsafeUpdateAt;
	/**
	 * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.
	 *
	 * @example
	 * import { uniq } from 'fp-ts/NonEmptyArray'
	 * import * as N from 'fp-ts/number'
	 *
	 * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
	 *
	 * @since 2.11.0
	 */
	var uniq = function (E) {
	    return function (as) {
	        if (as.length === 1) {
	            return (0, exports.copy)(as);
	        }
	        var out = [(0, exports.head)(as)];
	        var rest = (0, exports.tail)(as);
	        var _loop_1 = function (a) {
	            if (out.every(function (o) { return !E.equals(o, a); })) {
	                out.push(a);
	            }
	        };
	        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
	            var a = rest_1[_i];
	            _loop_1(a);
	        }
	        return out;
	    };
	};
	exports.uniq = uniq;
	/**
	 * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
	 * etc...
	 *
	 * @example
	 * import * as NEA from 'fp-ts/NonEmptyArray'
	 * import { contramap } from 'fp-ts/Ord'
	 * import * as S from 'fp-ts/string'
	 * import * as N from 'fp-ts/number'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * interface Person {
	 *   name: string
	 *   age: number
	 * }
	 *
	 * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
	 *
	 * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
	 *
	 * const sortByNameByAge = NEA.sortBy([byName, byAge])
	 *
	 * const persons: NEA.NonEmptyArray<Person> = [
	 *   { name: 'a', age: 1 },
	 *   { name: 'b', age: 3 },
	 *   { name: 'c', age: 2 },
	 *   { name: 'b', age: 2 }
	 * ]
	 *
	 * assert.deepStrictEqual(sortByNameByAge(persons), [
	 *   { name: 'a', age: 1 },
	 *   { name: 'b', age: 2 },
	 *   { name: 'b', age: 3 },
	 *   { name: 'c', age: 2 }
	 * ])
	 *
	 * @since 2.11.0
	 */
	var sortBy = function (ords) {
	    if ((0, exports.isNonEmpty)(ords)) {
	        var M = (0, Ord_1.getMonoid)();
	        return (0, exports.sort)(ords.reduce(M.concat, M.empty));
	    }
	    return exports.copy;
	};
	exports.sortBy = sortBy;
	/**
	 * @since 2.11.0
	 */
	var union = function (E) {
	    var uniqE = (0, exports.uniq)(E);
	    return function (second) { return function (first) { return uniqE((0, function_1.pipe)(first, concat(second))); }; };
	};
	exports.union = union;
	/**
	 * Rotate a `NonEmptyArray` by `n` steps.
	 *
	 * @example
	 * import { rotate } from 'fp-ts/NonEmptyArray'
	 *
	 * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
	 * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])
	 *
	 * @since 2.11.0
	 */
	var rotate = function (n) {
	    return function (as) {
	        var len = as.length;
	        var m = Math.round(n) % len;
	        if ((0, exports.isOutOfBound)(Math.abs(m), as) || m === 0) {
	            return (0, exports.copy)(as);
	        }
	        if (m < 0) {
	            var _a = (0, exports.splitAt)(-m)(as), f = _a[0], s = _a[1];
	            return (0, function_1.pipe)(s, concat(f));
	        }
	        else {
	            return (0, exports.rotate)(m - len)(as);
	        }
	    };
	};
	exports.rotate = rotate;
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * @category conversions
	 * @since 2.10.0
	 */
	exports.fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;
	/**
	 * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array
	 *
	 * @category conversions
	 * @since 2.0.0
	 */
	var fromArray = function (as) { return ((0, exports.isNonEmpty)(as) ? _.some(as) : _.none); };
	exports.fromArray = fromArray;
	/**
	 * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.
	 *
	 * **Note**. `n` is normalized to a natural number.
	 *
	 * @example
	 * import { makeBy } from 'fp-ts/NonEmptyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const double = (n: number): number => n * 2
	 * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])
	 *
	 * @category constructors
	 * @since 2.11.0
	 */
	var makeBy = function (f) {
	    return function (n) {
	        var j = Math.max(0, Math.floor(n));
	        var out = [f(0)];
	        for (var i = 1; i < j; i++) {
	            out.push(f(i));
	        }
	        return out;
	    };
	};
	exports.makeBy = makeBy;
	/**
	 * Create a `NonEmptyArray` containing a value repeated the specified number of times.
	 *
	 * **Note**. `n` is normalized to a natural number.
	 *
	 * @example
	 * import { replicate } from 'fp-ts/NonEmptyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])
	 *
	 * @category constructors
	 * @since 2.11.0
	 */
	var replicate = function (a) { return (0, exports.makeBy)(function () { return a; }); };
	exports.replicate = replicate;
	/**
	 * Create a `NonEmptyArray` containing a range of integers, including both endpoints.
	 *
	 * @example
	 * import { range } from 'fp-ts/NonEmptyArray'
	 *
	 * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])
	 *
	 * @category constructors
	 * @since 2.11.0
	 */
	var range = function (start, end) {
	    return start <= end ? (0, exports.makeBy)(function (i) { return start + i; })(end - start + 1) : [start];
	};
	exports.range = range;
	/**
	 * Return the tuple of the `head` and the `tail`.
	 *
	 * @example
	 * import { unprepend } from 'fp-ts/NonEmptyArray'
	 *
	 * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])
	 *
	 * @since 2.9.0
	 */
	var unprepend = function (as) { return [(0, exports.head)(as), (0, exports.tail)(as)]; };
	exports.unprepend = unprepend;
	/**
	 * Return the tuple of the `init` and the `last`.
	 *
	 * @example
	 * import { unappend } from 'fp-ts/NonEmptyArray'
	 *
	 * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])
	 *
	 * @since 2.9.0
	 */
	var unappend = function (as) { return [(0, exports.init)(as), (0, exports.last)(as)]; };
	exports.unappend = unappend;
	function concatW(second) {
	    return function (first) { return first.concat(second); };
	}
	exports.concatW = concatW;
	function concat(x, y) {
	    return y ? x.concat(y) : function (y) { return y.concat(x); };
	}
	exports.concat = concat;
	/**
	 * @since 2.0.0
	 */
	var reverse = function (as) { return __spreadArray([(0, exports.last)(as)], as.slice(0, -1).reverse(), true); };
	exports.reverse = reverse;
	function group(E) {
	    return function (as) {
	        var len = as.length;
	        if (len === 0) {
	            return [];
	        }
	        var out = [];
	        var head = as[0];
	        var nea = [head];
	        for (var i = 1; i < len; i++) {
	            var a = as[i];
	            if (E.equals(a, head)) {
	                nea.push(a);
	            }
	            else {
	                out.push(nea);
	                head = a;
	                nea = [head];
	            }
	        }
	        out.push(nea);
	        return out;
	    };
	}
	exports.group = group;
	/**
	 * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
	 * function on each element, and grouping the results according to values returned
	 *
	 * @example
	 * import { groupBy } from 'fp-ts/NonEmptyArray'
	 *
	 * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {
	 *   '1': ['a', 'b'],
	 *   '2': ['ab']
	 * })
	 *
	 * @since 2.0.0
	 */
	var groupBy = function (f) {
	    return function (as) {
	        var out = {};
	        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
	            var a = as_1[_i];
	            var k = f(a);
	            if (_.has.call(out, k)) {
	                out[k].push(a);
	            }
	            else {
	                out[k] = [a];
	            }
	        }
	        return out;
	    };
	};
	exports.groupBy = groupBy;
	/**
	 * @since 2.0.0
	 */
	var sort = function (O) {
	    return function (as) {
	        return as.slice().sort(O.compare);
	    };
	};
	exports.sort = sort;
	/**
	 * @since 2.0.0
	 */
	var insertAt = function (i, a) {
	    return function (as) {
	        return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
	    };
	};
	exports.insertAt = insertAt;
	/**
	 * @since 2.0.0
	 */
	var updateAt = function (i, a) {
	    return (0, exports.modifyAt)(i, function () { return a; });
	};
	exports.updateAt = updateAt;
	/**
	 * @since 2.0.0
	 */
	var modifyAt = function (i, f) {
	    return function (as) {
	        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
	    };
	};
	exports.modifyAt = modifyAt;
	/**
	 * @since 2.0.0
	 */
	exports.copy = exports.fromReadonlyNonEmptyArray;
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	var of = function (a) { return [a]; };
	exports.of = of;
	/**
	 * @since 2.5.1
	 */
	var zipWith = function (as, bs, f) {
	    var cs = [f(as[0], bs[0])];
	    var len = Math.min(as.length, bs.length);
	    for (var i = 1; i < len; i++) {
	        cs[i] = f(as[i], bs[i]);
	    }
	    return cs;
	};
	exports.zipWith = zipWith;
	function zip(as, bs) {
	    if (bs === undefined) {
	        return function (bs) { return zip(bs, as); };
	    }
	    return (0, exports.zipWith)(as, bs, function (a, b) { return [a, b]; });
	}
	exports.zip = zip;
	/**
	 * @since 2.5.1
	 */
	var unzip = function (abs) {
	    var fa = [abs[0][0]];
	    var fb = [abs[0][1]];
	    for (var i = 1; i < abs.length; i++) {
	        fa[i] = abs[i][0];
	        fb[i] = abs[i][1];
	    }
	    return [fa, fb];
	};
	exports.unzip = unzip;
	/**
	 * Prepend an element to every member of an array
	 *
	 * @example
	 * import { prependAll } from 'fp-ts/NonEmptyArray'
	 *
	 * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
	 *
	 * @since 2.10.0
	 */
	var prependAll = function (middle) {
	    return function (as) {
	        var out = [middle, as[0]];
	        for (var i = 1; i < as.length; i++) {
	            out.push(middle, as[i]);
	        }
	        return out;
	    };
	};
	exports.prependAll = prependAll;
	/**
	 * Places an element in between members of an array
	 *
	 * @example
	 * import { intersperse } from 'fp-ts/NonEmptyArray'
	 *
	 * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
	 *
	 * @since 2.9.0
	 */
	var intersperse = function (middle) {
	    return function (as) {
	        var rest = (0, exports.tail)(as);
	        return (0, exports.isNonEmpty)(rest) ? (0, function_1.pipe)(rest, (0, exports.prependAll)(middle), (0, exports.prepend)((0, exports.head)(as))) : (0, exports.copy)(as);
	    };
	};
	exports.intersperse = intersperse;
	/**
	 * @category folding
	 * @since 2.0.0
	 */
	exports.foldMapWithIndex = RNEA.foldMapWithIndex;
	/**
	 * @category folding
	 * @since 2.0.0
	 */
	exports.foldMap = RNEA.foldMap;
	/**
	 * @category sequencing
	 * @since 2.10.0
	 */
	var chainWithIndex = function (f) {
	    return function (as) {
	        var out = (0, exports.fromReadonlyNonEmptyArray)(f(0, (0, exports.head)(as)));
	        for (var i = 1; i < as.length; i++) {
	            out.push.apply(out, f(i, as[i]));
	        }
	        return out;
	    };
	};
	exports.chainWithIndex = chainWithIndex;
	/**
	 * @since 2.10.0
	 */
	var chop = function (f) {
	    return function (as) {
	        var _a = f(as), b = _a[0], rest = _a[1];
	        var out = [b];
	        var next = rest;
	        while ((0, exports.isNonEmpty)(next)) {
	            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
	            out.push(b_1);
	            next = rest_2;
	        }
	        return out;
	    };
	};
	exports.chop = chop;
	/**
	 * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.
	 *
	 * @since 2.10.0
	 */
	var splitAt = function (n) {
	    return function (as) {
	        var m = Math.max(1, n);
	        return m >= as.length ? [(0, exports.copy)(as), []] : [(0, function_1.pipe)(as.slice(1, m), (0, exports.prepend)((0, exports.head)(as))), as.slice(m)];
	    };
	};
	exports.splitAt = splitAt;
	/**
	 * @since 2.10.0
	 */
	var chunksOf = function (n) { return (0, exports.chop)((0, exports.splitAt)(n)); };
	exports.chunksOf = chunksOf;
	/* istanbul ignore next */
	var _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };
	/* istanbul ignore next */
	var _mapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f)); };
	/* istanbul ignore next */
	var _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };
	/* istanbul ignore next */
	var _extend = function (wa, f) { return (0, function_1.pipe)(wa, (0, exports.extend)(f)); };
	/* istanbul ignore next */
	var _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };
	/* istanbul ignore next */
	var _foldMap = function (M) {
	    var foldMapM = (0, exports.foldMap)(M);
	    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };
	};
	/* istanbul ignore next */
	var _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };
	/* istanbul ignore next */
	var _traverse = function (F) {
	    var traverseF = (0, exports.traverse)(F);
	    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };
	};
	/* istanbul ignore next */
	var _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };
	/* istanbul ignore next */
	var _reduceWithIndex = function (fa, b, f) {
	    return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
	};
	/* istanbul ignore next */
	var _foldMapWithIndex = function (M) {
	    var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
	    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapWithIndexM(f)); };
	};
	/* istanbul ignore next */
	var _reduceRightWithIndex = function (fa, b, f) {
	    return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
	};
	/* istanbul ignore next */
	var _traverseWithIndex = function (F) {
	    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
	    return function (ta, f) { return (0, function_1.pipe)(ta, traverseWithIndexF(f)); };
	};
	/**
	 * Less strict version of [`alt`](#alt).
	 *
	 * The `W` suffix (short for **W**idening) means that the return types will be merged.
	 *
	 * @example
	 * import * as NEA from 'fp-ts/NonEmptyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3] as NEA.NonEmptyArray<number>,
	 *     NEA.altW(() => ['a', 'b'])
	 *   ),
	 *   [1, 2, 3, 'a', 'b']
	 * )
	 *
	 * @category error handling
	 * @since 2.9.0
	 */
	var altW = function (that) {
	    return function (as) {
	        return (0, function_1.pipe)(as, concatW(that()));
	    };
	};
	exports.altW = altW;
	/**
	 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
	 * types of kind `* -> *`.
	 *
	 * In case of `NonEmptyArray` concatenates the inputs into a single array.
	 *
	 * @example
	 * import * as NEA from 'fp-ts/NonEmptyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     NEA.alt(() => [4, 5])
	 *   ),
	 *   [1, 2, 3, 4, 5]
	 * )
	 *
	 * @category error handling
	 * @since 2.6.2
	 */
	exports.alt = exports.altW;
	/**
	 * Apply a function to an argument under a type constructor.
	 *
	 * @since 2.0.0
	 */
	var ap = function (as) {
	    return (0, exports.flatMap)(function (f) { return (0, function_1.pipe)(as, (0, exports.map)(f)); });
	};
	exports.ap = ap;
	/**
	 * @example
	 * import * as NEA from 'fp-ts/NonEmptyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     NEA.flatMap((n) => [`a${n}`, `b${n}`])
	 *   ),
	 *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']
	 * )
	 *
	 * @category sequencing
	 * @since 2.14.0
	 */
	exports.flatMap = (0, function_1.dual)(2, function (ma, f) {
	    return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function (i, a) { return f(a, i); }));
	});
	/**
	 * @since 2.0.0
	 */
	var extend = function (f) {
	    return function (as) {
	        var next = (0, exports.tail)(as);
	        var out = [f(as)];
	        while ((0, exports.isNonEmpty)(next)) {
	            out.push(f(next));
	            next = (0, exports.tail)(next);
	        }
	        return out;
	    };
	};
	exports.extend = extend;
	/**
	 * @since 2.5.0
	 */
	exports.duplicate = (0, exports.extend)(function_1.identity);
	/**
	 * @category sequencing
	 * @since 2.5.0
	 */
	exports.flatten = (0, exports.flatMap)(function_1.identity);
	/**
	 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
	 * use the type constructor `F` to represent some computational context.
	 *
	 * @category mapping
	 * @since 2.0.0
	 */
	var map = function (f) { return (0, exports.mapWithIndex)(function (_, a) { return f(a); }); };
	exports.map = map;
	/**
	 * @category mapping
	 * @since 2.0.0
	 */
	var mapWithIndex = function (f) {
	    return function (as) {
	        var out = [f(0, (0, exports.head)(as))];
	        for (var i = 1; i < as.length; i++) {
	            out.push(f(i, as[i]));
	        }
	        return out;
	    };
	};
	exports.mapWithIndex = mapWithIndex;
	/**
	 * @category folding
	 * @since 2.0.0
	 */
	exports.reduce = RNEA.reduce;
	/**
	 * @category folding
	 * @since 2.0.0
	 */
	exports.reduceWithIndex = RNEA.reduceWithIndex;
	/**
	 * @category folding
	 * @since 2.0.0
	 */
	exports.reduceRight = RNEA.reduceRight;
	/**
	 * @category folding
	 * @since 2.0.0
	 */
	exports.reduceRightWithIndex = RNEA.reduceRightWithIndex;
	/**
	 * @category traversing
	 * @since 2.6.3
	 */
	var traverse = function (F) {
	    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
	    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
	};
	exports.traverse = traverse;
	/**
	 * @category traversing
	 * @since 2.6.3
	 */
	var sequence = function (F) { return (0, exports.traverseWithIndex)(F)(function (_, a) { return a; }); };
	exports.sequence = sequence;
	/**
	 * @category sequencing
	 * @since 2.6.3
	 */
	var traverseWithIndex = function (F) {
	    return function (f) {
	        return function (as) {
	            var out = F.map(f(0, (0, exports.head)(as)), exports.of);
	            for (var i = 1; i < as.length; i++) {
	                out = F.ap(F.map(out, function (bs) { return function (b) { return (0, function_1.pipe)(bs, (0, exports.append)(b)); }; }), f(i, as[i]));
	            }
	            return out;
	        };
	    };
	};
	exports.traverseWithIndex = traverseWithIndex;
	/**
	 * @since 2.7.0
	 */
	exports.extract = RNEA.head;
	/**
	 * @category type lambdas
	 * @since 2.0.0
	 */
	exports.URI = 'NonEmptyArray';
	/**
	 * @category instances
	 * @since 2.0.0
	 */
	exports.getShow = RNEA.getShow;
	/**
	 * Builds a `Semigroup` instance for `NonEmptyArray`
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	var getSemigroup = function () { return ({
	    concat: concat
	}); };
	exports.getSemigroup = getSemigroup;
	/**
	 * @example
	 * import { getEq } from 'fp-ts/NonEmptyArray'
	 * import * as N from 'fp-ts/number'
	 *
	 * const E = getEq(N.Eq)
	 * assert.strictEqual(E.equals([1, 2], [1, 2]), true)
	 * assert.strictEqual(E.equals([1, 2], [1, 3]), false)
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	exports.getEq = RNEA.getEq;
	/**
	 * @since 2.11.0
	 */
	var getUnionSemigroup = function (E) {
	    var unionE = (0, exports.union)(E);
	    return {
	        concat: function (first, second) { return unionE(second)(first); }
	    };
	};
	exports.getUnionSemigroup = getUnionSemigroup;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Functor = {
	    URI: exports.URI,
	    map: _map
	};
	/**
	 * @category mapping
	 * @since 2.10.0
	 */
	exports.flap = (0, Functor_1.flap)(exports.Functor);
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Pointed = {
	    URI: exports.URI,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.FunctorWithIndex = {
	    URI: exports.URI,
	    map: _map,
	    mapWithIndex: _mapWithIndex
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Apply = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap
	};
	/**
	 * Combine two effectful actions, keeping only the result of the first.
	 *
	 * @since 2.5.0
	 */
	exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
	/**
	 * Combine two effectful actions, keeping only the result of the second.
	 *
	 * @since 2.5.0
	 */
	exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Applicative = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Chain = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap
	};
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @category sequencing
	 * @since 2.5.0
	 */
	exports.chainFirst = 
	/*#__PURE__*/ (0, Chain_1.chainFirst)(exports.Chain);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Monad = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    chain: exports.flatMap
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Foldable = {
	    URI: exports.URI,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.FoldableWithIndex = {
	    URI: exports.URI,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Traversable = {
	    URI: exports.URI,
	    map: _map,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.TraversableWithIndex = {
	    URI: exports.URI,
	    map: _map,
	    mapWithIndex: _mapWithIndex,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex,
	    traverseWithIndex: _traverseWithIndex
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Alt = {
	    URI: exports.URI,
	    map: _map,
	    alt: _alt
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Comonad = {
	    URI: exports.URI,
	    map: _map,
	    extend: _extend,
	    extract: exports.extract
	};
	// -------------------------------------------------------------------------------------
	// do notation
	// -------------------------------------------------------------------------------------
	/**
	 * @category do notation
	 * @since 2.9.0
	 */
	exports.Do = (0, exports.of)(_.emptyRecord);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
	var let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);
	exports.let = let_;
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bind = (0, Chain_1.bind)(exports.Chain);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.apS = (0, Apply_1.apS)(exports.Apply);
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * @since 2.0.0
	 */
	exports.head = RNEA.head;
	/**
	 * @since 2.0.0
	 */
	var tail = function (as) { return as.slice(1); };
	exports.tail = tail;
	/**
	 * @since 2.0.0
	 */
	exports.last = RNEA.last;
	/**
	 * Get all but the last element of a non empty array, creating a new array.
	 *
	 * @example
	 * import { init } from 'fp-ts/NonEmptyArray'
	 *
	 * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])
	 * assert.deepStrictEqual(init([1]), [])
	 *
	 * @since 2.2.0
	 */
	var init = function (as) { return as.slice(0, -1); };
	exports.init = init;
	/**
	 * @since 2.0.0
	 */
	exports.min = RNEA.min;
	/**
	 * @since 2.0.0
	 */
	exports.max = RNEA.max;
	/**
	 * @since 2.10.0
	 */
	var concatAll = function (S) {
	    return function (as) {
	        return as.reduce(S.concat);
	    };
	};
	exports.concatAll = concatAll;
	/**
	 * Break an `Array` into its first element and remaining elements.
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	var matchLeft = function (f) {
	    return function (as) {
	        return f((0, exports.head)(as), (0, exports.tail)(as));
	    };
	};
	exports.matchLeft = matchLeft;
	/**
	 * Break an `Array` into its initial elements and the last element.
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	var matchRight = function (f) {
	    return function (as) {
	        return f((0, exports.init)(as), (0, exports.last)(as));
	    };
	};
	exports.matchRight = matchRight;
	/**
	 * Apply a function to the head, creating a new `NonEmptyArray`.
	 *
	 * @since 2.11.0
	 */
	var modifyHead = function (f) {
	    return function (as) {
	        return __spreadArray([f((0, exports.head)(as))], (0, exports.tail)(as), true);
	    };
	};
	exports.modifyHead = modifyHead;
	/**
	 * Change the head, creating a new `NonEmptyArray`.
	 *
	 * @since 2.11.0
	 */
	var updateHead = function (a) { return (0, exports.modifyHead)(function () { return a; }); };
	exports.updateHead = updateHead;
	/**
	 * Apply a function to the last element, creating a new `NonEmptyArray`.
	 *
	 * @since 2.11.0
	 */
	var modifyLast = function (f) {
	    return function (as) {
	        return (0, function_1.pipe)((0, exports.init)(as), (0, exports.append)(f((0, exports.last)(as))));
	    };
	};
	exports.modifyLast = modifyLast;
	/**
	 * Change the last element, creating a new `NonEmptyArray`.
	 *
	 * @since 2.11.0
	 */
	var updateLast = function (a) { return (0, exports.modifyLast)(function () { return a; }); };
	exports.updateLast = updateLast;
	/**
	 * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.
	 *
	 * @example
	 * import * as S from 'fp-ts/string'
	 * import { intercalate } from 'fp-ts/NonEmptyArray'
	 *
	 * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
	 *
	 * @since 2.12.0
	 */
	exports.intercalate = RNEA.intercalate;
	// -------------------------------------------------------------------------------------
	// legacy
	// -------------------------------------------------------------------------------------
	/**
	 * Alias of `flatMap`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.chain = exports.flatMap;
	function groupSort(O) {
	    var sortO = (0, exports.sort)(O);
	    var groupO = group(O);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? groupO(sortO(as)) : []); };
	}
	exports.groupSort = groupSort;
	function filter(predicate) {
	    return (0, exports.filterWithIndex)(function (_, a) { return predicate(a); });
	}
	exports.filter = filter;
	/**
	 * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	var filterWithIndex = function (predicate) {
	    return function (as) {
	        return (0, exports.fromArray)(as.filter(function (a, i) { return predicate(i, a); }));
	    };
	};
	exports.filterWithIndex = filterWithIndex;
	/**
	 * Use [`unprepend`](#unprepend) instead.
	 *
	 * @category zone of death
	 * @since 2.9.0
	 * @deprecated
	 */
	exports.uncons = exports.unprepend;
	/**
	 * Use [`unappend`](#unappend) instead.
	 *
	 * @category zone of death
	 * @since 2.9.0
	 * @deprecated
	 */
	exports.unsnoc = exports.unappend;
	function cons(head, tail) {
	    return tail === undefined ? (0, exports.prepend)(head) : (0, function_1.pipe)(tail, (0, exports.prepend)(head));
	}
	exports.cons = cons;
	/**
	 * Use [`append`](./Array.ts.html#append) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	var snoc = function (init, end) { return (0, function_1.pipe)(init, (0, exports.append)(end)); };
	exports.snoc = snoc;
	/**
	 * Use [`prependAll`](#prependall) instead.
	 *
	 * @category zone of death
	 * @since 2.9.0
	 * @deprecated
	 */
	exports.prependToAll = exports.prependAll;
	/**
	 * Use [`concatAll`](#concatall) instead.
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	exports.fold = RNEA.concatAll;
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`
	 * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.nonEmptyArray = {
	    URI: exports.URI,
	    of: exports.of,
	    map: _map,
	    mapWithIndex: _mapWithIndex,
	    ap: _ap,
	    chain: exports.flatMap,
	    extend: _extend,
	    extract: exports.extract,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex,
	    traverseWithIndex: _traverseWithIndex,
	    alt: _alt
	}; 
} (NonEmptyArray));

var ReadonlyArray = {};

var number = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Field = exports.MonoidProduct = exports.MonoidSum = exports.SemigroupProduct = exports.SemigroupSum = exports.MagmaSub = exports.Show = exports.Bounded = exports.Ord = exports.Eq = exports.isNumber = void 0;
	// -------------------------------------------------------------------------------------
	// refinements
	// -------------------------------------------------------------------------------------
	/**
	 * @category refinements
	 * @since 2.11.0
	 */
	var isNumber = function (u) { return typeof u === 'number'; };
	exports.isNumber = isNumber;
	// -------------------------------------------------------------------------------------
	// instances
	// -------------------------------------------------------------------------------------
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Eq = {
	    equals: function (first, second) { return first === second; }
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Ord = {
	    equals: exports.Eq.equals,
	    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Bounded = {
	    equals: exports.Eq.equals,
	    compare: exports.Ord.compare,
	    top: Infinity,
	    bottom: -Infinity
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Show = {
	    show: function (n) { return JSON.stringify(n); }
	};
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.MagmaSub = {
	    concat: function (first, second) { return first - second; }
	};
	/**
	 * `number` semigroup under addition.
	 *
	 * @example
	 * import { SemigroupSum } from 'fp-ts/number'
	 *
	 * assert.deepStrictEqual(SemigroupSum.concat(2, 3), 5)
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	exports.SemigroupSum = {
	    concat: function (first, second) { return first + second; }
	};
	/**
	 * `number` semigroup under multiplication.
	 *
	 * @example
	 * import { SemigroupProduct } from 'fp-ts/number'
	 *
	 * assert.deepStrictEqual(SemigroupProduct.concat(2, 3), 6)
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	exports.SemigroupProduct = {
	    concat: function (first, second) { return first * second; }
	};
	/**
	 * `number` monoid under addition.
	 *
	 * The `empty` value is `0`.
	 *
	 * @example
	 * import { MonoidSum } from 'fp-ts/number'
	 *
	 * assert.deepStrictEqual(MonoidSum.concat(2, MonoidSum.empty), 2)
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	exports.MonoidSum = {
	    concat: exports.SemigroupSum.concat,
	    empty: 0
	};
	/**
	 * `number` monoid under multiplication.
	 *
	 * The `empty` value is `1`.
	 *
	 * @example
	 * import { MonoidProduct } from 'fp-ts/number'
	 *
	 * assert.deepStrictEqual(MonoidProduct.concat(2, MonoidProduct.empty), 2)
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	exports.MonoidProduct = {
	    concat: exports.SemigroupProduct.concat,
	    empty: 1
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Field = {
	    add: exports.SemigroupSum.concat,
	    zero: 0,
	    mul: exports.SemigroupProduct.concat,
	    one: 1,
	    sub: exports.MagmaSub.concat,
	    degree: function (_) { return 1; },
	    div: function (first, second) { return first / second; },
	    mod: function (first, second) { return first % second; }
	}; 
} (number));

var Separated = {};

(function (exports) {
	/**
	 * ```ts
	 * interface Separated<E, A> {
	 *    readonly left: E
	 *    readonly right: A
	 * }
	 * ```
	 *
	 * Represents a result of separating a whole into two parts.
	 *
	 * @since 2.10.0
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
	var function_1 = _function;
	var Functor_1 = Functor;
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * @category constructors
	 * @since 2.10.0
	 */
	var separated = function (left, right) { return ({ left: left, right: right }); };
	exports.separated = separated;
	var _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };
	var _mapLeft = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f)); };
	var _bimap = function (fa, g, f) { return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f)); };
	/**
	 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
	 * use the type constructor `F` to represent some computational context.
	 *
	 * @category mapping
	 * @since 2.10.0
	 */
	var map = function (f) {
	    return function (fa) {
	        return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));
	    };
	};
	exports.map = map;
	/**
	 * Map a function over the first type argument of a bifunctor.
	 *
	 * @category error handling
	 * @since 2.10.0
	 */
	var mapLeft = function (f) {
	    return function (fa) {
	        return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));
	    };
	};
	exports.mapLeft = mapLeft;
	/**
	 * Map a pair of functions over the two type arguments of the bifunctor.
	 *
	 * @category mapping
	 * @since 2.10.0
	 */
	var bimap = function (f, g) {
	    return function (fa) {
	        return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));
	    };
	};
	exports.bimap = bimap;
	/**
	 * @category type lambdas
	 * @since 2.10.0
	 */
	exports.URI = 'Separated';
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Bifunctor = {
	    URI: exports.URI,
	    mapLeft: _mapLeft,
	    bimap: _bimap
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Functor = {
	    URI: exports.URI,
	    map: _map
	};
	/**
	 * @category mapping
	 * @since 2.10.0
	 */
	exports.flap = (0, Functor_1.flap)(exports.Functor);
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * @since 2.10.0
	 */
	var left = function (s) { return s.left; };
	exports.left = left;
	/**
	 * @since 2.10.0
	 */
	var right = function (s) { return s.right; };
	exports.right = right; 
} (Separated));

var Witherable = {};

var __createBinding$2 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$2 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$2 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
    __setModuleDefault$2(result, mod);
    return result;
};
Object.defineProperty(Witherable, "__esModule", { value: true });
Witherable.filterE = Witherable.witherDefault = Witherable.wiltDefault = void 0;
var _ = __importStar$2(internal);
function wiltDefault(T, C) {
    return function (F) {
        var traverseF = T.traverse(F);
        return function (wa, f) { return F.map(traverseF(wa, f), C.separate); };
    };
}
Witherable.wiltDefault = wiltDefault;
function witherDefault(T, C) {
    return function (F) {
        var traverseF = T.traverse(F);
        return function (wa, f) { return F.map(traverseF(wa, f), C.compact); };
    };
}
Witherable.witherDefault = witherDefault;
function filterE(W) {
    return function (F) {
        var witherF = W.wither(F);
        return function (predicate) { return function (ga) { return witherF(ga, function (a) { return F.map(predicate(a), function (b) { return (b ? _.some(a) : _.none); }); }); }; };
    };
}
Witherable.filterE = filterE;

var Zero = {};

Object.defineProperty(Zero, "__esModule", { value: true });
Zero.guard = void 0;
function guard(F, P) {
    return function (b) { return (b ? P.of(undefined) : F.zero()); };
}
Zero.guard = guard;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sort = exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
	exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.foldMap = exports.reduce = exports.foldMapWithIndex = exports.duplicate = exports.extend = exports.filterWithIndex = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.filter = exports.separate = exports.mapWithIndex = exports.map = exports.flatten = exports.flatMap = exports.ap = exports.alt = exports.altW = exports.zero = exports.of = exports._chainRecBreadthFirst = exports._chainRecDepthFirst = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = void 0;
	exports.toArray = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.Witherable = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = exports.traverseWithIndex = void 0;
	exports.readonlyArray = exports.prependToAll = exports.snoc = exports.cons = exports.range = exports.chain = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.intercalate = exports.exists = exports.some = exports.every = exports.empty = exports.fromArray = void 0;
	var Apply_1 = Apply;
	var Chain_1 = Chain;
	var Eq_1 = Eq;
	var FromEither_1 = FromEither;
	var function_1 = _function;
	var Functor_1 = Functor;
	var _ = __importStar(internal);
	var N = __importStar(number);
	var Ord_1 = Ord;
	var RNEA = __importStar(ReadonlyNonEmptyArray);
	var Separated_1 = Separated;
	var Witherable_1 = Witherable;
	var Zero_1 = Zero;
	// -------------------------------------------------------------------------------------
	// refinements
	// -------------------------------------------------------------------------------------
	/**
	 * Test whether a `ReadonlyArray` is empty.
	 *
	 * @example
	 * import { isEmpty } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.strictEqual(isEmpty([]), true)
	 *
	 * @category refinements
	 * @since 2.5.0
	 */
	var isEmpty = function (as) { return as.length === 0; };
	exports.isEmpty = isEmpty;
	/**
	 * Test whether a `ReadonlyArray` is non empty.
	 *
	 * @category refinements
	 * @since 2.5.0
	 */
	exports.isNonEmpty = RNEA.isNonEmpty;
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.
	 *
	 * @example
	 * import { prepend } from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])
	 *
	 * @since 2.10.0
	 */
	exports.prepend = RNEA.prepend;
	/**
	 * Less strict version of [`prepend`](#prepend).
	 *
	 * @since 2.11.0
	 */
	exports.prependW = RNEA.prependW;
	/**
	 * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.
	 *
	 * @example
	 * import { append } from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])
	 *
	 * @since 2.10.0
	 */
	exports.append = RNEA.append;
	/**
	 * Less strict version of [`append`](#append).
	 *
	 * @since 2.11.0
	 */
	exports.appendW = RNEA.appendW;
	/**
	 * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import { makeBy } from 'fp-ts/ReadonlyArray'
	 *
	 * const double = (n: number): number => n * 2
	 * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])
	 *
	 * @category constructors
	 * @since 2.5.0
	 */
	var makeBy = function (n, f) { return (n <= 0 ? exports.empty : RNEA.makeBy(f)(n)); };
	exports.makeBy = makeBy;
	/**
	 * Create a `ReadonlyArray` containing a value repeated the specified number of times.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import { replicate } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])
	 *
	 * @category constructors
	 * @since 2.5.0
	 */
	var replicate = function (n, a) { return (0, exports.makeBy)(n, function () { return a; }); };
	exports.replicate = replicate;
	function fromPredicate(predicate) {
	    return function (a) { return (predicate(a) ? [a] : exports.empty); };
	}
	exports.fromPredicate = fromPredicate;
	// -------------------------------------------------------------------------------------
	// conversions
	// -------------------------------------------------------------------------------------
	/**
	 * @category conversions
	 * @since 2.11.0
	 */
	var fromOption = function (ma) { return (_.isNone(ma) ? exports.empty : [ma.value]); };
	exports.fromOption = fromOption;
	/**
	 * Transforms an `Either` to a `ReadonlyArray`.
	 *
	 * @category conversions
	 * @since 2.11.0
	 */
	var fromEither = function (e) { return (_.isLeft(e) ? exports.empty : [e.right]); };
	exports.fromEither = fromEither;
	/**
	 * Less strict version of [`match`](#match).
	 *
	 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	var matchW = function (onEmpty, onNonEmpty) {
	    return function (as) {
	        return (0, exports.isNonEmpty)(as) ? onNonEmpty(as) : onEmpty();
	    };
	};
	exports.matchW = matchW;
	/**
	 * @category pattern matching
	 * @since 2.11.0
	 */
	exports.match = exports.matchW;
	/**
	 * Less strict version of [`matchLeft`](#matchleft).
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	var matchLeftW = function (onEmpty, onNonEmpty) {
	    return function (as) {
	        return (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();
	    };
	};
	exports.matchLeftW = matchLeftW;
	/**
	 * Break a `ReadonlyArray` into its first element and remaining elements.
	 *
	 * @example
	 * import { matchLeft } from 'fp-ts/ReadonlyArray'
	 *
	 * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))
	 * assert.strictEqual(len([1, 2, 3]), 3)
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.matchLeft = exports.matchLeftW;
	/**
	 * Alias of [`matchLeft`](#matchleft).
	 *
	 * @category pattern matching
	 * @since 2.5.0
	 */
	exports.foldLeft = exports.matchLeft;
	/**
	 * Less strict version of [`matchRight`](#matchright).
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	var matchRightW = function (onEmpty, onNonEmpty) {
	    return function (as) {
	        return (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();
	    };
	};
	exports.matchRightW = matchRightW;
	/**
	 * Break a `ReadonlyArray` into its initial elements and the last element.
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.matchRight = exports.matchRightW;
	/**
	 * Alias of [`matchRight`](#matchright).
	 *
	 * @category pattern matching
	 * @since 2.5.0
	 */
	exports.foldRight = exports.matchRight;
	// -------------------------------------------------------------------------------------
	// combinators
	// -------------------------------------------------------------------------------------
	/**
	 * @category sequencing
	 * @since 2.7.0
	 */
	var chainWithIndex = function (f) {
	    return function (as) {
	        if ((0, exports.isEmpty)(as)) {
	            return exports.empty;
	        }
	        var out = [];
	        for (var i = 0; i < as.length; i++) {
	            out.push.apply(out, f(i, as[i]));
	        }
	        return out;
	    };
	};
	exports.chainWithIndex = chainWithIndex;
	/**
	 * Same as `reduce` but it carries over the intermediate steps.
	 *
	 * @example
	 * import { scanLeft } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])
	 *
	 * @since 2.5.0
	 */
	var scanLeft = function (b, f) {
	    return function (as) {
	        var len = as.length;
	        var out = new Array(len + 1);
	        out[0] = b;
	        for (var i = 0; i < len; i++) {
	            out[i + 1] = f(out[i], as[i]);
	        }
	        return out;
	    };
	};
	exports.scanLeft = scanLeft;
	/**
	 * Fold an array from the right, keeping all intermediate results instead of only the final result
	 *
	 * @example
	 * import { scanRight } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])
	 *
	 * @since 2.5.0
	 */
	var scanRight = function (b, f) {
	    return function (as) {
	        var len = as.length;
	        var out = new Array(len + 1);
	        out[len] = b;
	        for (var i = len - 1; i >= 0; i--) {
	            out[i] = f(as[i], out[i + 1]);
	        }
	        return out;
	    };
	};
	exports.scanRight = scanRight;
	/**
	 * Calculate the number of elements in a `ReadonlyArray`.
	 *
	 * @since 2.10.0
	 */
	var size = function (as) { return as.length; };
	exports.size = size;
	/**
	 * Test whether an array contains a particular index
	 *
	 * @since 2.5.0
	 */
	exports.isOutOfBound = RNEA.isOutOfBound;
	function lookup(i, as) {
	    return as === undefined ? function (as) { return lookup(i, as); } : (0, exports.isOutOfBound)(i, as) ? _.none : _.some(as[i]);
	}
	exports.lookup = lookup;
	/**
	 * Get the first element in an array, or `None` if the array is empty
	 *
	 * @example
	 * import { head } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(head([1, 2, 3]), some(1))
	 * assert.deepStrictEqual(head([]), none)
	 *
	 * @since 2.5.0
	 */
	var head = function (as) { return ((0, exports.isNonEmpty)(as) ? _.some(RNEA.head(as)) : _.none); };
	exports.head = head;
	/**
	 * Get the last element in an array, or `None` if the array is empty
	 *
	 * @example
	 * import { last } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(last([1, 2, 3]), some(3))
	 * assert.deepStrictEqual(last([]), none)
	 *
	 * @since 2.5.0
	 */
	var last = function (as) { return ((0, exports.isNonEmpty)(as) ? _.some(RNEA.last(as)) : _.none); };
	exports.last = last;
	/**
	 * Get all but the first element of an array, creating a new array, or `None` if the array is empty
	 *
	 * @example
	 * import { tail } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))
	 * assert.deepStrictEqual(tail([]), none)
	 *
	 * @since 2.5.0
	 */
	var tail = function (as) {
	    return (0, exports.isNonEmpty)(as) ? _.some(RNEA.tail(as)) : _.none;
	};
	exports.tail = tail;
	/**
	 * Get all but the last element of an array, creating a new array, or `None` if the array is empty
	 *
	 * @example
	 * import { init } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))
	 * assert.deepStrictEqual(init([]), none)
	 *
	 * @since 2.5.0
	 */
	var init = function (as) {
	    return (0, exports.isNonEmpty)(as) ? _.some(RNEA.init(as)) : _.none;
	};
	exports.init = init;
	/**
	 * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const input: ReadonlyArray<number> = [1, 2, 3]
	 * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])
	 *
	 * // out of bounds
	 * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)
	 * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)
	 *
	 * @since 2.5.0
	 */
	var takeLeft = function (n) {
	    return function (as) {
	        return (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(0, n);
	    };
	};
	exports.takeLeft = takeLeft;
	/**
	 * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const input: ReadonlyArray<number> = [1, 2, 3]
	 * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])
	 *
	 * // out of bounds
	 * assert.strictEqual(pipe(input, RA.takeRight(4)), input)
	 * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)
	 *
	 * @since 2.5.0
	 */
	var takeRight = function (n) {
	    return function (as) {
	        return (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(-n);
	    };
	};
	exports.takeRight = takeRight;
	function takeLeftWhile(predicate) {
	    return function (as) {
	        var out = [];
	        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
	            var a = as_1[_i];
	            if (!predicate(a)) {
	                break;
	            }
	            out.push(a);
	        }
	        var len = out.length;
	        return len === as.length ? as : len === 0 ? exports.empty : out;
	    };
	}
	exports.takeLeftWhile = takeLeftWhile;
	var spanLeftIndex = function (as, predicate) {
	    var l = as.length;
	    var i = 0;
	    for (; i < l; i++) {
	        if (!predicate(as[i])) {
	            break;
	        }
	    }
	    return i;
	};
	function spanLeft(predicate) {
	    return function (as) {
	        var _a = (0, exports.splitAt)(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];
	        return { init: init, rest: rest };
	    };
	}
	exports.spanLeft = spanLeft;
	/**
	 * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const input: ReadonlyArray<number> = [1, 2, 3]
	 * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])
	 * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)
	 * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)
	 *
	 * @since 2.5.0
	 */
	var dropLeft = function (n) {
	    return function (as) {
	        return n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(n, as.length);
	    };
	};
	exports.dropLeft = dropLeft;
	/**
	 * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const input: ReadonlyArray<number> = [1, 2, 3]
	 * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])
	 * assert.strictEqual(pipe(input, RA.dropRight(0)), input)
	 * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)
	 *
	 * @since 2.5.0
	 */
	var dropRight = function (n) {
	    return function (as) {
	        return n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(0, as.length - n);
	    };
	};
	exports.dropRight = dropRight;
	function dropLeftWhile(predicate) {
	    return function (as) {
	        var i = spanLeftIndex(as, predicate);
	        return i === 0 ? as : i === as.length ? exports.empty : as.slice(i);
	    };
	}
	exports.dropLeftWhile = dropLeftWhile;
	/**
	 * Find the first index for which a predicate holds
	 *
	 * @example
	 * import { findIndex } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))
	 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)
	 *
	 * @since 2.5.0
	 */
	var findIndex = function (predicate) {
	    return function (as) {
	        for (var i = 0; i < as.length; i++) {
	            if (predicate(as[i])) {
	                return _.some(i);
	            }
	        }
	        return _.none;
	    };
	};
	exports.findIndex = findIndex;
	function findFirst(predicate) {
	    return function (as) {
	        for (var i = 0; i < as.length; i++) {
	            if (predicate(as[i])) {
	                return _.some(as[i]);
	            }
	        }
	        return _.none;
	    };
	}
	exports.findFirst = findFirst;
	/**
	 * Find the first element returned by an option based selector function
	 *
	 * @example
	 * import { findFirstMap } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * interface Person {
	 *   readonly name: string
	 *   readonly age?: number
	 * }
	 *
	 * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]
	 *
	 * // returns the name of the first person that has an age
	 * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))
	 *
	 * @since 2.5.0
	 */
	var findFirstMap = function (f) {
	    return function (as) {
	        for (var i = 0; i < as.length; i++) {
	            var out = f(as[i]);
	            if (_.isSome(out)) {
	                return out;
	            }
	        }
	        return _.none;
	    };
	};
	exports.findFirstMap = findFirstMap;
	function findLast(predicate) {
	    return function (as) {
	        for (var i = as.length - 1; i >= 0; i--) {
	            if (predicate(as[i])) {
	                return _.some(as[i]);
	            }
	        }
	        return _.none;
	    };
	}
	exports.findLast = findLast;
	/**
	 * Find the last element returned by an option based selector function
	 *
	 * @example
	 * import { findLastMap } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * interface Person {
	 *   readonly name: string
	 *   readonly age?: number
	 * }
	 *
	 * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]
	 *
	 * // returns the name of the last person that has an age
	 * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))
	 *
	 * @since 2.5.0
	 */
	var findLastMap = function (f) {
	    return function (as) {
	        for (var i = as.length - 1; i >= 0; i--) {
	            var out = f(as[i]);
	            if (_.isSome(out)) {
	                return out;
	            }
	        }
	        return _.none;
	    };
	};
	exports.findLastMap = findLastMap;
	/**
	 * Returns the index of the last element of the list which matches the predicate
	 *
	 * @example
	 * import { findLastIndex } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * interface X {
	 *   readonly a: number
	 *   readonly b: number
	 * }
	 * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]
	 * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))
	 * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)
	 *
	 *
	 * @since 2.5.0
	 */
	var findLastIndex = function (predicate) {
	    return function (as) {
	        for (var i = as.length - 1; i >= 0; i--) {
	            if (predicate(as[i])) {
	                return _.some(i);
	            }
	        }
	        return _.none;
	    };
	};
	exports.findLastIndex = findLastIndex;
	/**
	 * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds
	 *
	 * @example
	 * import { insertAt } from 'fp-ts/ReadonlyArray'
	 * import { some } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))
	 *
	 * @since 2.5.0
	 */
	var insertAt = function (i, a) {
	    return function (as) {
	        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));
	    };
	};
	exports.insertAt = insertAt;
	/**
	 * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds
	 *
	 * @example
	 * import { updateAt } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))
	 * assert.deepStrictEqual(updateAt(1, 1)([]), none)
	 *
	 * @since 2.5.0
	 */
	var updateAt = function (i, a) {
	    return (0, exports.modifyAt)(i, function () { return a; });
	};
	exports.updateAt = updateAt;
	/**
	 * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds
	 *
	 * @example
	 * import { deleteAt } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))
	 * assert.deepStrictEqual(deleteAt(1)([]), none)
	 *
	 * @since 2.5.0
	 */
	var deleteAt = function (i) {
	    return function (as) {
	        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeDeleteAt)(i, as));
	    };
	};
	exports.deleteAt = deleteAt;
	/**
	 * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out
	 * of bounds
	 *
	 * @example
	 * import { modifyAt } from 'fp-ts/ReadonlyArray'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * const double = (x: number): number => x * 2
	 * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))
	 * assert.deepStrictEqual(modifyAt(1, double)([]), none)
	 *
	 * @since 2.5.0
	 */
	var modifyAt = function (i, f) {
	    return function (as) {
	        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
	    };
	};
	exports.modifyAt = modifyAt;
	/**
	 * Reverse an array, creating a new array
	 *
	 * @example
	 * import { reverse } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])
	 *
	 * @since 2.5.0
	 */
	var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };
	exports.reverse = reverse;
	/**
	 * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order
	 *
	 * @example
	 * import { rights } from 'fp-ts/ReadonlyArray'
	 * import { right, left } from 'fp-ts/Either'
	 *
	 * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])
	 *
	 * @since 2.5.0
	 */
	var rights = function (as) {
	    var r = [];
	    for (var i = 0; i < as.length; i++) {
	        var a = as[i];
	        if (a._tag === 'Right') {
	            r.push(a.right);
	        }
	    }
	    return r;
	};
	exports.rights = rights;
	/**
	 * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order
	 *
	 * @example
	 * import { lefts } from 'fp-ts/ReadonlyArray'
	 * import { left, right } from 'fp-ts/Either'
	 *
	 * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])
	 *
	 * @since 2.5.0
	 */
	var lefts = function (as) {
	    var r = [];
	    for (var i = 0; i < as.length; i++) {
	        var a = as[i];
	        if (a._tag === 'Left') {
	            r.push(a.left);
	        }
	    }
	    return r;
	};
	exports.lefts = lefts;
	/**
	 * Sort the elements of an array in increasing order, creating a new array
	 *
	 * @example
	 * import { sort } from 'fp-ts/ReadonlyArray'
	 * import * as N from 'fp-ts/number'
	 *
	 * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])
	 *
	 * @since 2.5.0
	 */
	var sort = function (O) {
	    return function (as) {
	        return as.length <= 1 ? as : as.slice().sort(O.compare);
	    };
	};
	exports.sort = sort;
	// TODO: curry and make data-last in v3
	/**
	 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one
	 * input array is short, excess elements of the longer array are discarded.
	 *
	 * @example
	 * import { zipWith } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])
	 *
	 * @since 2.5.0
	 */
	var zipWith = function (fa, fb, f) {
	    var fc = [];
	    var len = Math.min(fa.length, fb.length);
	    for (var i = 0; i < len; i++) {
	        fc[i] = f(fa[i], fb[i]);
	    }
	    return fc;
	};
	exports.zipWith = zipWith;
	function zip(as, bs) {
	    if (bs === undefined) {
	        return function (bs) { return zip(bs, as); };
	    }
	    return (0, exports.zipWith)(as, bs, function (a, b) { return [a, b]; });
	}
	exports.zip = zip;
	/**
	 * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays
	 *
	 * @example
	 * import { unzip } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])
	 *
	 * @since 2.5.0
	 */
	var unzip = function (as) {
	    var fa = [];
	    var fb = [];
	    for (var i = 0; i < as.length; i++) {
	        fa[i] = as[i][0];
	        fb[i] = as[i][1];
	    }
	    return [fa, fb];
	};
	exports.unzip = unzip;
	/**
	 * Prepend an element to every member of an array
	 *
	 * @example
	 * import { prependAll } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
	 *
	 * @since 2.10.0
	 */
	var prependAll = function (middle) {
	    var f = RNEA.prependAll(middle);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : as); };
	};
	exports.prependAll = prependAll;
	/**
	 * Places an element in between members of an array
	 *
	 * @example
	 * import { intersperse } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
	 *
	 * @since 2.9.0
	 */
	var intersperse = function (middle) {
	    var f = RNEA.intersperse(middle);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : as); };
	};
	exports.intersperse = intersperse;
	/**
	 * Rotate a `ReadonlyArray` by `n` steps.
	 *
	 * @example
	 * import { rotate } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
	 *
	 * @since 2.5.0
	 */
	var rotate = function (n) {
	    var f = RNEA.rotate(n);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : as); };
	};
	exports.rotate = rotate;
	function elem(E) {
	    return function (a, as) {
	        if (as === undefined) {
	            var elemE_1 = elem(E);
	            return function (as) { return elemE_1(a, as); };
	        }
	        var predicate = function (element) { return E.equals(element, a); };
	        var i = 0;
	        for (; i < as.length; i++) {
	            if (predicate(as[i])) {
	                return true;
	            }
	        }
	        return false;
	    };
	}
	exports.elem = elem;
	/**
	 * Remove duplicates from an array, keeping the first occurrence of an element.
	 *
	 * @example
	 * import { uniq } from 'fp-ts/ReadonlyArray'
	 * import * as N from 'fp-ts/number'
	 *
	 * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
	 *
	 * @since 2.5.0
	 */
	var uniq = function (E) {
	    var f = RNEA.uniq(E);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : as); };
	};
	exports.uniq = uniq;
	/**
	 * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
	 * etc...
	 *
	 * @example
	 * import { sortBy } from 'fp-ts/ReadonlyArray'
	 * import { contramap } from 'fp-ts/Ord'
	 * import * as S from 'fp-ts/string'
	 * import * as N from 'fp-ts/number'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * interface Person {
	 *   readonly name: string
	 *   readonly age: number
	 * }
	 * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
	 * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
	 *
	 * const sortByNameByAge = sortBy([byName, byAge])
	 *
	 * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]
	 * assert.deepStrictEqual(sortByNameByAge(persons), [
	 *   { name: 'a', age: 1 },
	 *   { name: 'b', age: 2 },
	 *   { name: 'b', age: 3 },
	 *   { name: 'c', age: 2 }
	 * ])
	 *
	 * @since 2.5.0
	 */
	var sortBy = function (ords) {
	    var f = RNEA.sortBy(ords);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : as); };
	};
	exports.sortBy = sortBy;
	/**
	 * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for "chopping" up the input
	 * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a
	 * value and the tail of the `ReadonlyArray`.
	 *
	 * @example
	 * import { Eq } from 'fp-ts/Eq'
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import * as N from 'fp-ts/number'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {
	 *   return RA.chop(as => {
	 *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))
	 *     return [init, rest]
	 *   })
	 * }
	 * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])
	 *
	 * @since 2.5.0
	 */
	var chop = function (f) {
	    var g = RNEA.chop(f);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? g(as) : exports.empty); };
	};
	exports.chop = chop;
	/**
	 * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.
	 *
	 * @example
	 * import { splitAt } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])
	 *
	 * @since 2.5.0
	 */
	var splitAt = function (n) {
	    return function (as) {
	        return n >= 1 && (0, exports.isNonEmpty)(as) ? RNEA.splitAt(n)(as) : (0, exports.isEmpty)(as) ? [as, exports.empty] : [exports.empty, as];
	    };
	};
	exports.splitAt = splitAt;
	/**
	 * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
	 * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
	 * definition of `chunksOf`; it satisfies the property that:
	 *
	 * ```ts
	 * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
	 * ```
	 *
	 * whenever `n` evenly divides the length of `as`.
	 *
	 * @example
	 * import { chunksOf } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])
	 *
	 * @since 2.5.0
	 */
	var chunksOf = function (n) {
	    var f = RNEA.chunksOf(n);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : exports.empty); };
	};
	exports.chunksOf = chunksOf;
	/**
	 * @category lifting
	 * @since 2.11.0
	 */
	var fromOptionK = function (f) {
	    return function () {
	        var a = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            a[_i] = arguments[_i];
	        }
	        return (0, exports.fromOption)(f.apply(void 0, a));
	    };
	};
	exports.fromOptionK = fromOptionK;
	function comprehension(input, f, g) {
	    if (g === void 0) { g = function () { return true; }; }
	    var go = function (scope, input) {
	        return (0, exports.isNonEmpty)(input)
	            ? (0, exports.flatMap)(RNEA.head(input), function (a) { return go((0, function_1.pipe)(scope, (0, exports.append)(a)), RNEA.tail(input)); })
	            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]
	                : exports.empty;
	    };
	    return go(exports.empty, input);
	}
	exports.comprehension = comprehension;
	/**
	 * @since 2.11.0
	 */
	var concatW = function (second) {
	    return function (first) {
	        return (0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second);
	    };
	};
	exports.concatW = concatW;
	/**
	 * @since 2.11.0
	 */
	exports.concat = exports.concatW;
	function union(E) {
	    var unionE = RNEA.union(E);
	    return function (first, second) {
	        if (second === undefined) {
	            var unionE_1 = union(E);
	            return function (second) { return unionE_1(second, first); };
	        }
	        return (0, exports.isNonEmpty)(first) && (0, exports.isNonEmpty)(second) ? unionE(second)(first) : (0, exports.isNonEmpty)(first) ? first : second;
	    };
	}
	exports.union = union;
	function intersection(E) {
	    var elemE = elem(E);
	    return function (xs, ys) {
	        if (ys === undefined) {
	            var intersectionE_1 = intersection(E);
	            return function (ys) { return intersectionE_1(ys, xs); };
	        }
	        return xs.filter(function (a) { return elemE(a, ys); });
	    };
	}
	exports.intersection = intersection;
	function difference(E) {
	    var elemE = elem(E);
	    return function (xs, ys) {
	        if (ys === undefined) {
	            var differenceE_1 = difference(E);
	            return function (ys) { return differenceE_1(ys, xs); };
	        }
	        return xs.filter(function (a) { return !elemE(a, ys); });
	    };
	}
	exports.difference = difference;
	var _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };
	var _mapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f)); };
	var _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };
	var _filter = function (fa, predicate) {
	    return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
	};
	var _filterMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.filterMap)(f)); };
	var _partition = function (fa, predicate) {
	    return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
	};
	var _partitionMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f)); };
	var _partitionWithIndex = function (fa, predicateWithIndex) { return (0, function_1.pipe)(fa, (0, exports.partitionWithIndex)(predicateWithIndex)); };
	var _partitionMapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f)); };
	var _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };
	var _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };
	var _foldMap = function (M) {
	    var foldMapM = (0, exports.foldMap)(M);
	    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };
	};
	var _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };
	var _reduceWithIndex = function (fa, b, f) {
	    return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
	};
	var _foldMapWithIndex = function (M) {
	    var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
	    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapWithIndexM(f)); };
	};
	var _reduceRightWithIndex = function (fa, b, f) {
	    return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
	};
	var _filterMapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f)); };
	var _filterWithIndex = function (fa, predicateWithIndex) { return (0, function_1.pipe)(fa, (0, exports.filterWithIndex)(predicateWithIndex)); };
	var _extend = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.extend)(f)); };
	var _traverse = function (F) {
	    var traverseF = (0, exports.traverse)(F);
	    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };
	};
	/* istanbul ignore next */
	var _traverseWithIndex = function (F) {
	    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
	    return function (ta, f) { return (0, function_1.pipe)(ta, traverseWithIndexF(f)); };
	};
	/** @internal */
	var _chainRecDepthFirst = function (a, f) { return (0, function_1.pipe)(a, (0, exports.chainRecDepthFirst)(f)); };
	exports._chainRecDepthFirst = _chainRecDepthFirst;
	/** @internal */
	var _chainRecBreadthFirst = function (a, f) { return (0, function_1.pipe)(a, (0, exports.chainRecBreadthFirst)(f)); };
	exports._chainRecBreadthFirst = _chainRecBreadthFirst;
	/**
	 * @category constructors
	 * @since 2.5.0
	 */
	exports.of = RNEA.of;
	/**
	 * @since 2.7.0
	 */
	var zero = function () { return exports.empty; };
	exports.zero = zero;
	/**
	 * Less strict version of [`alt`](#alt).
	 *
	 * The `W` suffix (short for **W**idening) means that the return types will be merged.
	 *
	 * @example
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     RA.altW(() => ['a', 'b'])
	 *   ),
	 *   [1, 2, 3, 'a', 'b']
	 * )
	 *
	 * @category error handling
	 * @since 2.9.0
	 */
	var altW = function (that) {
	    return function (fa) {
	        return fa.concat(that());
	    };
	};
	exports.altW = altW;
	/**
	 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
	 * types of kind `* -> *`.
	 *
	 * In case of `ReadonlyArray` concatenates the inputs into a single array.
	 *
	 * @example
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     RA.alt(() => [4, 5])
	 *   ),
	 *   [1, 2, 3, 4, 5]
	 * )
	 *
	 * @category error handling
	 * @since 2.5.0
	 */
	exports.alt = exports.altW;
	/**
	 * @since 2.5.0
	 */
	var ap = function (fa) {
	    return (0, exports.flatMap)(function (f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); });
	};
	exports.ap = ap;
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation.
	 *
	 * @example
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     RA.flatMap((n) => [`a${n}`, `b${n}`])
	 *   ),
	 *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     RA.flatMap(() => [])
	 *   ),
	 *   []
	 * )
	 *
	 * @category sequencing
	 * @since 2.14.0
	 */
	exports.flatMap = (0, function_1.dual)(2, function (ma, f) {
	    return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function (i, a) { return f(a, i); }));
	});
	/**
	 * @category sequencing
	 * @since 2.5.0
	 */
	exports.flatten = (0, exports.flatMap)(function_1.identity);
	/**
	 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
	 * use the type constructor `F` to represent some computational context.
	 *
	 * @category mapping
	 * @since 2.5.0
	 */
	var map = function (f) { return function (fa) {
	    return fa.map(function (a) { return f(a); });
	}; };
	exports.map = map;
	/**
	 * @category mapping
	 * @since 2.5.0
	 */
	var mapWithIndex = function (f) { return function (fa) {
	    return fa.map(function (a, i) { return f(i, a); });
	}; };
	exports.mapWithIndex = mapWithIndex;
	/**
	 * @category filtering
	 * @since 2.5.0
	 */
	var separate = function (fa) {
	    var left = [];
	    var right = [];
	    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
	        var e = fa_1[_i];
	        if (e._tag === 'Left') {
	            left.push(e.left);
	        }
	        else {
	            right.push(e.right);
	        }
	    }
	    return (0, Separated_1.separated)(left, right);
	};
	exports.separate = separate;
	/**
	 * @category filtering
	 * @since 2.5.0
	 */
	var filter = function (predicate) {
	    return function (as) {
	        return as.filter(predicate);
	    };
	};
	exports.filter = filter;
	/**
	 * @category filtering
	 * @since 2.5.0
	 */
	var filterMapWithIndex = function (f) {
	    return function (fa) {
	        var out = [];
	        for (var i = 0; i < fa.length; i++) {
	            var optionB = f(i, fa[i]);
	            if (_.isSome(optionB)) {
	                out.push(optionB.value);
	            }
	        }
	        return out;
	    };
	};
	exports.filterMapWithIndex = filterMapWithIndex;
	/**
	 * @category filtering
	 * @since 2.5.0
	 */
	var filterMap = function (f) {
	    return (0, exports.filterMapWithIndex)(function (_, a) { return f(a); });
	};
	exports.filterMap = filterMap;
	/**
	 * @category filtering
	 * @since 2.5.0
	 */
	exports.compact = (0, exports.filterMap)(function_1.identity);
	/**
	 * @category filtering
	 * @since 2.5.0
	 */
	var partition = function (predicate) {
	    return (0, exports.partitionWithIndex)(function (_, a) { return predicate(a); });
	};
	exports.partition = partition;
	/**
	 * @category filtering
	 * @since 2.5.0
	 */
	var partitionWithIndex = function (predicateWithIndex) {
	    return function (as) {
	        var left = [];
	        var right = [];
	        for (var i = 0; i < as.length; i++) {
	            var a = as[i];
	            if (predicateWithIndex(i, a)) {
	                right.push(a);
	            }
	            else {
	                left.push(a);
	            }
	        }
	        return (0, Separated_1.separated)(left, right);
	    };
	};
	exports.partitionWithIndex = partitionWithIndex;
	/**
	 * @category filtering
	 * @since 2.5.0
	 */
	var partitionMap = function (f) {
	    return (0, exports.partitionMapWithIndex)(function (_, a) { return f(a); });
	};
	exports.partitionMap = partitionMap;
	/**
	 * @category filtering
	 * @since 2.5.0
	 */
	var partitionMapWithIndex = function (f) {
	    return function (fa) {
	        var left = [];
	        var right = [];
	        for (var i = 0; i < fa.length; i++) {
	            var e = f(i, fa[i]);
	            if (e._tag === 'Left') {
	                left.push(e.left);
	            }
	            else {
	                right.push(e.right);
	            }
	        }
	        return (0, Separated_1.separated)(left, right);
	    };
	};
	exports.partitionMapWithIndex = partitionMapWithIndex;
	/**
	 * @category filtering
	 * @since 2.5.0
	 */
	var filterWithIndex = function (predicateWithIndex) {
	    return function (as) {
	        return as.filter(function (a, i) { return predicateWithIndex(i, a); });
	    };
	};
	exports.filterWithIndex = filterWithIndex;
	/**
	 * @since 2.5.0
	 */
	var extend = function (f) { return function (wa) {
	    return wa.map(function (_, i) { return f(wa.slice(i)); });
	}; };
	exports.extend = extend;
	/**
	 * @since 2.5.0
	 */
	exports.duplicate = (0, exports.extend)(function_1.identity);
	/**
	 * @category folding
	 * @since 2.5.0
	 */
	var foldMapWithIndex = function (M) {
	    return function (f) {
	        return function (fa) {
	            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);
	        };
	    };
	};
	exports.foldMapWithIndex = foldMapWithIndex;
	/**
	 * @category folding
	 * @since 2.5.0
	 */
	var reduce = function (b, f) {
	    return (0, exports.reduceWithIndex)(b, function (_, b, a) { return f(b, a); });
	};
	exports.reduce = reduce;
	/**
	 * @category folding
	 * @since 2.5.0
	 */
	var foldMap = function (M) {
	    var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
	    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };
	};
	exports.foldMap = foldMap;
	/**
	 * @category folding
	 * @since 2.5.0
	 */
	var reduceWithIndex = function (b, f) { return function (fa) {
	    var len = fa.length;
	    var out = b;
	    for (var i = 0; i < len; i++) {
	        out = f(i, out, fa[i]);
	    }
	    return out;
	}; };
	exports.reduceWithIndex = reduceWithIndex;
	/**
	 * @category folding
	 * @since 2.5.0
	 */
	var reduceRight = function (b, f) {
	    return (0, exports.reduceRightWithIndex)(b, function (_, a, b) { return f(a, b); });
	};
	exports.reduceRight = reduceRight;
	/**
	 * @category folding
	 * @since 2.5.0
	 */
	var reduceRightWithIndex = function (b, f) { return function (fa) {
	    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);
	}; };
	exports.reduceRightWithIndex = reduceRightWithIndex;
	/**
	 * @category traversing
	 * @since 2.6.3
	 */
	var traverse = function (F) {
	    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
	    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
	};
	exports.traverse = traverse;
	/**
	 * @category traversing
	 * @since 2.6.3
	 */
	var sequence = function (F) {
	    return function (ta) {
	        return _reduce(ta, F.of((0, exports.zero)()), function (fas, fa) {
	            return F.ap(F.map(fas, function (as) { return function (a) { return (0, function_1.pipe)(as, (0, exports.append)(a)); }; }), fa);
	        });
	    };
	};
	exports.sequence = sequence;
	/**
	 * @category sequencing
	 * @since 2.6.3
	 */
	var traverseWithIndex = function (F) {
	    return function (f) {
	        return (0, exports.reduceWithIndex)(F.of((0, exports.zero)()), function (i, fbs, a) {
	            return F.ap(F.map(fbs, function (bs) { return function (b) { return (0, function_1.pipe)(bs, (0, exports.append)(b)); }; }), f(i, a));
	        });
	    };
	};
	exports.traverseWithIndex = traverseWithIndex;
	/**
	 * @category filtering
	 * @since 2.6.5
	 */
	var wither = function (F) {
	    var _witherF = _wither(F);
	    return function (f) { return function (fa) { return _witherF(fa, f); }; };
	};
	exports.wither = wither;
	/**
	 * @category filtering
	 * @since 2.6.5
	 */
	var wilt = function (F) {
	    var _wiltF = _wilt(F);
	    return function (f) { return function (fa) { return _wiltF(fa, f); }; };
	};
	exports.wilt = wilt;
	/**
	 * @since 2.6.6
	 */
	var unfold = function (b, f) {
	    var out = [];
	    var bb = b;
	    // eslint-disable-next-line no-constant-condition
	    while (true) {
	        var mt = f(bb);
	        if (_.isSome(mt)) {
	            var _a = mt.value, a = _a[0], b_1 = _a[1];
	            out.push(a);
	            bb = b_1;
	        }
	        else {
	            break;
	        }
	    }
	    return out;
	};
	exports.unfold = unfold;
	/**
	 * @category type lambdas
	 * @since 2.5.0
	 */
	exports.URI = 'ReadonlyArray';
	/**
	 * @category instances
	 * @since 2.5.0
	 */
	var getShow = function (S) { return ({
	    show: function (as) { return "[".concat(as.map(S.show).join(', '), "]"); }
	}); };
	exports.getShow = getShow;
	/**
	 * @category instances
	 * @since 2.5.0
	 */
	var getSemigroup = function () { return ({
	    concat: function (first, second) { return ((0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second)); }
	}); };
	exports.getSemigroup = getSemigroup;
	/**
	 * Returns a `Monoid` for `ReadonlyArray<A>`.
	 *
	 * @example
	 * import { getMonoid } from 'fp-ts/ReadonlyArray'
	 *
	 * const M = getMonoid<number>()
	 * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])
	 *
	 * @category instances
	 * @since 2.5.0
	 */
	var getMonoid = function () { return ({
	    concat: (0, exports.getSemigroup)().concat,
	    empty: exports.empty
	}); };
	exports.getMonoid = getMonoid;
	/**
	 * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two
	 * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of
	 * different lengths, the result is non equality.
	 *
	 * @example
	 * import * as S from 'fp-ts/string'
	 * import { getEq } from 'fp-ts/ReadonlyArray'
	 *
	 * const E = getEq(S.Eq)
	 * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)
	 * assert.strictEqual(E.equals(['a'], []), false)
	 *
	 * @category instances
	 * @since 2.5.0
	 */
	var getEq = function (E) {
	    return (0, Eq_1.fromEquals)(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });
	};
	exports.getEq = getEq;
	/**
	 * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such
	 * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in
	 * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have
	 * the same length, the result is equality.
	 *
	 * @example
	 * import { getOrd } from 'fp-ts/ReadonlyArray'
	 * import * as S from 'fp-ts/string'
	 *
	 * const O = getOrd(S.Ord)
	 * assert.strictEqual(O.compare(['b'], ['a']), 1)
	 * assert.strictEqual(O.compare(['a'], ['a']), 0)
	 * assert.strictEqual(O.compare(['a'], ['b']), -1)
	 *
	 *
	 * @category instances
	 * @since 2.5.0
	 */
	var getOrd = function (O) {
	    return (0, Ord_1.fromCompare)(function (a, b) {
	        var aLen = a.length;
	        var bLen = b.length;
	        var len = Math.min(aLen, bLen);
	        for (var i = 0; i < len; i++) {
	            var ordering = O.compare(a[i], b[i]);
	            if (ordering !== 0) {
	                return ordering;
	            }
	        }
	        return N.Ord.compare(aLen, bLen);
	    });
	};
	exports.getOrd = getOrd;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	var getUnionSemigroup = function (E) {
	    var unionE = union(E);
	    return {
	        concat: function (first, second) { return unionE(second)(first); }
	    };
	};
	exports.getUnionSemigroup = getUnionSemigroup;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	var getUnionMonoid = function (E) { return ({
	    concat: (0, exports.getUnionSemigroup)(E).concat,
	    empty: exports.empty
	}); };
	exports.getUnionMonoid = getUnionMonoid;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	var getIntersectionSemigroup = function (E) {
	    var intersectionE = intersection(E);
	    return {
	        concat: function (first, second) { return intersectionE(second)(first); }
	    };
	};
	exports.getIntersectionSemigroup = getIntersectionSemigroup;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	var getDifferenceMagma = function (E) {
	    var differenceE = difference(E);
	    return {
	        concat: function (first, second) { return differenceE(second)(first); }
	    };
	};
	exports.getDifferenceMagma = getDifferenceMagma;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Functor = {
	    URI: exports.URI,
	    map: _map
	};
	/**
	 * @category mapping
	 * @since 2.10.0
	 */
	exports.flap = (0, Functor_1.flap)(exports.Functor);
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Pointed = {
	    URI: exports.URI,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.FunctorWithIndex = {
	    URI: exports.URI,
	    map: _map,
	    mapWithIndex: _mapWithIndex
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Apply = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap
	};
	/**
	 * Combine two effectful actions, keeping only the result of the first.
	 *
	 * @since 2.5.0
	 */
	exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
	/**
	 * Combine two effectful actions, keeping only the result of the second.
	 *
	 * @since 2.5.0
	 */
	exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Applicative = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Chain = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Monad = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    chain: exports.flatMap
	};
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @example
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     RA.chainFirst(() => ['a', 'b'])
	 *   ),
	 *   [1, 1, 2, 2, 3, 3]
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     RA.chainFirst(() => [])
	 *   ),
	 *   []
	 * )
	 *
	 * @category sequencing
	 * @since 2.5.0
	 */
	exports.chainFirst = 
	/*#__PURE__*/ (0, Chain_1.chainFirst)(exports.Chain);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Unfoldable = {
	    URI: exports.URI,
	    unfold: exports.unfold
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Alt = {
	    URI: exports.URI,
	    map: _map,
	    alt: _alt
	};
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.Zero = {
	    URI: exports.URI,
	    zero: exports.zero
	};
	/**
	 * @category do notation
	 * @since 2.11.0
	 */
	exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Alternative = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    alt: _alt,
	    zero: exports.zero
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Extend = {
	    URI: exports.URI,
	    map: _map,
	    extend: _extend
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Compactable = {
	    URI: exports.URI,
	    compact: exports.compact,
	    separate: exports.separate
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Filterable = {
	    URI: exports.URI,
	    map: _map,
	    compact: exports.compact,
	    separate: exports.separate,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.FilterableWithIndex = {
	    URI: exports.URI,
	    map: _map,
	    mapWithIndex: _mapWithIndex,
	    compact: exports.compact,
	    separate: exports.separate,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap,
	    partitionMapWithIndex: _partitionMapWithIndex,
	    partitionWithIndex: _partitionWithIndex,
	    filterMapWithIndex: _filterMapWithIndex,
	    filterWithIndex: _filterWithIndex
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Foldable = {
	    URI: exports.URI,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.FoldableWithIndex = {
	    URI: exports.URI,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Traversable = {
	    URI: exports.URI,
	    map: _map,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.TraversableWithIndex = {
	    URI: exports.URI,
	    map: _map,
	    mapWithIndex: _mapWithIndex,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    traverseWithIndex: _traverseWithIndex
	};
	/**
	 * @category sequencing
	 * @since 2.11.0
	 */
	var chainRecDepthFirst = function (f) {
	    return function (a) {
	        var todo = __spreadArray([], f(a), true);
	        var out = [];
	        while (todo.length > 0) {
	            var e = todo.shift();
	            if (_.isLeft(e)) {
	                todo.unshift.apply(todo, f(e.left));
	            }
	            else {
	                out.push(e.right);
	            }
	        }
	        return out;
	    };
	};
	exports.chainRecDepthFirst = chainRecDepthFirst;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.ChainRecDepthFirst = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap,
	    chainRec: exports._chainRecDepthFirst
	};
	/**
	 * @category sequencing
	 * @since 2.11.0
	 */
	var chainRecBreadthFirst = function (f) {
	    return function (a) {
	        var initial = f(a);
	        var todo = [];
	        var out = [];
	        function go(e) {
	            if (_.isLeft(e)) {
	                f(e.left).forEach(function (v) { return todo.push(v); });
	            }
	            else {
	                out.push(e.right);
	            }
	        }
	        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {
	            var e = initial_1[_i];
	            go(e);
	        }
	        while (todo.length > 0) {
	            go(todo.shift());
	        }
	        return out;
	    };
	};
	exports.chainRecBreadthFirst = chainRecBreadthFirst;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.ChainRecBreadthFirst = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap,
	    chainRec: exports._chainRecBreadthFirst
	};
	var _wither = /*#__PURE__*/ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
	var _wilt = /*#__PURE__*/ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Witherable = {
	    URI: exports.URI,
	    map: _map,
	    compact: exports.compact,
	    separate: exports.separate,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    wither: _wither,
	    wilt: _wilt
	};
	/**
	 * Filter values inside a context.
	 *
	 * @example
	 * import { pipe } from 'fp-ts/function'
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import * as T from 'fp-ts/Task'
	 *
	 * const filterE = RA.filterE(T.ApplicativePar)
	 * async function test() {
	 *   assert.deepStrictEqual(
	 *     await pipe(
	 *       [-1, 2, 3],
	 *       filterE((n) => T.of(n > 0))
	 *     )(),
	 *     [2, 3]
	 *   )
	 * }
	 * test()
	 *
	 * @since 2.11.0
	 */
	exports.filterE = (0, Witherable_1.filterE)(exports.Witherable);
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.FromEither = {
	    URI: exports.URI,
	    fromEither: exports.fromEither
	};
	/**
	 * @category lifting
	 * @since 2.11.0
	 */
	exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
	// -------------------------------------------------------------------------------------
	// unsafe
	// -------------------------------------------------------------------------------------
	/**
	 * @category unsafe
	 * @since 2.5.0
	 */
	exports.unsafeInsertAt = RNEA.unsafeInsertAt;
	/**
	 * @category unsafe
	 * @since 2.5.0
	 */
	var unsafeUpdateAt = function (i, a, as) {
	    return (0, exports.isNonEmpty)(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;
	};
	exports.unsafeUpdateAt = unsafeUpdateAt;
	/**
	 * @category unsafe
	 * @since 2.5.0
	 */
	var unsafeDeleteAt = function (i, as) {
	    var xs = as.slice();
	    xs.splice(i, 1);
	    return xs;
	};
	exports.unsafeDeleteAt = unsafeDeleteAt;
	/**
	 * @category conversions
	 * @since 2.5.0
	 */
	var toArray = function (as) { return as.slice(); };
	exports.toArray = toArray;
	/**
	 * @category conversions
	 * @since 2.5.0
	 */
	var fromArray = function (as) { return ((0, exports.isEmpty)(as) ? exports.empty : as.slice()); };
	exports.fromArray = fromArray;
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * An empty array
	 *
	 * @since 2.5.0
	 */
	exports.empty = RNEA.empty;
	function every(predicate) {
	    return function (as) { return as.every(predicate); };
	}
	exports.every = every;
	/**
	 * Check if a predicate holds true for any array member.
	 *
	 * @example
	 * import { some } from 'fp-ts/ReadonlyArray'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const isPositive = (n: number): boolean => n > 0
	 *
	 * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)
	 * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)
	 *
	 * @since 2.9.0
	 */
	var some = function (predicate) {
	    return function (as) {
	        return as.some(predicate);
	    };
	};
	exports.some = some;
	/**
	 * Alias of [`some`](#some)
	 *
	 * @since 2.11.0
	 */
	exports.exists = exports.some;
	/**
	 * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.
	 *
	 * @example
	 * import * as S from 'fp-ts/string'
	 * import { intercalate } from 'fp-ts/ReadonlyArray'
	 *
	 * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
	 *
	 * @since 2.12.0
	 */
	var intercalate = function (M) {
	    var intercalateM = RNEA.intercalate(M);
	    return function (middle) { return (0, exports.match)(function () { return M.empty; }, intercalateM(middle)); };
	};
	exports.intercalate = intercalate;
	// -------------------------------------------------------------------------------------
	// do notation
	// -------------------------------------------------------------------------------------
	/**
	 * @category do notation
	 * @since 2.9.0
	 */
	exports.Do = (0, exports.of)(_.emptyRecord);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
	var let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);
	exports.let = let_;
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bind = (0, Chain_1.bind)(exports.Chain);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.apS = (0, Apply_1.apS)(exports.Apply);
	// -------------------------------------------------------------------------------------
	// legacy
	// -------------------------------------------------------------------------------------
	/**
	 * Alias of `flatMap`.
	 *
	 * @category legacy
	 * @since 2.5.0
	 */
	exports.chain = exports.flatMap;
	// -------------------------------------------------------------------------------------
	// deprecated
	// -------------------------------------------------------------------------------------
	/**
	 * Use `ReadonlyNonEmptyArray` module instead.
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	exports.range = RNEA.range;
	/**
	 * Use [`prepend`](#prepend) instead.
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	exports.cons = RNEA.cons;
	/**
	 * Use [`append`](#append) instead.
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	exports.snoc = RNEA.snoc;
	/**
	 * Use [`prependAll`](#prependall) instead.
	 *
	 * @category zone of death
	 * @since 2.9.0
	 * @deprecated
	 */
	exports.prependToAll = exports.prependAll;
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`
	 * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)
	 *
	 * @category zone of death
	 * @since 2.5.0
	 * @deprecated
	 */
	exports.readonlyArray = {
	    URI: exports.URI,
	    compact: exports.compact,
	    separate: exports.separate,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    chain: exports.flatMap,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap,
	    mapWithIndex: _mapWithIndex,
	    partitionMapWithIndex: _partitionMapWithIndex,
	    partitionWithIndex: _partitionWithIndex,
	    filterMapWithIndex: _filterMapWithIndex,
	    filterWithIndex: _filterWithIndex,
	    alt: _alt,
	    zero: exports.zero,
	    unfold: exports.unfold,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex,
	    traverseWithIndex: _traverseWithIndex,
	    extend: _extend,
	    wither: _wither,
	    wilt: _wilt
	}; 
} (ReadonlyArray));

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.copy = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
	exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = exports.foldMapWithIndex = exports.foldMap = exports.duplicate = exports.extend = exports.filterWithIndex = exports.alt = exports.altW = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.filter = exports.separate = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.mapWithIndex = exports.flatten = exports.flatMap = exports.ap = exports.map = exports.zero = exports.of = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.sort = void 0;
	exports.some = exports.every = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = void 0;
	exports.array = exports.prependToAll = exports.snoc = exports.cons = exports.empty = exports.range = exports.chain = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.intercalate = exports.exists = void 0;
	var Apply_1 = Apply;
	var Chain_1 = Chain;
	var FromEither_1 = FromEither;
	var function_1 = _function;
	var Functor_1 = Functor;
	var _ = __importStar(internal);
	var NEA = __importStar(NonEmptyArray);
	var RA = __importStar(ReadonlyArray);
	var Separated_1 = Separated;
	var Witherable_1 = Witherable;
	var Zero_1 = Zero;
	// -------------------------------------------------------------------------------------
	// refinements
	// -------------------------------------------------------------------------------------
	/**
	 * Test whether an array is empty
	 *
	 * @example
	 * import { isEmpty } from 'fp-ts/Array'
	 *
	 * assert.strictEqual(isEmpty([]), true)
	 * assert.strictEqual(isEmpty(['a']), false)
	 *
	 * @category refinements
	 * @since 2.0.0
	 */
	var isEmpty = function (as) { return as.length === 0; };
	exports.isEmpty = isEmpty;
	/**
	 * Test whether an array is non empty narrowing down the type to `NonEmptyArray<A>`
	 *
	 * @example
	 * import { isNonEmpty } from 'fp-ts/Array'
	 *
	 * assert.strictEqual(isNonEmpty([]), false)
	 * assert.strictEqual(isNonEmpty(['a']), true)
	 *
	 * @category refinements
	 * @since 2.0.0
	 */
	exports.isNonEmpty = NEA.isNonEmpty;
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * Prepend an element to the front of a `Array`, creating a new `NonEmptyArray`.
	 *
	 * @example
	 * import { prepend } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])
	 *
	 * @since 2.10.0
	 */
	exports.prepend = NEA.prepend;
	/**
	 * Less strict version of [`prepend`](#prepend).
	 *
	 * @example
	 * import { prependW } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe([2, 3, 4], prependW("a")), ["a", 2, 3, 4]);
	 *
	 * @since 2.11.0
	 */
	exports.prependW = NEA.prependW;
	/**
	 * Append an element to the end of a `Array`, creating a new `NonEmptyArray`.
	 *
	 * @example
	 * import { append } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])
	 *
	 * @since 2.10.0
	 */
	exports.append = NEA.append;
	/**
	 * Less strict version of [`append`](#append).
	 *
	 * @example
	 * import { appendW } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe([1, 2, 3], appendW("d")), [1, 2, 3, "d"]);
	 *
	 * @since 2.11.0
	 */
	exports.appendW = NEA.appendW;
	/**
	 * Return a `Array` of length `n` with element `i` initialized with `f(i)`.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import { makeBy } from 'fp-ts/Array'
	 *
	 * const double = (i: number): number => i * 2
	 * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])
	 * assert.deepStrictEqual(makeBy(-3, double), [])
	 * assert.deepStrictEqual(makeBy(4.32164, double), [0, 2, 4, 6])
	 *
	 * @category constructors
	 * @since 2.0.0
	 */
	var makeBy = function (n, f) { return (n <= 0 ? [] : NEA.makeBy(f)(n)); };
	exports.makeBy = makeBy;
	/**
	 * Create a `Array` containing a value repeated the specified number of times.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import { replicate } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])
	 * assert.deepStrictEqual(replicate(-3, 'a'), [])
	 * assert.deepStrictEqual(replicate(2.985647, 'a'), ['a', 'a'])
	 *
	 * @category constructors
	 * @since 2.0.0
	 */
	var replicate = function (n, a) { return (0, exports.makeBy)(n, function () { return a; }); };
	exports.replicate = replicate;
	function fromPredicate(predicate) {
	    return function (a) { return (predicate(a) ? [a] : []); };
	}
	exports.fromPredicate = fromPredicate;
	// -------------------------------------------------------------------------------------
	// conversions
	// -------------------------------------------------------------------------------------
	/**
	 * Create an array from an `Option`. The resulting array will contain the content of the
	 * `Option` if it is `Some` and it will be empty if the `Option` is `None`.
	 *
	 * @example
	 * import { fromOption } from 'fp-ts/Array'
	 * import { option } from "fp-ts";
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe(option.some("a"), fromOption),["a"])
	 * assert.deepStrictEqual(pipe(option.none, fromOption),[])
	 *
	 * @category conversions
	 * @since 2.11.0
	 */
	var fromOption = function (ma) { return (_.isNone(ma) ? [] : [ma.value]); };
	exports.fromOption = fromOption;
	/**
	 * Create an array from an `Either`. The resulting array will contain the content of the
	 * `Either` if it is `Right` and it will be empty if the `Either` is `Left`.
	 *
	 * @example
	 * import { fromEither } from 'fp-ts/Array'
	 * import { either } from "fp-ts";
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe(either.right("r"), fromEither), ["r"]);
	 * assert.deepStrictEqual(pipe(either.left("l"), fromEither), []);
	 *
	 * @category conversions
	 * @since 2.11.0
	 */
	var fromEither = function (e) { return (_.isLeft(e) ? [] : [e.right]); };
	exports.fromEither = fromEither;
	/**
	 * Less strict version of [`match`](#match).
	 *
	 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
	 *
	 * @example
	 * import { matchW } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const matcherW = matchW(
	 *   () => "No elements",
	 *   (as) => as.length
	 * );
	 * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcherW), 4);
	 * assert.deepStrictEqual(pipe([], matcherW), "No elements");
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	var matchW = function (onEmpty, onNonEmpty) {
	    return function (as) {
	        return (0, exports.isNonEmpty)(as) ? onNonEmpty(as) : onEmpty();
	    };
	};
	exports.matchW = matchW;
	/**
	 * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise
	 * it passes the array to `onNonEmpty` and returns the result.
	 *
	 * @example
	 * import { match } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const matcher = match(
	 *   () => "No elements",
	 *   (as) => `Found ${as.length} element(s)`
	 * );
	 * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcher), "Found 4 element(s)");
	 * assert.deepStrictEqual(pipe([], matcher), "No elements");
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	exports.match = exports.matchW;
	/**
	 * Less strict version of [`matchLeft`](#matchleft). It will work when `onEmpty` and
	 * `onNonEmpty` have different return types.
	 *
	 * @example
	 * import { matchLeftW } from 'fp-ts/Array'
	 *
	 * const f = matchLeftW(
	 *   () => 0,
	 *   (head: string, tail: string[]) => `Found "${head}" followed by ${tail.length} elements`
	 * );
	 * assert.strictEqual(f(["a", "b", "c"]), 'Found "a" followed by 2 elements');
	 * assert.strictEqual(f([]), 0);
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	var matchLeftW = function (onEmpty, onNonEmpty) {
	    return function (as) {
	        return (0, exports.isNonEmpty)(as) ? onNonEmpty(NEA.head(as), NEA.tail(as)) : onEmpty();
	    };
	};
	exports.matchLeftW = matchLeftW;
	/**
	 * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise
	 * it passes the array to `onNonEmpty` broken into its first element and remaining elements.
	 *
	 * @example
	 * import { matchLeft } from 'fp-ts/Array'
	 *
	 * const len: <A>(as: Array<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))
	 * assert.strictEqual(len([1, 2, 3]), 3)
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.matchLeft = exports.matchLeftW;
	/**
	 * Alias of [`matchLeft`](#matchleft).
	 *
	 * @category pattern matching
	 * @since 2.0.0
	 */
	exports.foldLeft = exports.matchLeft;
	/**
	 * Less strict version of [`matchRight`](#matchright). It will work when `onEmpty` and
	 * `onNonEmpty` have different return types.
	 *
	 * @example
	 * import { matchRightW } from 'fp-ts/Array'
	 *
	 * const f = matchRightW(
	 *   () => 0,
	 *   (head: string[], tail: string) => `Found ${head.length} elements folllowed by "${tail}"`
	 * );
	 * assert.strictEqual(f(["a", "b", "c"]), 'Found 2 elements folllowed by "c"');
	 * assert.strictEqual(f([]), 0);
	 *
	 * @category pattern matching
	 * @since 2.11.0
	 */
	var matchRightW = function (onEmpty, onNonEmpty) {
	    return function (as) {
	        return (0, exports.isNonEmpty)(as) ? onNonEmpty(NEA.init(as), NEA.last(as)) : onEmpty();
	    };
	};
	exports.matchRightW = matchRightW;
	/**
	 * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise
	 * it passes the array to `onNonEmpty` broken  into its initial elements and the last element.
	 *
	 * @example
	 * import { matchRight } from 'fp-ts/Array'
	 *
	 * const len: <A>(as: Array<A>) => number = matchRight(
	 *   () => 0,
	 *   (head, _) => 1 + len(head)
	 * );
	 * assert.strictEqual(len([1, 2, 3]), 3);
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.matchRight = exports.matchRightW;
	/**
	 * Alias of [`matchRight`](#matchright).
	 *
	 * @category pattern matching
	 * @since 2.0.0
	 */
	exports.foldRight = exports.matchRight;
	// -------------------------------------------------------------------------------------
	// combinators
	// -------------------------------------------------------------------------------------
	/**
	 * Same as [`chain`](#chain), but passing also the index to the iterating function.
	 *
	 * @example
	 * import { chainWithIndex, replicate } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const f = (index: number, x: string) => replicate(2, `${x}${index}`);
	 * assert.deepStrictEqual(pipe(["a", "b", "c"], chainWithIndex(f)), ["a0", "a0", "b1", "b1", "c2", "c2"]);
	 *
	 * @category sequencing
	 * @since 2.7.0
	 */
	var chainWithIndex = function (f) {
	    return function (as) {
	        var out = [];
	        for (var i = 0; i < as.length; i++) {
	            out.push.apply(out, f(i, as[i]));
	        }
	        return out;
	    };
	};
	exports.chainWithIndex = chainWithIndex;
	/**
	 * Same as `reduce` but it carries over the intermediate steps
	 *
	 * @example
	 * import { scanLeft } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])
	 *
	 * @since 2.0.0
	 */
	var scanLeft = function (b, f) {
	    return function (as) {
	        var len = as.length;
	        var out = new Array(len + 1);
	        out[0] = b;
	        for (var i = 0; i < len; i++) {
	            out[i + 1] = f(out[i], as[i]);
	        }
	        return out;
	    };
	};
	exports.scanLeft = scanLeft;
	/**
	 * Fold an array from the right, keeping all intermediate results instead of only the final result
	 *
	 * @example
	 * import { scanRight } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])
	 *
	 * @since 2.0.0
	 */
	var scanRight = function (b, f) {
	    return function (as) {
	        var len = as.length;
	        var out = new Array(len + 1);
	        out[len] = b;
	        for (var i = len - 1; i >= 0; i--) {
	            out[i] = f(as[i], out[i + 1]);
	        }
	        return out;
	    };
	};
	exports.scanRight = scanRight;
	/**
	 * Calculate the number of elements in a `Array`.
	 *
	 * @example
	 * import { size } from 'fp-ts/Array'
	 *
	 * assert.strictEqual(size(["a","b","c"]),3)
	 *
	 * @since 2.10.0
	 */
	var size = function (as) { return as.length; };
	exports.size = size;
	/**
	 * Test whether an array contains a particular index
	 *
	 * @example
	 * import { isOutOfBound } from 'fp-ts/Array'
	 *
	 * assert.strictEqual(isOutOfBound(1,["a","b","c"]),false)
	 * assert.strictEqual(isOutOfBound(-1,["a","b","c"]),true)
	 * assert.strictEqual(isOutOfBound(3,["a","b","c"]),true)
	 *
	 * @since 2.0.0
	 */
	exports.isOutOfBound = NEA.isOutOfBound;
	// TODO: remove non-curried overloading in v3
	/**
	 * This function provides a safe way to read a value at a particular index from an array.
	 * It returns a `none` if the index is out of bounds, and a `some` of the element if the
	 * index is valid.
	 *
	 * @example
	 * import { lookup } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(pipe([1, 2, 3], lookup(1)), some(2))
	 * assert.deepStrictEqual(pipe([1, 2, 3], lookup(3)), none)
	 *
	 * @since 2.0.0
	 */
	exports.lookup = RA.lookup;
	/**
	 * Get the first element in an array, or `None` if the array is empty
	 *
	 * @example
	 * import { head } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(head([1, 2, 3]), some(1))
	 * assert.deepStrictEqual(head([]), none)
	 *
	 * @since 2.0.0
	 */
	exports.head = RA.head;
	/**
	 * Get the last element in an array, or `None` if the array is empty
	 *
	 * @example
	 * import { last } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(last([1, 2, 3]), some(3))
	 * assert.deepStrictEqual(last([]), none)
	 *
	 * @since 2.0.0
	 */
	exports.last = RA.last;
	/**
	 * Get all but the first element of an array, creating a new array, or `None` if the array is empty
	 *
	 * @example
	 * import { tail } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))
	 * assert.deepStrictEqual(tail([]), none)
	 *
	 * @since 2.0.0
	 */
	var tail = function (as) { return ((0, exports.isNonEmpty)(as) ? _.some(NEA.tail(as)) : _.none); };
	exports.tail = tail;
	/**
	 * Get all but the last element of an array, creating a new array, or `None` if the array is empty
	 *
	 * @example
	 * import { init } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))
	 * assert.deepStrictEqual(init([]), none)
	 *
	 * @since 2.0.0
	 */
	var init = function (as) { return ((0, exports.isNonEmpty)(as) ? _.some(NEA.init(as)) : _.none); };
	exports.init = init;
	/**
	 * Keep only a max number of elements from the start of an `Array`, creating a new `Array`.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import { takeLeft } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(takeLeft(2)([1, 2, 3, 4, 5]), [1, 2]);
	 * assert.deepStrictEqual(takeLeft(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
	 * assert.deepStrictEqual(takeLeft(0)([1, 2, 3, 4, 5]), []);
	 * assert.deepStrictEqual(takeLeft(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
	 *
	 * @since 2.0.0
	 */
	var takeLeft = function (n) {
	    return function (as) {
	        return (0, exports.isOutOfBound)(n, as) ? (0, exports.copy)(as) : as.slice(0, n);
	    };
	};
	exports.takeLeft = takeLeft;
	/**
	 * Keep only a max number of elements from the end of an `Array`, creating a new `Array`.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import { takeRight } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(takeRight(2)([1, 2, 3, 4, 5]), [4, 5]);
	 * assert.deepStrictEqual(takeRight(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
	 * assert.deepStrictEqual(takeRight(0)([1, 2, 3, 4, 5]), []);
	 * assert.deepStrictEqual(takeRight(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
	 *
	 * @since 2.0.0
	 */
	var takeRight = function (n) {
	    return function (as) {
	        return (0, exports.isOutOfBound)(n, as) ? (0, exports.copy)(as) : n === 0 ? [] : as.slice(-n);
	    };
	};
	exports.takeRight = takeRight;
	function takeLeftWhile(predicate) {
	    return function (as) {
	        var out = [];
	        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
	            var a = as_1[_i];
	            if (!predicate(a)) {
	                break;
	            }
	            out.push(a);
	        }
	        return out;
	    };
	}
	exports.takeLeftWhile = takeLeftWhile;
	var spanLeftIndex = function (as, predicate) {
	    var l = as.length;
	    var i = 0;
	    for (; i < l; i++) {
	        if (!predicate(as[i])) {
	            break;
	        }
	    }
	    return i;
	};
	function spanLeft(predicate) {
	    return function (as) {
	        var _a = (0, exports.splitAt)(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];
	        return { init: init, rest: rest };
	    };
	}
	exports.spanLeft = spanLeft;
	/**
	 * Creates a new `Array` which is a copy of the input dropping a max number of elements from the start.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import { dropLeft } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(dropLeft(2)([1, 2, 3]), [3]);
	 * assert.deepStrictEqual(dropLeft(5)([1, 2, 3]), []);
	 * assert.deepStrictEqual(dropLeft(0)([1, 2, 3]), [1, 2, 3]);
	 * assert.deepStrictEqual(dropLeft(-2)([1, 2, 3]), [1, 2, 3]);
	 *
	 * @since 2.0.0
	 */
	var dropLeft = function (n) {
	    return function (as) {
	        return n <= 0 || (0, exports.isEmpty)(as) ? (0, exports.copy)(as) : n >= as.length ? [] : as.slice(n, as.length);
	    };
	};
	exports.dropLeft = dropLeft;
	/**
	 * Creates a new `Array` which is a copy of the input dropping a max number of elements from the end.
	 *
	 * **Note**. `n` is normalized to a non negative integer.
	 *
	 * @example
	 * import { dropRight } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(dropRight(2)([1, 2, 3]), [1]);
	 * assert.deepStrictEqual(dropRight(5)([1, 2, 3]), []);
	 * assert.deepStrictEqual(dropRight(0)([1, 2, 3]), [1, 2, 3]);
	 * assert.deepStrictEqual(dropRight(-2)([1, 2, 3]), [1, 2, 3]);
	 *
	 * @since 2.0.0
	 */
	var dropRight = function (n) {
	    return function (as) {
	        return n <= 0 || (0, exports.isEmpty)(as) ? (0, exports.copy)(as) : n >= as.length ? [] : as.slice(0, as.length - n);
	    };
	};
	exports.dropRight = dropRight;
	function dropLeftWhile(predicate) {
	    return function (as) { return as.slice(spanLeftIndex(as, predicate)); };
	}
	exports.dropLeftWhile = dropLeftWhile;
	/**
	 * `findIndex` returns an `Option` containing the first index for which a predicate holds.
	 * It returns `None` if no element satisfies the predicate.
	 * Similar to [`findFirst`](#findFirst) but returning the index instead of the element.
	 *
	 * @example
	 * import { findIndex } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))
	 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)
	 *
	 * @since 2.0.0
	 */
	exports.findIndex = RA.findIndex;
	function findFirst(predicate) {
	    return RA.findFirst(predicate);
	}
	exports.findFirst = findFirst;
	/**
	 * Given a selector function which takes an element and returns an option,
	 * this function applies the selector to each element of the array and
	 * returns the first `Some` result. Otherwise it returns `None`.
	 *
	 * @example
	 * import { findFirstMap } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * interface Person {
	 *   readonly name: string;
	 *   readonly age: number;
	 * }
	 *
	 * const persons: Array<Person> = [
	 *   { name: "John", age: 16 },
	 *   { name: "Mary", age: 45 },
	 *   { name: "Joey", age: 28 },
	 * ];
	 *
	 * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));
	 * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));
	 * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove18)(persons), some("Mary"));
	 * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove70)(persons), none);
	 *
	 * @since 2.0.0
	 */
	exports.findFirstMap = RA.findFirstMap;
	function findLast(predicate) {
	    return RA.findLast(predicate);
	}
	exports.findLast = findLast;
	/**
	 * Given a selector function which takes an element and returns an option,
	 * this function applies the selector to each element of the array starting from the
	 * end and returns the last `Some` result. Otherwise it returns `None`.
	 *
	 * @example
	 * import { findLastMap } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * interface Person {
	 *   readonly name: string;
	 *   readonly age: number;
	 * }
	 *
	 * const persons: Array<Person> = [
	 *   { name: "John", age: 16 },
	 *   { name: "Mary", age: 45 },
	 *   { name: "Joey", age: 28 },
	 * ];
	 *
	 * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));
	 * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));
	 * assert.deepStrictEqual(findLastMap(nameOfPersonAbove18)(persons), some("Joey"));
	 * assert.deepStrictEqual(findLastMap(nameOfPersonAbove70)(persons), none);
	 *
	 * @since 2.0.0
	 */
	exports.findLastMap = RA.findLastMap;
	/**
	 * Returns the index of the last element of the list which matches the predicate.
	 * It returns an `Option` containing the index or `None` if not found.
	 *
	 * @example
	 * import { findLastIndex } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * interface X {
	 *   readonly a: number
	 *   readonly b: number
	 * }
	 * const xs: Array<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]
	 * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))
	 * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)
	 *
	 * @since 2.0.0
	 */
	exports.findLastIndex = RA.findLastIndex;
	/**
	 * This function takes an array and makes a new array containing the same elements.
	 *
	 * @since 2.0.0
	 */
	var copy = function (as) { return as.slice(); };
	exports.copy = copy;
	/**
	 * Insert an element at the specified index, creating a new array,
	 * or returning `None` if the index is out of bounds.
	 *
	 * @example
	 * import { insertAt } from 'fp-ts/Array'
	 * import { some } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))
	 *
	 * @since 2.0.0
	 */
	var insertAt = function (i, a) {
	    return function (as) {
	        return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
	    };
	};
	exports.insertAt = insertAt;
	/**
	 * Change the element at the specified index, creating a new array,
	 * or returning `None` if the index is out of bounds.
	 *
	 * @example
	 * import { updateAt } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))
	 * assert.deepStrictEqual(updateAt(1, 1)([]), none)
	 *
	 * @since 2.0.0
	 */
	var updateAt = function (i, a) { return (0, exports.modifyAt)(i, function () { return a; }); };
	exports.updateAt = updateAt;
	/**
	 * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds.
	 *
	 * @example
	 * import { deleteAt } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))
	 * assert.deepStrictEqual(deleteAt(1)([]), none)
	 *
	 * @since 2.0.0
	 */
	var deleteAt = function (i) {
	    return function (as) {
	        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeDeleteAt)(i, as));
	    };
	};
	exports.deleteAt = deleteAt;
	/**
	 * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out
	 * of bounds.
	 *
	 * @example
	 * import { modifyAt } from 'fp-ts/Array'
	 * import { some, none } from 'fp-ts/Option'
	 *
	 * const double = (x: number): number => x * 2
	 * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))
	 * assert.deepStrictEqual(modifyAt(1, double)([]), none)
	 *
	 * @since 2.0.0
	 */
	var modifyAt = function (i, f) {
	    return function (as) {
	        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
	    };
	};
	exports.modifyAt = modifyAt;
	/**
	 * Reverse an array, creating a new array
	 *
	 * @example
	 * import { reverse } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])
	 *
	 * @since 2.0.0
	 */
	var reverse = function (as) { return ((0, exports.isEmpty)(as) ? [] : as.slice().reverse()); };
	exports.reverse = reverse;
	/**
	 * Takes an `Array` of `Either` and produces a new `Array` containing
	 * the values of all the `Right` elements in the same order.
	 *
	 * @example
	 * import { rights } from 'fp-ts/Array'
	 * import { right, left } from 'fp-ts/Either'
	 *
	 * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])
	 *
	 * @since 2.0.0
	 */
	var rights = function (as) {
	    var r = [];
	    for (var i = 0; i < as.length; i++) {
	        var a = as[i];
	        if (a._tag === 'Right') {
	            r.push(a.right);
	        }
	    }
	    return r;
	};
	exports.rights = rights;
	/**
	 * Takes an `Array` of `Either` and produces a new `Array` containing
	 * the values of all the `Left` elements in the same order.
	 *
	 * @example
	 * import { lefts } from 'fp-ts/Array'
	 * import { left, right } from 'fp-ts/Either'
	 *
	 * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])
	 *
	 * @since 2.0.0
	 */
	var lefts = function (as) {
	    var r = [];
	    for (var i = 0; i < as.length; i++) {
	        var a = as[i];
	        if (a._tag === 'Left') {
	            r.push(a.left);
	        }
	    }
	    return r;
	};
	exports.lefts = lefts;
	/**
	 * Sort the elements of an array in increasing order, creating a new array
	 *
	 * @example
	 * import { sort } from 'fp-ts/Array'
	 * import * as N from 'fp-ts/number'
	 *
	 * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])
	 *
	 * @since 2.0.0
	 */
	var sort = function (O) {
	    return function (as) {
	        return as.length <= 1 ? (0, exports.copy)(as) : as.slice().sort(O.compare);
	    };
	};
	exports.sort = sort;
	/**
	 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one
	 * input array is short, excess elements of the longer array are discarded.
	 *
	 * @example
	 * import { zipWith } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])
	 *
	 * @since 2.0.0
	 */
	var zipWith = function (fa, fb, f) {
	    var fc = [];
	    var len = Math.min(fa.length, fb.length);
	    for (var i = 0; i < len; i++) {
	        fc[i] = f(fa[i], fb[i]);
	    }
	    return fc;
	};
	exports.zipWith = zipWith;
	function zip(as, bs) {
	    if (bs === undefined) {
	        return function (bs) { return zip(bs, as); };
	    }
	    return (0, exports.zipWith)(as, bs, function (a, b) { return [a, b]; });
	}
	exports.zip = zip;
	/**
	 * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays
	 *
	 * @example
	 * import { unzip } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])
	 *
	 * @since 2.0.0
	 */
	var unzip = function (as) {
	    var fa = [];
	    var fb = [];
	    for (var i = 0; i < as.length; i++) {
	        fa[i] = as[i][0];
	        fb[i] = as[i][1];
	    }
	    return [fa, fb];
	};
	exports.unzip = unzip;
	/**
	 * Creates a new `Array`, prepending an element to every member of the input `Array`.
	 *
	 * @example
	 * import { prependAll } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
	 *
	 * @since 2.10.0
	 */
	var prependAll = function (middle) {
	    var f = NEA.prependAll(middle);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : []); };
	};
	exports.prependAll = prependAll;
	/**
	 * Creates a new `Array` placing an element in between members of the input `Array`.
	 *
	 * @example
	 * import { intersperse } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
	 *
	 * @since 2.9.0
	 */
	var intersperse = function (middle) {
	    var f = NEA.intersperse(middle);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as)); };
	};
	exports.intersperse = intersperse;
	/**
	 * Creates a new `Array` rotating the input `Array` by `n` steps.
	 *
	 * @example
	 * import { rotate } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
	 *
	 * @since 2.0.0
	 */
	var rotate = function (n) {
	    var f = NEA.rotate(n);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as)); };
	};
	exports.rotate = rotate;
	// TODO: remove non-curried overloading in v3
	/**
	 * Test if a value is a member of an `Array`. Takes a `Eq<A>` as a single
	 * argument which returns the function to use to search for a value of type `A` in
	 * an `Array<A>`.
	 *
	 * @example
	 * import { elem } from 'fp-ts/Array'
	 * import * as N from 'fp-ts/number'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(2)), true)
	 * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(0)), false)
	 *
	 * @since 2.0.0
	 */
	exports.elem = RA.elem;
	/**
	 * Creates a new `Array` removing duplicate elements, keeping the first occurrence of an element,
	 * based on a `Eq<A>`.
	 *
	 * @example
	 * import { uniq } from 'fp-ts/Array'
	 * import * as N from 'fp-ts/number'
	 *
	 * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
	 *
	 * @since 2.0.0
	 */
	var uniq = function (E) {
	    var f = NEA.uniq(E);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as)); };
	};
	exports.uniq = uniq;
	/**
	 * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
	 * etc...
	 *
	 * @example
	 * import { sortBy } from 'fp-ts/Array'
	 * import { contramap } from 'fp-ts/Ord'
	 * import * as S from 'fp-ts/string'
	 * import * as N from 'fp-ts/number'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * interface Person {
	 *   readonly name: string
	 *   readonly age: number
	 * }
	 * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
	 * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
	 *
	 * const sortByNameByAge = sortBy([byName, byAge])
	 *
	 * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]
	 * assert.deepStrictEqual(sortByNameByAge(persons), [
	 *   { name: 'a', age: 1 },
	 *   { name: 'b', age: 2 },
	 *   { name: 'b', age: 3 },
	 *   { name: 'c', age: 2 }
	 * ])
	 *
	 * @since 2.0.0
	 */
	var sortBy = function (ords) {
	    var f = NEA.sortBy(ords);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as)); };
	};
	exports.sortBy = sortBy;
	/**
	 * A useful recursion pattern for processing an array to produce a new array, often used for "chopping" up the input
	 * array. Typically chop is called with some function that will consume an initial prefix of the array and produce a
	 * value and the rest of the array.
	 *
	 * @example
	 * import { Eq } from 'fp-ts/Eq'
	 * import * as A from 'fp-ts/Array'
	 * import * as N from 'fp-ts/number'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const group = <A>(S: Eq<A>): ((as: Array<A>) => Array<Array<A>>) => {
	 *   return A.chop(as => {
	 *     const { init, rest } = pipe(as, A.spanLeft((a: A) => S.equals(a, as[0])))
	 *     return [init, rest]
	 *   })
	 * }
	 * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])
	 *
	 * @since 2.0.0
	 */
	var chop = function (f) {
	    var g = NEA.chop(f);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? g(as) : []); };
	};
	exports.chop = chop;
	/**
	 * Splits an `Array` into two pieces, the first piece has max `n` elements.
	 *
	 * @example
	 * import { splitAt } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])
	 *
	 * @since 2.0.0
	 */
	var splitAt = function (n) {
	    return function (as) {
	        return n >= 1 && (0, exports.isNonEmpty)(as) ? NEA.splitAt(n)(as) : (0, exports.isEmpty)(as) ? [(0, exports.copy)(as), []] : [[], (0, exports.copy)(as)];
	    };
	};
	exports.splitAt = splitAt;
	/**
	 * Splits an array into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
	 * the array. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
	 * definition of `chunksOf`; it satisfies the property that
	 *
	 * ```ts
	 * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
	 * ```
	 *
	 * whenever `n` evenly divides the length of `xs`.
	 *
	 * @example
	 * import { chunksOf } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])
	 *
	 * @since 2.0.0
	 */
	var chunksOf = function (n) {
	    var f = NEA.chunksOf(n);
	    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : []); };
	};
	exports.chunksOf = chunksOf;
	/**
	 * @category lifting
	 * @since 2.11.0
	 */
	var fromOptionK = function (f) {
	    return function () {
	        var a = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            a[_i] = arguments[_i];
	        }
	        return (0, exports.fromOption)(f.apply(void 0, a));
	    };
	};
	exports.fromOptionK = fromOptionK;
	function comprehension(input, f, g) {
	    if (g === void 0) { g = function () { return true; }; }
	    var go = function (scope, input) {
	        return (0, exports.isNonEmpty)(input)
	            ? (0, exports.flatMap)(NEA.head(input), function (a) { return go((0, function_1.pipe)(scope, (0, exports.append)(a)), NEA.tail(input)); })
	            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]
	                : [];
	    };
	    return go([], input);
	}
	exports.comprehension = comprehension;
	/**
	 * @since 2.11.0
	 */
	var concatW = function (second) {
	    return function (first) {
	        return (0, exports.isEmpty)(first) ? (0, exports.copy)(second) : (0, exports.isEmpty)(second) ? (0, exports.copy)(first) : first.concat(second);
	    };
	};
	exports.concatW = concatW;
	/**
	 * @since 2.11.0
	 */
	exports.concat = exports.concatW;
	function union(E) {
	    var unionE = NEA.union(E);
	    return function (first, second) {
	        if (second === undefined) {
	            var unionE_1 = union(E);
	            return function (second) { return unionE_1(second, first); };
	        }
	        return (0, exports.isNonEmpty)(first) && (0, exports.isNonEmpty)(second)
	            ? unionE(second)(first)
	            : (0, exports.isNonEmpty)(first)
	                ? (0, exports.copy)(first)
	                : (0, exports.copy)(second);
	    };
	}
	exports.union = union;
	function intersection(E) {
	    var elemE = (0, exports.elem)(E);
	    return function (xs, ys) {
	        if (ys === undefined) {
	            var intersectionE_1 = intersection(E);
	            return function (ys) { return intersectionE_1(ys, xs); };
	        }
	        return xs.filter(function (a) { return elemE(a, ys); });
	    };
	}
	exports.intersection = intersection;
	function difference(E) {
	    var elemE = (0, exports.elem)(E);
	    return function (xs, ys) {
	        if (ys === undefined) {
	            var differenceE_1 = difference(E);
	            return function (ys) { return differenceE_1(ys, xs); };
	        }
	        return xs.filter(function (a) { return !elemE(a, ys); });
	    };
	}
	exports.difference = difference;
	var _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };
	/* istanbul ignore next */
	var _mapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f)); };
	var _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };
	/* istanbul ignore next */
	var _filter = function (fa, predicate) { return (0, function_1.pipe)(fa, (0, exports.filter)(predicate)); };
	/* istanbul ignore next */
	var _filterMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.filterMap)(f)); };
	/* istanbul ignore next */
	var _partition = function (fa, predicate) {
	    return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
	};
	/* istanbul ignore next */
	var _partitionMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f)); };
	/* istanbul ignore next */
	var _partitionWithIndex = function (fa, predicateWithIndex) { return (0, function_1.pipe)(fa, (0, exports.partitionWithIndex)(predicateWithIndex)); };
	/* istanbul ignore next */
	var _partitionMapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f)); };
	/* istanbul ignore next */
	var _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };
	var _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };
	/* istanbul ignore next */
	var _foldMap = function (M) {
	    var foldMapM = (0, exports.foldMap)(M);
	    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };
	};
	/* istanbul ignore next */
	var _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };
	/* istanbul ignore next */
	var _reduceWithIndex = function (fa, b, f) {
	    return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
	};
	/* istanbul ignore next */
	var _foldMapWithIndex = function (M) {
	    var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
	    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapWithIndexM(f)); };
	};
	/* istanbul ignore next */
	var _reduceRightWithIndex = function (fa, b, f) {
	    return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
	};
	/* istanbul ignore next */
	var _filterMapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f)); };
	/* istanbul ignore next */
	var _filterWithIndex = function (fa, predicateWithIndex) { return (0, function_1.pipe)(fa, (0, exports.filterWithIndex)(predicateWithIndex)); };
	/* istanbul ignore next */
	var _extend = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.extend)(f)); };
	/* istanbul ignore next */
	var _traverse = function (F) {
	    var traverseF = (0, exports.traverse)(F);
	    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };
	};
	/* istanbul ignore next */
	var _traverseWithIndex = function (F) {
	    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
	    return function (ta, f) { return (0, function_1.pipe)(ta, traverseWithIndexF(f)); };
	};
	var _chainRecDepthFirst = RA._chainRecDepthFirst;
	var _chainRecBreadthFirst = RA._chainRecBreadthFirst;
	/**
	 * Given an element of the base type, `of` builds an `Array` containing just that
	 * element of the base type (this is useful for building a `Monad`).
	 *
	 * @example
	 * import { of } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(of("a"), ["a"]);
	 *
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.of = NEA.of;
	/**
	 * Makes an empty `Array`, useful for building a [`Monoid`](#Monoid)
	 *
	 * @since 2.7.0
	 */
	var zero = function () { return []; };
	exports.zero = zero;
	/**
	 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: Array<A>) => Array<B>`.
	 * In practice it applies the base function to each element of the array and collects the
	 * results in a new array.
	 *
	 * @example
	 * import { map } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const f = (n: number) => n * 2;
	 * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [2, 4, 6]);
	 *
	 * @category mapping
	 * @since 2.0.0
	 */
	var map = function (f) { return function (fa) { return fa.map(function (a) { return f(a); }); }; };
	exports.map = map;
	/**
	 * @example
	 * import { ap, map, of } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * // a curried function with 3 input parameteres
	 * const f = (s1: string) => (n: number) => (s2: string) => s1 + n + s2;
	 *
	 * // let's use `ap` to iterate `f` over an array for each input parameter
	 * assert.deepStrictEqual(pipe(["a", "b"], map(f), ap([1, 2]), ap(["😀", "😫", "😎"])), [
	 *   "a1😀", "a1😫", "a1😎",
	 *   "a2😀", "a2😫", "a2😎",
	 *   "b1😀", "b1😫", "b1😎",
	 *   "b2😀", "b2😫", "b2😎",
	 * ]);
	 *
	 * // given Array implements the Applicative interface with the `of` method,
	 * // we can write exactly the same thing in a more symmetric way
	 * // using `of` on `f` and `ap` on each array in input
	 * assert.deepStrictEqual(
	 *   pipe(of(f), ap(["a", "b"]), ap([1, 2]), ap(["😀", "😫", "😎"])),
	 *   pipe(["a", "b"], map(f), ap([1, 2]), ap(["😀", "😫", "😎"]))
	 * );
	 *
	 * @since 2.0.0
	 */
	var ap = function (fa) {
	    return (0, exports.flatMap)(function (f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); });
	};
	exports.ap = ap;
	/**
	 * Composes computations in sequence, using the return value of one computation to
	 * determine the next computation.
	 *
	 * In other words it takes a function `f` that produces an array from a single element of
	 * the base type `A` and returns a new function which applies `f` to each element of the
	 * input array (like [`map`](#map)) and, instead of returning an array of arrays, concatenates the
	 * results into a single array (like [`flatten`](#flatten)).
	 *
	 * @example
	 * import { flatMap, map, replicate } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const f = (n: number) => replicate(n, `${n}`);
	 * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [["1"], ["2", "2"], ["3", "3", "3"]]);
	 * assert.deepStrictEqual(pipe([1, 2, 3], flatMap(f)), ["1", "2", "2", "3", "3", "3"]);
	 *
	 * @category sequencing
	 * @since 2.14.0
	 */
	exports.flatMap = (0, function_1.dual)(2, function (ma, f) {
	    return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function (i, a) { return f(a, i); }));
	});
	/**
	 * Takes an array of arrays of `A` and flattens them into an array of `A`
	 * by concatenating the elements of each array in order.
	 *
	 * @example
	 * import { flatten } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(flatten([["a"], ["b", "c"], ["d", "e", "f"]]), ["a", "b", "c", "d", "e", "f"]);
	 *
	 * @category sequencing
	 * @since 2.5.0
	 */
	exports.flatten = (0, exports.flatMap)(function_1.identity);
	/**
	 * Same as [`map`](#map), but the iterating function takes both the index and the value
	 * of the element.
	 *
	 * @example
	 * import { mapWithIndex } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * const f = (i: number, s: string) => `${s} - ${i}`;
	 * assert.deepStrictEqual(pipe(["a", "b", "c"], mapWithIndex(f)), ["a - 0", "b - 1", "c - 2"]);
	 *
	 * @category mapping
	 * @since 2.0.0
	 */
	var mapWithIndex = function (f) { return function (fa) {
	    return fa.map(function (a, i) { return f(i, a); });
	}; };
	exports.mapWithIndex = mapWithIndex;
	/**
	 * Maps an array with an iterating function that takes the index and the value of
	 * each element and returns an `Option`. It keeps only the `Some` values discarding
	 * the `None`s.
	 *
	 * Same as [`filterMap`](#filterMap), but with an iterating function which takes also
	 * the index as input.
	 *
	 * @example
	 * import { filterMapWithIndex } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 * import { option } from "fp-ts";
	 *
	 * const f = (i: number, s: string) => (i % 2 === 1 ? option.some(s.toUpperCase()) : option.none);
	 * assert.deepStrictEqual(pipe(["a", "no", "neither", "b"], filterMapWithIndex(f)), ["NO", "B"]);
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	var filterMapWithIndex = function (f) {
	    return function (fa) {
	        var out = [];
	        for (var i = 0; i < fa.length; i++) {
	            var optionB = f(i, fa[i]);
	            if (_.isSome(optionB)) {
	                out.push(optionB.value);
	            }
	        }
	        return out;
	    };
	};
	exports.filterMapWithIndex = filterMapWithIndex;
	/**
	 * Maps an array with an iterating function that returns an `Option`
	 * and it keeps only the `Some` values discarding the `None`s.
	 *
	 * @example
	 * import { filterMap } from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 * import { option } from "fp-ts";
	 *
	 * const f = (s: string) => s.length === 1 ? option.some(s.toUpperCase()) : option.none;
	 * assert.deepStrictEqual(pipe(["a", "no", "neither", "b"], filterMap(f)), ["A", "B"]);
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	var filterMap = function (f) {
	    return (0, exports.filterMapWithIndex)(function (_, a) { return f(a); });
	};
	exports.filterMap = filterMap;
	/**
	 * Compact an array of `Option`s discarding the `None` values and
	 * keeping the `Some` values. It returns a new array containing the values of
	 * the `Some` options.
	 *
	 * @example
	 * import { compact } from 'fp-ts/Array'
	 * import { option } from "fp-ts";
	 *
	 * assert.deepStrictEqual(compact([option.some("a"), option.none, option.some("b")]), ["a", "b"]);
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	exports.compact = (0, exports.filterMap)(function_1.identity);
	/**
	 * Separate an array of `Either`s into `Left`s and `Right`s, creating two new arrays:
	 * one containing all the left values and one containing all the right values.
	 *
	 * @example
	 * import { separate } from 'fp-ts/Array'
	 * import { either } from "fp-ts";
	 *
	 * assert.deepStrictEqual(separate([either.right("r1"), either.left("l1"), either.right("r2")]), {
	 *   left: ["l1"],
	 *   right: ["r1", "r2"],
	 * });
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	var separate = function (fa) {
	    var left = [];
	    var right = [];
	    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
	        var e = fa_1[_i];
	        if (e._tag === 'Left') {
	            left.push(e.left);
	        }
	        else {
	            right.push(e.right);
	        }
	    }
	    return (0, Separated_1.separated)(left, right);
	};
	exports.separate = separate;
	/**
	 * Given an iterating function that is a `Predicate` or a `Refinement`,
	 * `filter` creates a new `Array` containing the elements of the original
	 * `Array` for which the iterating function is `true`.
	 *
	 * @example
	 * import { filter } from 'fp-ts/Array'
	 * import { isString } from "fp-ts/lib/string";
	 *
	 * assert.deepStrictEqual(filter(isString)(["a", 1, {}, "b", 5]), ["a", "b"]);
	 * assert.deepStrictEqual(filter((x:number) => x > 0)([-3, 1, -2, 5]), [1, 5]);
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	var filter = function (predicate) {
	    return function (as) {
	        return as.filter(predicate);
	    };
	};
	exports.filter = filter;
	/**
	 * Given an iterating function that is a `Predicate` or a `Refinement`,
	 * `partition` creates two new `Array`s: `right` containing the elements of the original
	 * `Array` for which the iterating function is `true`, `left` containing the elements
	 * for which it is false.
	 *
	 * @example
	 * import { partition } from 'fp-ts/Array'
	 * import { isString } from "fp-ts/lib/string";
	 *
	 * assert.deepStrictEqual(partition(isString)(["a", 1, {}, "b", 5]), { left: [1, {}, 5], right: ["a", "b"] });
	 * assert.deepStrictEqual(partition((x: number) => x > 0)([-3, 1, -2, 5]), { left: [-3, -2], right: [1, 5] });
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	var partition = function (predicate) {
	    return (0, exports.partitionWithIndex)(function (_, a) { return predicate(a); });
	};
	exports.partition = partition;
	/**
	 * Same as [`partition`](#partition), but passing also the index to the iterating function.
	 *
	 * @example
	 * import { partitionWithIndex } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(partitionWithIndex((index, x: number) => index < 3 && x > 0)([-2, 5, 6, 7]), {
	 *   left: [-2, 7],
	 *   right: [5, 6],
	 * });
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	var partitionWithIndex = function (predicateWithIndex) {
	    return function (as) {
	        var left = [];
	        var right = [];
	        for (var i = 0; i < as.length; i++) {
	            var b = as[i];
	            if (predicateWithIndex(i, b)) {
	                right.push(b);
	            }
	            else {
	                left.push(b);
	            }
	        }
	        return (0, Separated_1.separated)(left, right);
	    };
	};
	exports.partitionWithIndex = partitionWithIndex;
	/**
	 * Given an iterating function that returns an `Either`,
	 * `partitionMap` applies the iterating function to each element and it creates two `Array`s:
	 * `right` containing the values of `Right` results, `left` containing the values of `Left` results.
	 *
	 * @example
	 * import { partitionMap } from 'fp-ts/Array'
	 * import { Either, left, right } from "fp-ts/lib/Either";
	 *
	 * const upperIfString = <B>(x: B): Either<B, string> =>
	 *   typeof x === "string" ? right(x.toUpperCase()) : left(x);
	 * assert.deepStrictEqual(partitionMap(upperIfString)([-2, "hello", 6, 7, "world"]), {
	 *   left: [-2, 6, 7],
	 *   right: [ 'HELLO', 'WORLD' ],
	 * });
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	var partitionMap = function (f) { return (0, exports.partitionMapWithIndex)(function (_, a) { return f(a); }); };
	exports.partitionMap = partitionMap;
	/**
	 * Same as [`partitionMap`](#partitionMap), but passing also the index to the iterating function.
	 *
	 * @example
	 * import { partitionMapWithIndex } from 'fp-ts/Array'
	 * import { Either, left, right } from "fp-ts/lib/Either";
	 *
	 * const upperIfStringBefore3 = <B>(index: number, x: B): Either<B, string> =>
	 *   index < 3 && typeof x === "string" ? right(x.toUpperCase()) : left(x);
	 * assert.deepStrictEqual(partitionMapWithIndex(upperIfStringBefore3)([-2, "hello", 6, 7, "world"]), {
	 *   left: [-2, 6, 7, "world"],
	 *   right: ["HELLO"],
	 * });
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	var partitionMapWithIndex = function (f) {
	    return function (fa) {
	        var left = [];
	        var right = [];
	        for (var i = 0; i < fa.length; i++) {
	            var e = f(i, fa[i]);
	            if (e._tag === 'Left') {
	                left.push(e.left);
	            }
	            else {
	                right.push(e.right);
	            }
	        }
	        return (0, Separated_1.separated)(left, right);
	    };
	};
	exports.partitionMapWithIndex = partitionMapWithIndex;
	/**
	 * Less strict version of [`alt`](#alt).
	 *
	 * The `W` suffix (short for **W**idening) means that the return types will be merged.
	 *
	 * @example
	 * import * as A from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     A.altW(() => ['a', 'b'])
	 *   ),
	 *   [1, 2, 3, 'a', 'b']
	 * )
	 *
	 * @category error handling
	 * @since 2.9.0
	 */
	var altW = function (that) {
	    return function (fa) {
	        return fa.concat(that());
	    };
	};
	exports.altW = altW;
	/**
	 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
	 * types of kind `* -> *`.
	 *
	 * In case of `Array` concatenates the inputs into a single array.
	 *
	 * @example
	 * import * as A from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     A.alt(() => [4, 5])
	 *   ),
	 *   [1, 2, 3, 4, 5]
	 * )
	 *
	 * @category error handling
	 * @since 2.0.0
	 */
	exports.alt = exports.altW;
	/**
	 * Same as [`filter`](#filter), but passing also the index to the iterating function.
	 *
	 * @example
	 * import { filterWithIndex } from 'fp-ts/Array';
	 *
	 * const f = (index: number, x: number) => x > 0 && index <= 2;
	 * assert.deepStrictEqual(filterWithIndex(f)([-3, 1, -2, 5]), [1]);
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	var filterWithIndex = function (predicateWithIndex) {
	    return function (as) {
	        return as.filter(function (b, i) { return predicateWithIndex(i, b); });
	    };
	};
	exports.filterWithIndex = filterWithIndex;
	/**
	 * Given an iterating function that takes `Array<A>` as input, `extend` returns
	 * an array containing the results of the iterating function applied to the whole input
	 * `Array`, then to the input `Array` without the first element, then to the input
	 * `Array` without the first two elements, etc.
	 *
	 * @example
	 * import { extend } from 'fp-ts/Array'
	 *
	 * const f = (a: string[]) => a.join(",");
	 * assert.deepStrictEqual(extend(f)(["a", "b", "c"]), ["a,b,c", "b,c", "c"]);
	 *
	 * @since 2.0.0
	 */
	var extend = function (f) { return function (wa) {
	    return wa.map(function (_, i) { return f(wa.slice(i)); });
	}; };
	exports.extend = extend;
	/**
	 * `duplicate` returns an array containing the whole input `Array`,
	 * then to the input `Array` dropping the first element, then to the input
	 * `Array` dropping the first two elements, etc.
	 *
	 * @example
	 * import { duplicate } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(duplicate(["a", "b", "c"]), [["a", "b", "c"], ["b", "c"], ["c"]]);
	 *
	 * @since 2.0.0
	 */
	exports.duplicate = (0, exports.extend)(function_1.identity);
	/**
	 * Map and fold an `Array`.
	 * Map the `Array` passing each value to the iterating function.
	 * Then fold the results using the provided `Monoid`.
	 *
	 * @example
	 * import { foldMap } from 'fp-ts/Array'
	 *
	 * const monoid = { concat: (a: string, b: string) => a + b, empty: "" };
	 * const f = (s: string) => s.toUpperCase()
	 * assert.deepStrictEqual(foldMap(monoid)(f)(["a", "b", "c"]), "ABC");
	 *
	 * @category folding
	 * @since 2.0.0
	 */
	exports.foldMap = RA.foldMap;
	/**
	 * Same as [`foldMap`](#foldMap) but passing also the index to the iterating function.
	 *
	 * @example
	 * import { foldMapWithIndex } from 'fp-ts/Array'
	 *
	 * const monoid = { concat: (a: string, b: string) => a + b, empty: "" };
	 * const f = (index:number, s: string) => `${s.toUpperCase()}(${index})`
	 * assert.deepStrictEqual(foldMapWithIndex(monoid)(f)(["a", "b", "c"]), "A(0)B(1)C(2)");
	 *
	 * @category folding
	 * @since 2.0.0
	 */
	exports.foldMapWithIndex = RA.foldMapWithIndex;
	/**
	 * Reduces an `Array`.
	 *
	 * `reduce` executes the supplied iterating function on each element of the array,
	 * in order, passing in the element and the return value from the calculation on the preceding element.
	 *
	 * The first time that the iterating function is called there is no "return value of the
	 * previous calculation", the initial value is used in its place.
	 *
	 * @example
	 * import { reduce } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(reduce(5, (acc: number, cur: number) => acc * cur)([2, 3]), 5 * 2 * 3);
	 *
	 * @category folding
	 * @since 2.0.0
	 */
	exports.reduce = RA.reduce;
	/**
	 * Same as [`reduce`](#reduce) but passing also the index to the iterating function.
	 *
	 * @example
	 * import { reduceWithIndex } from 'fp-ts/Array'
	 *
	 * const f = (index: number, acc: string, cur: unknown) =>
	 *   acc + (typeof cur === "string" ? cur.toUpperCase() + index : "");
	 * assert.deepStrictEqual(reduceWithIndex("", f)([2, "a", "b", null]), "A1B2");
	 *
	 * @category folding
	 * @since 2.0.0
	 */
	exports.reduceWithIndex = RA.reduceWithIndex;
	/**
	 * Same as [`reduce`](#reduce) but applied from the end to the start.
	 *
	 * *Note*: the iterating function in this case takes the accumulator as the last argument.
	 *
	 * @example
	 * import { reduceRight } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(reduceRight("", (cur: string, acc: string) => acc + cur)(["a", "b", "c"]), "cba");
	 *
	 * @category folding
	 * @since 2.0.0
	 */
	exports.reduceRight = RA.reduceRight;
	/**
	 * Same as [`reduceRight`](#reduceRight) but passing also the index to the iterating function.
	 *
	 * @example
	 * import { reduceRightWithIndex } from 'fp-ts/Array'
	 *
	 * const f = (index: number, cur: unknown, acc: string) =>
	 *   acc + (typeof cur === "string" ? cur.toUpperCase() + index : "");
	 * assert.deepStrictEqual(reduceRightWithIndex("", f)([2, "a", "b", null]), "B2A1");
	 *
	 * @category folding
	 * @since 2.0.0
	 */
	exports.reduceRightWithIndex = RA.reduceRightWithIndex;
	/**
	 * Given an iterating function that returns a `HKT` (higher kinded type), `traverse`
	 * applies the iterating function to each element of the `Array` and then [`sequence`](#sequence)-s
	 * the results using the provided `Applicative`.
	 *
	 * E.g. suppose you have an `Array` and you want to format each element with a function
	 * that returns a result or an error as `f = (a: A) => Either<Error, B>`, using `traverse`
	 * you can apply `f` to all elements and directly obtain as a result an `Either<Error,Array<B>>`
	 * i.e. an `Array<B>` if all the results are `B`, or an `Error` if some of the results
	 * are `Error`s.
	 *
	 * @example
	 * import { traverse } from 'fp-ts/Array'
	 * import { Applicative, left, right } from "fp-ts/lib/Either";
	 *
	 * const f = (x: unknown) =>
	 *   typeof x === "string" ? right(x.toUpperCase()) : left(new Error("not a string"));
	 * assert.deepStrictEqual(traverse(Applicative)(f)(["a", "b"]), right(["A", "B"]));
	 * assert.deepStrictEqual(traverse(Applicative)(f)(["a", 5]), left(new Error("not a string")));
	 *
	 * @category traversing
	 * @since 2.6.3
	 */
	var traverse = function (F) {
	    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
	    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
	};
	exports.traverse = traverse;
	/**
	 * `sequence` takes an `Array` where elements are `HKT<A>` (higher kinded type) and,
	 * using an applicative of that `HKT`, returns an `HKT` of `Array<A>`.
	 * E.g. it can turn an `Array<Either<Error, string>>` into an `Either<Error, Array<string>>`.
	 *
	 * `sequence` requires an `Applicative` of the `HKT` you are targeting, e.g. to turn an
	 * `Array<Either<E, A>>` into an `Either<E, Array<A>>`, it needs an
	 * `Applicative` for `Either`, to to turn an `Array<Option<A>>` into an `Option<Array<A>>`,
	 * it needs an `Applicative` for `Option`.
	 *
	 * @example
	 * import { sequence } from 'fp-ts/Array'
	 * import { Applicative, left, right } from "fp-ts/lib/Either";
	 *
	 * assert.deepStrictEqual(sequence(Applicative)([right("a"), right("b")]), right(["a", "b"]));
	 * assert.deepStrictEqual(
	 *   sequence(Applicative)([right("a"), left(new Error("not a string"))]),
	 *   left(new Error("not a string"))
	 * );
	 *
	 * @category traversing
	 * @since 2.6.3
	 */
	var sequence = function (F) {
	    return function (ta) {
	        return _reduce(ta, F.of((0, exports.zero)()), function (fas, fa) {
	            return F.ap(F.map(fas, function (as) { return function (a) { return (0, function_1.pipe)(as, (0, exports.append)(a)); }; }), fa);
	        });
	    };
	};
	exports.sequence = sequence;
	/**
	 * Same as [`traverse`](#traverse) but passing also the index to the iterating function.
	 *
	 * @example
	 * import { traverseWithIndex } from 'fp-ts/Array'
	 * import { Applicative, left, right } from "fp-ts/lib/Either";
	 *
	 * const f = (index:number, x:unknown) =>
	 *   typeof x === "string" ? right(x.toUpperCase() + index) : left(new Error("not a string"));
	 * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)(["a", "b"]), right(["A0", "B1"]));
	 * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)(["a", 5]), left(new Error("not a string")));
	 *
	 * @category sequencing
	 * @since 2.6.3
	 */
	var traverseWithIndex = function (F) {
	    return function (f) {
	        return (0, exports.reduceWithIndex)(F.of((0, exports.zero)()), function (i, fbs, a) {
	            return F.ap(F.map(fbs, function (bs) { return function (b) { return (0, function_1.pipe)(bs, (0, exports.append)(b)); }; }), f(i, a));
	        });
	    };
	};
	exports.traverseWithIndex = traverseWithIndex;
	/**
	 * @category filtering
	 * @since 2.6.5
	 */
	var wither = function (F) {
	    var _witherF = _wither(F);
	    return function (f) { return function (fa) { return _witherF(fa, f); }; };
	};
	exports.wither = wither;
	/**
	 * @category filtering
	 * @since 2.6.5
	 */
	var wilt = function (F) {
	    var _wiltF = _wilt(F);
	    return function (f) { return function (fa) { return _wiltF(fa, f); }; };
	};
	exports.wilt = wilt;
	/**
	 * `unfold` takes a function `f` which returns an `Option` of a tuple containing an outcome
	 * value and an input for the following iteration.
	 * `unfold` applies `f` to the initial value `b` and then recursively to the second
	 * element of the tuple contained in the returned `option` of the previous
	 * calculation until `f` returns `Option.none`.
	 *
	 * @example
	 * import { unfold } from 'fp-ts/Array'
	 * import { option } from 'fp-ts'
	 *
	 * const f = (n: number) => {
	 *   if (n <= 0) return option.none;
	 *   const returnValue = n * 2;
	 *   const inputForNextRound = n - 1;
	 *   return option.some([returnValue, inputForNextRound] as const);
	 * };
	 * assert.deepStrictEqual(unfold(5, f), [10, 8, 6, 4, 2]);
	 *
	 * @since 2.6.6
	 */
	var unfold = function (b, f) {
	    var out = [];
	    var bb = b;
	    // eslint-disable-next-line no-constant-condition
	    while (true) {
	        var mt = f(bb);
	        if (_.isSome(mt)) {
	            var _a = mt.value, a = _a[0], b_1 = _a[1];
	            out.push(a);
	            bb = b_1;
	        }
	        else {
	            break;
	        }
	    }
	    return out;
	};
	exports.unfold = unfold;
	/**
	 * @category type lambdas
	 * @since 2.0.0
	 */
	exports.URI = 'Array';
	/**
	 * `getShow` makes a `Show` for an `Array<A>` from a `Show` for
	 * an `A`.
	 *
	 * @example
	 * import { getShow } from 'fp-ts/Array'
	 *
	 * const numShow = { show: (n: number) => (n >= 0 ? `${n}` : `(${-n})`) };
	 * assert.deepStrictEqual(getShow(numShow).show([-2, -1, 0, 1]), "[(2), (1), 0, 1]");
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	exports.getShow = RA.getShow;
	/**
	 * Get a `Semigroup` based on the concatenation of `Array`s.
	 * See also [`getMonoid`](#getMonoid).
	 *
	 * @example
	 * import { getSemigroup } from 'fp-ts/Array'
	 *
	 * const S = getSemigroup<number>();
	 * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 2, 3]);
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	var getSemigroup = function () { return ({
	    concat: function (first, second) { return first.concat(second); }
	}); };
	exports.getSemigroup = getSemigroup;
	/**
	 * Returns a `Monoid` for `Array<A>` based on the concatenation of `Array`s.
	 *
	 * @example
	 * import { getMonoid } from 'fp-ts/Array'
	 *
	 * const M = getMonoid<number>()
	 * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	var getMonoid = function () { return ({
	    concat: (0, exports.getSemigroup)().concat,
	    empty: []
	}); };
	exports.getMonoid = getMonoid;
	/**
	 * Derives an `Eq` over the `Array` of a given element type from the `Eq` of that type. The derived `Eq` defines two
	 * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of
	 * different lengths, the result is non equality.
	 *
	 * @example
	 * import * as S from 'fp-ts/string'
	 * import { getEq } from 'fp-ts/Array'
	 *
	 * const E = getEq(S.Eq)
	 * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)
	 * assert.strictEqual(E.equals(['a'], []), false)
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	exports.getEq = RA.getEq;
	/**
	 * Derives an `Ord` over the `Array` of a given element type from the `Ord` of that type. The ordering between two such
	 * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in
	 * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have
	 * the same length, the result is equality.
	 *
	 * @example
	 * import { getOrd } from 'fp-ts/Array'
	 * import * as S from 'fp-ts/string'
	 *
	 * const O = getOrd(S.Ord)
	 * assert.strictEqual(O.compare(['b'], ['a']), 1)
	 * assert.strictEqual(O.compare(['a'], ['a']), 0)
	 * assert.strictEqual(O.compare(['a'], ['b']), -1)
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	exports.getOrd = RA.getOrd;
	/**
	 * Get a `Semigroup` based on the union of the elements of `Array`s.
	 * Elements which equal according to the provided `Eq` are included
	 * only once in the result.
	 * See also [`getUnionMonoid`](#getUnionMonoid).
	 *
	 * @example
	 * import { getUnionSemigroup } from 'fp-ts/Array';
	 * import { Eq } from 'fp-ts/number';
	 *
	 * const S = getUnionSemigroup<number>(Eq);
	 * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 3]);
	 *
	 * @category instances
	 * @since 2.11.0
	 */
	var getUnionSemigroup = function (E) {
	    var unionE = union(E);
	    return {
	        concat: function (first, second) { return unionE(second)(first); }
	    };
	};
	exports.getUnionSemigroup = getUnionSemigroup;
	/**
	 * Get a `Monoid` based on the union of the elements of `Array`s.
	 * Elements which equal according to the provided `Eq` are included
	 * only once in the result.
	 *
	 * @example
	 * import { getUnionMonoid } from 'fp-ts/Array'
	 * import { Eq } from 'fp-ts/number';
	 *
	 * const M = getUnionMonoid<number>(Eq);
	 * assert.deepStrictEqual(M.concat([1, 2], [2, 3]), [1, 2, 3]);
	 * assert.deepStrictEqual(M.empty,[]);
	 *
	 * @category instances
	 * @since 2.11.0
	 */
	var getUnionMonoid = function (E) { return ({
	    concat: (0, exports.getUnionSemigroup)(E).concat,
	    empty: []
	}); };
	exports.getUnionMonoid = getUnionMonoid;
	/**
	 * Get a `Semigroup` based on the intersection of the elements of `Array`s.
	 * Only elements present in the two arrays which are equal according to the
	 * provided `Eq` are included in the result.
	 *
	 * @example
	 * import { getIntersectionSemigroup } from 'fp-ts/Array'
	 * import { Eq } from 'fp-ts/number';
	 *
	 * const S = getIntersectionSemigroup<number>(Eq);
	 * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [2]);
	 *
	 * @category instances
	 * @since 2.11.0
	 */
	var getIntersectionSemigroup = function (E) {
	    var intersectionE = intersection(E);
	    return {
	        concat: function (first, second) { return intersectionE(second)(first); }
	    };
	};
	exports.getIntersectionSemigroup = getIntersectionSemigroup;
	/**
	 * Get a `Magma` for `Array` where the `concat` function is the differnce between
	 * the first and the second array, i.e. the result contains all the elements of the
	 * first array for which their is no equal element in the second array according
	 * to the `Eq` provided.
	 *
	 *
	 * @example
	 * import { getDifferenceMagma } from 'fp-ts/Array'
	 * import { Eq } from 'fp-ts/number';
	 *
	 * const S = getDifferenceMagma<number>(Eq);
	 * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1]);
	 *
	 * @category instances
	 * @since 2.11.0
	 */
	var getDifferenceMagma = function (E) {
	    var differenceE = difference(E);
	    return {
	        concat: function (first, second) { return differenceE(second)(first); }
	    };
	};
	exports.getDifferenceMagma = getDifferenceMagma;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Functor = {
	    URI: exports.URI,
	    map: _map
	};
	/**
	 * Given an input an `Array` of functions, `flap` returns an `Array` containing
	 * the results of applying each function to the given input.
	 *
	 * @example
	 * import { flap } from 'fp-ts/Array'
	 *
	 * const funs = [
	 *   (n: number) => `Double: ${n * 2}`,
	 *   (n: number) => `Triple: ${n * 3}`,
	 *   (n: number) => `Square: ${n * n}`,
	 * ];
	 * assert.deepStrictEqual(flap(4)(funs), ['Double: 8', 'Triple: 12', 'Square: 16']);
	 *
	 * @category mapping
	 * @since 2.10.0
	 */
	exports.flap = (0, Functor_1.flap)(exports.Functor);
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Pointed = {
	    URI: exports.URI,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.FunctorWithIndex = {
	    URI: exports.URI,
	    map: _map,
	    mapWithIndex: _mapWithIndex
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Apply = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap
	};
	/**
	 * Combine two effectful actions, keeping only the result of the first.
	 *
	 * @since 2.5.0
	 */
	exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
	/**
	 * Combine two effectful actions, keeping only the result of the second.
	 *
	 * @since 2.5.0
	 */
	exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Applicative = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Chain = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap
	};
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @example
	 * import * as A from 'fp-ts/Array'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     A.chainFirst(() => ['a', 'b'])
	 *   ),
	 *   [1, 1, 2, 2, 3, 3]
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     [1, 2, 3],
	 *     A.chainFirst(() => [])
	 *   ),
	 *   []
	 * )
	 *
	 * @category sequencing
	 * @since 2.0.0
	 */
	exports.chainFirst = 
	/*#__PURE__*/ (0, Chain_1.chainFirst)(exports.Chain);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Monad = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    chain: exports.flatMap
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Unfoldable = {
	    URI: exports.URI,
	    unfold: exports.unfold
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Alt = {
	    URI: exports.URI,
	    map: _map,
	    alt: _alt
	};
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.Zero = {
	    URI: exports.URI,
	    zero: exports.zero
	};
	/**
	 * @category do notation
	 * @since 2.11.0
	 */
	exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Alternative = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    alt: _alt,
	    zero: exports.zero
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Extend = {
	    URI: exports.URI,
	    map: _map,
	    extend: _extend
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Compactable = {
	    URI: exports.URI,
	    compact: exports.compact,
	    separate: exports.separate
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Filterable = {
	    URI: exports.URI,
	    map: _map,
	    compact: exports.compact,
	    separate: exports.separate,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.FilterableWithIndex = {
	    URI: exports.URI,
	    map: _map,
	    mapWithIndex: _mapWithIndex,
	    compact: exports.compact,
	    separate: exports.separate,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap,
	    partitionMapWithIndex: _partitionMapWithIndex,
	    partitionWithIndex: _partitionWithIndex,
	    filterMapWithIndex: _filterMapWithIndex,
	    filterWithIndex: _filterWithIndex
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Foldable = {
	    URI: exports.URI,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.FoldableWithIndex = {
	    URI: exports.URI,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Traversable = {
	    URI: exports.URI,
	    map: _map,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.TraversableWithIndex = {
	    URI: exports.URI,
	    map: _map,
	    mapWithIndex: _mapWithIndex,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    traverseWithIndex: _traverseWithIndex
	};
	var _wither = /*#__PURE__*/ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
	var _wilt = /*#__PURE__*/ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Witherable = {
	    URI: exports.URI,
	    map: _map,
	    compact: exports.compact,
	    separate: exports.separate,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    wither: _wither,
	    wilt: _wilt
	};
	/**
	 * @category sequencing
	 * @since 2.11.0
	 */
	exports.chainRecDepthFirst = RA.chainRecDepthFirst;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.ChainRecDepthFirst = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap,
	    chainRec: _chainRecDepthFirst
	};
	/**
	 * @category sequencing
	 * @since 2.11.0
	 */
	exports.chainRecBreadthFirst = RA.chainRecBreadthFirst;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.ChainRecBreadthFirst = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap,
	    chainRec: _chainRecBreadthFirst
	};
	/**
	 * Filter values inside a context.
	 *
	 * @since 2.11.0
	 */
	exports.filterE = (0, Witherable_1.filterE)(exports.Witherable);
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.FromEither = {
	    URI: exports.URI,
	    fromEither: exports.fromEither
	};
	/**
	 * @category lifting
	 * @since 2.11.0
	 */
	exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
	// -------------------------------------------------------------------------------------
	// unsafe
	// -------------------------------------------------------------------------------------
	/**
	 * @category unsafe
	 * @since 2.0.0
	 */
	exports.unsafeInsertAt = NEA.unsafeInsertAt;
	/**
	 * @category unsafe
	 * @since 2.0.0
	 */
	var unsafeUpdateAt = function (i, a, as) {
	    return (0, exports.isNonEmpty)(as) ? NEA.unsafeUpdateAt(i, a, as) : [];
	};
	exports.unsafeUpdateAt = unsafeUpdateAt;
	/**
	 * @category unsafe
	 * @since 2.0.0
	 */
	var unsafeDeleteAt = function (i, as) {
	    var xs = as.slice();
	    xs.splice(i, 1);
	    return xs;
	};
	exports.unsafeDeleteAt = unsafeDeleteAt;
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * `every` tells if the provided predicate holds true for every element in the `Array`.
	 *
	 * @example
	 * import { every } from 'fp-ts/Array'
	 *
	 * assert.equal(every((x: number) => x >= 0)([1, 2, 3]), true);
	 * assert.equal(every((x: number) => x >= 0)([-1, 2, 3]), false);
	 *
	 * @since 2.9.0
	 */
	exports.every = RA.every;
	/**
	 * `some` tells if the provided predicate holds true at least for one element in the `Array`.
	 *
	 * @example
	 * import { some } from 'fp-ts/Array'
	 *
	 * assert.equal(some((x: number) => x >= 0)([1, 2, 3]), true);
	 * assert.equal(some((x: number) => x >= 10)([1, 2, 3]), false);
	 *
	 * @since 2.9.0
	 */
	var some = function (predicate) {
	    return function (as) {
	        return as.some(predicate);
	    };
	};
	exports.some = some;
	/**
	 * Alias of [`some`](#some)
	 *
	 * @since 2.11.0
	 */
	exports.exists = exports.some;
	/**
	 * Places an element in between members of an `Array`, then folds the results using the provided `Monoid`.
	 *
	 * @example
	 * import * as S from 'fp-ts/string'
	 * import { intercalate } from 'fp-ts/Array'
	 *
	 * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
	 *
	 * @since 2.12.0
	 */
	exports.intercalate = RA.intercalate;
	// -------------------------------------------------------------------------------------
	// do notation
	// -------------------------------------------------------------------------------------
	/**
	 * @category do notation
	 * @since 2.9.0
	 */
	exports.Do = (0, exports.of)(_.emptyRecord);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
	var let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);
	exports.let = let_;
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bind = (0, Chain_1.bind)(exports.Chain);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.apS = (0, Apply_1.apS)(exports.Apply);
	// -------------------------------------------------------------------------------------
	// legacy
	// -------------------------------------------------------------------------------------
	/**
	 * Alias of `flatMap`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.chain = exports.flatMap;
	// -------------------------------------------------------------------------------------
	// deprecated
	// -------------------------------------------------------------------------------------
	/**
	 * Use `NonEmptyArray` module instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.range = NEA.range;
	/**
	 * Use a new `[]` instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.empty = [];
	/**
	 * Use `prepend` instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.cons = NEA.cons;
	/**
	 * Use `append` instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.snoc = NEA.snoc;
	/**
	 * Use `prependAll` instead
	 *
	 * @category zone of death
	 * @since 2.9.0
	 * @deprecated
	 */
	exports.prependToAll = exports.prependAll;
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Functor` instance, pass `A.Functor` instead of `A.array`
	 * (where `A` is from `import A from 'fp-ts/Array'`)
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.array = {
	    URI: exports.URI,
	    compact: exports.compact,
	    separate: exports.separate,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    chain: exports.flatMap,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap,
	    mapWithIndex: _mapWithIndex,
	    partitionMapWithIndex: _partitionMapWithIndex,
	    partitionWithIndex: _partitionWithIndex,
	    filterMapWithIndex: _filterMapWithIndex,
	    filterWithIndex: _filterWithIndex,
	    alt: _alt,
	    zero: exports.zero,
	    unfold: exports.unfold,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    reduceWithIndex: _reduceWithIndex,
	    foldMapWithIndex: _foldMapWithIndex,
	    reduceRightWithIndex: _reduceRightWithIndex,
	    traverseWithIndex: _traverseWithIndex,
	    extend: _extend,
	    wither: _wither,
	    wilt: _wilt
	}; 
} (_Array));

var Option = {};

var Applicative = {};

Object.defineProperty(Applicative, "__esModule", { value: true });
Applicative.getApplicativeComposition = Applicative.getApplicativeMonoid = void 0;
/**
 * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values
 * of type `f a` from values of type `a`.
 *
 * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are
 * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the
 * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for
 * any number of function arguments.
 *
 * Instances must satisfy the following laws in addition to the `Apply` laws:
 *
 * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`
 * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`
 * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`
 *
 * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`
 *
 * @since 2.0.0
 */
var Apply_1$1 = Apply;
var function_1$5 = _function;
var Functor_1$3 = Functor;
function getApplicativeMonoid(F) {
    var f = (0, Apply_1$1.getApplySemigroup)(F);
    return function (M) { return ({
        concat: f(M).concat,
        empty: F.of(M.empty)
    }); };
}
Applicative.getApplicativeMonoid = getApplicativeMonoid;
/** @deprecated */
function getApplicativeComposition(F, G) {
    var map = (0, Functor_1$3.getFunctorComposition)(F, G).map;
    var _ap = (0, Apply_1$1.ap)(F, G);
    return {
        map: map,
        of: function (a) { return F.of(G.of(a)); },
        ap: function (fgab, fga) { return (0, function_1$5.pipe)(fgab, _ap(fga)); }
    };
}
Applicative.getApplicativeComposition = getApplicativeComposition;

var Predicate = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.and = exports.or = exports.not = exports.Contravariant = exports.getMonoidAll = exports.getSemigroupAll = exports.getMonoidAny = exports.getSemigroupAny = exports.URI = exports.contramap = void 0;
	var function_1 = _function;
	var contramap_ = function (predicate, f) { return (0, function_1.pipe)(predicate, (0, exports.contramap)(f)); };
	/**
	 * @since 2.11.0
	 */
	var contramap = function (f) {
	    return function (predicate) {
	        return (0, function_1.flow)(f, predicate);
	    };
	};
	exports.contramap = contramap;
	/**
	 * @category type lambdas
	 * @since 2.11.0
	 */
	exports.URI = 'Predicate';
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	var getSemigroupAny = function () { return ({
	    concat: function (first, second) { return (0, function_1.pipe)(first, (0, exports.or)(second)); }
	}); };
	exports.getSemigroupAny = getSemigroupAny;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	var getMonoidAny = function () { return ({
	    concat: (0, exports.getSemigroupAny)().concat,
	    empty: function_1.constFalse
	}); };
	exports.getMonoidAny = getMonoidAny;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	var getSemigroupAll = function () { return ({
	    concat: function (first, second) { return (0, function_1.pipe)(first, (0, exports.and)(second)); }
	}); };
	exports.getSemigroupAll = getSemigroupAll;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	var getMonoidAll = function () { return ({
	    concat: (0, exports.getSemigroupAll)().concat,
	    empty: function_1.constTrue
	}); };
	exports.getMonoidAll = getMonoidAll;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.Contravariant = {
	    URI: exports.URI,
	    contramap: contramap_
	};
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * @since 2.11.0
	 */
	var not = function (predicate) {
	    return function (a) {
	        return !predicate(a);
	    };
	};
	exports.not = not;
	/**
	 * @since 2.11.0
	 */
	var or = function (second) {
	    return function (first) {
	        return function (a) {
	            return first(a) || second(a);
	        };
	    };
	};
	exports.or = or;
	/**
	 * @since 2.11.0
	 */
	var and = function (second) {
	    return function (first) {
	        return function (a) {
	            return first(a) && second(a);
	        };
	    };
	};
	exports.and = and; 
} (Predicate));

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Witherable = exports.wilt = exports.wither = exports.Traversable = exports.sequence = exports.traverse = exports.Filterable = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.Compactable = exports.separate = exports.compact = exports.Extend = exports.extend = exports.Alternative = exports.guard = exports.Zero = exports.zero = exports.Alt = exports.alt = exports.altW = exports.orElse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.flatMap = exports.Applicative = exports.Apply = exports.ap = exports.Pointed = exports.of = exports.asUnit = exports.as = exports.Functor = exports.map = exports.getMonoid = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.getRight = exports.getLeft = exports.fromPredicate = exports.some = exports.none = void 0;
	exports.getFirstMonoid = exports.getApplyMonoid = exports.getApplySemigroup = exports.option = exports.mapNullable = exports.getRefinement = exports.chainFirst = exports.chain = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toUndefined = exports.toNullable = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.duplicate = exports.tapEither = exports.tap = exports.flatten = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isNone = exports.isSome = exports.FromEither = exports.fromEither = exports.MonadThrow = exports.throwError = void 0;
	exports.getLastMonoid = void 0;
	var Applicative_1 = Applicative;
	var Apply_1 = Apply;
	var chainable = __importStar(Chain);
	var FromEither_1 = FromEither;
	var function_1 = _function;
	var Functor_1 = Functor;
	var _ = __importStar(internal);
	var Predicate_1 = Predicate;
	var Semigroup_1 = Semigroup;
	var Separated_1 = Separated;
	var Witherable_1 = Witherable;
	var Zero_1 = Zero;
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.
	 *
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.none = _.none;
	/**
	 * Constructs a `Some`. Represents an optional value that exists.
	 *
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.some = _.some;
	function fromPredicate(predicate) {
	    return function (a) { return (predicate(a) ? (0, exports.some)(a) : exports.none); };
	}
	exports.fromPredicate = fromPredicate;
	/**
	 * Returns the `Left` value of an `Either` if possible.
	 *
	 * @example
	 * import { getLeft, none, some } from 'fp-ts/Option'
	 * import { right, left } from 'fp-ts/Either'
	 *
	 * assert.deepStrictEqual(getLeft(right(1)), none)
	 * assert.deepStrictEqual(getLeft(left('a')), some('a'))
	 *
	 * @category constructors
	 * @since 2.0.0
	 */
	var getLeft = function (ma) { return (ma._tag === 'Right' ? exports.none : (0, exports.some)(ma.left)); };
	exports.getLeft = getLeft;
	/**
	 * Returns the `Right` value of an `Either` if possible.
	 *
	 * @example
	 * import { getRight, none, some } from 'fp-ts/Option'
	 * import { right, left } from 'fp-ts/Either'
	 *
	 * assert.deepStrictEqual(getRight(right(1)), some(1))
	 * assert.deepStrictEqual(getRight(left('a')), none)
	 *
	 * @category constructors
	 * @since 2.0.0
	 */
	var getRight = function (ma) { return (ma._tag === 'Left' ? exports.none : (0, exports.some)(ma.right)); };
	exports.getRight = getRight;
	var _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };
	var _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };
	var _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };
	var _foldMap = function (M) {
	    var foldMapM = (0, exports.foldMap)(M);
	    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };
	};
	var _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };
	var _traverse = function (F) {
	    var traverseF = (0, exports.traverse)(F);
	    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };
	};
	/* istanbul ignore next */
	var _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };
	var _filter = function (fa, predicate) { return (0, function_1.pipe)(fa, (0, exports.filter)(predicate)); };
	/* istanbul ignore next */
	var _filterMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.filterMap)(f)); };
	/* istanbul ignore next */
	var _extend = function (wa, f) { return (0, function_1.pipe)(wa, (0, exports.extend)(f)); };
	/* istanbul ignore next */
	var _partition = function (fa, predicate) {
	    return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
	};
	/* istanbul ignore next */
	var _partitionMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f)); };
	/**
	 * @category type lambdas
	 * @since 2.0.0
	 */
	exports.URI = 'Option';
	/**
	 * @category instances
	 * @since 2.0.0
	 */
	var getShow = function (S) { return ({
	    show: function (ma) { return ((0, exports.isNone)(ma) ? 'none' : "some(".concat(S.show(ma.value), ")")); }
	}); };
	exports.getShow = getShow;
	/**
	 * @example
	 * import { none, some, getEq } from 'fp-ts/Option'
	 * import * as N from 'fp-ts/number'
	 *
	 * const E = getEq(N.Eq)
	 * assert.strictEqual(E.equals(none, none), true)
	 * assert.strictEqual(E.equals(none, some(1)), false)
	 * assert.strictEqual(E.equals(some(1), none), false)
	 * assert.strictEqual(E.equals(some(1), some(2)), false)
	 * assert.strictEqual(E.equals(some(1), some(1)), true)
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	var getEq = function (E) { return ({
	    equals: function (x, y) { return x === y || ((0, exports.isNone)(x) ? (0, exports.isNone)(y) : (0, exports.isNone)(y) ? false : E.equals(x.value, y.value)); }
	}); };
	exports.getEq = getEq;
	/**
	 * The `Ord` instance allows `Option` values to be compared with
	 * `compare`, whenever there is an `Ord` instance for
	 * the type the `Option` contains.
	 *
	 * `None` is considered to be less than any `Some` value.
	 *
	 *
	 * @example
	 * import { none, some, getOrd } from 'fp-ts/Option'
	 * import * as N from 'fp-ts/number'
	 *
	 * const O = getOrd(N.Ord)
	 * assert.strictEqual(O.compare(none, none), 0)
	 * assert.strictEqual(O.compare(none, some(1)), -1)
	 * assert.strictEqual(O.compare(some(1), none), 1)
	 * assert.strictEqual(O.compare(some(1), some(2)), -1)
	 * assert.strictEqual(O.compare(some(1), some(1)), 0)
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	var getOrd = function (O) { return ({
	    equals: (0, exports.getEq)(O).equals,
	    compare: function (x, y) { return (x === y ? 0 : (0, exports.isSome)(x) ? ((0, exports.isSome)(y) ? O.compare(x.value, y.value) : 1) : -1); }
	}); };
	exports.getOrd = getOrd;
	/**
	 * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are
	 * concatenated using the provided `Semigroup`
	 *
	 * | x       | y       | concat(x, y)       |
	 * | ------- | ------- | ------------------ |
	 * | none    | none    | none               |
	 * | some(a) | none    | some(a)            |
	 * | none    | some(b) | some(b)            |
	 * | some(a) | some(b) | some(concat(a, b)) |
	 *
	 * @example
	 * import { getMonoid, some, none } from 'fp-ts/Option'
	 * import { SemigroupSum } from 'fp-ts/number'
	 *
	 * const M = getMonoid(SemigroupSum)
	 * assert.deepStrictEqual(M.concat(none, none), none)
	 * assert.deepStrictEqual(M.concat(some(1), none), some(1))
	 * assert.deepStrictEqual(M.concat(none, some(1)), some(1))
	 * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	var getMonoid = function (S) { return ({
	    concat: function (x, y) { return ((0, exports.isNone)(x) ? y : (0, exports.isNone)(y) ? x : (0, exports.some)(S.concat(x.value, y.value))); },
	    empty: exports.none
	}); };
	exports.getMonoid = getMonoid;
	/**
	 * @category mapping
	 * @since 2.0.0
	 */
	var map = function (f) { return function (fa) {
	    return (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(f(fa.value));
	}; };
	exports.map = map;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Functor = {
	    URI: exports.URI,
	    map: _map
	};
	/**
	 * Maps the `Some` value of this `Option` to the specified constant value.
	 *
	 * @category mapping
	 * @since 2.16.0
	 */
	exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
	/**
	 * Maps the `Some` value of this `Option` to the void constant value.
	 *
	 * @category mapping
	 * @since 2.16.0
	 */
	exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
	/**
	 * @category constructors
	 * @since 2.7.0
	 */
	exports.of = exports.some;
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Pointed = {
	    URI: exports.URI,
	    of: exports.of
	};
	/**
	 * @since 2.0.0
	 */
	var ap = function (fa) { return function (fab) {
	    return (0, exports.isNone)(fab) ? exports.none : (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(fab.value(fa.value));
	}; };
	exports.ap = ap;
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Apply = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Applicative = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of
	};
	/**
	 * @category sequencing
	 * @since 2.14.0
	 */
	exports.flatMap = (0, function_1.dual)(2, function (ma, f) { return ((0, exports.isNone)(ma) ? exports.none : f(ma.value)); });
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Chain = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Monad = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    chain: exports.flatMap
	};
	/**
	 * @category folding
	 * @since 2.0.0
	 */
	var reduce = function (b, f) { return function (fa) {
	    return (0, exports.isNone)(fa) ? b : f(b, fa.value);
	}; };
	exports.reduce = reduce;
	/**
	 * @category folding
	 * @since 2.0.0
	 */
	var foldMap = function (M) { return function (f) { return function (fa) {
	    return (0, exports.isNone)(fa) ? M.empty : f(fa.value);
	}; }; };
	exports.foldMap = foldMap;
	/**
	 * @category folding
	 * @since 2.0.0
	 */
	var reduceRight = function (b, f) { return function (fa) {
	    return (0, exports.isNone)(fa) ? b : f(fa.value, b);
	}; };
	exports.reduceRight = reduceRight;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Foldable = {
	    URI: exports.URI,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight
	};
	/**
	 * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.
	 *
	 * @param self - The first `Option` to be checked.
	 * @param that - The `Option` to return if `self` is `None`.
	 *
	 * @example
	 * import * as O from "fp-ts/Option"
	 *
	 * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)
	 * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))
	 * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))
	 * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))
	 *
	 * @category error handling
	 * @since 2.16.0
	 */
	exports.orElse = (0, function_1.dual)(2, function (self, that) { return ((0, exports.isNone)(self) ? that() : self); });
	/**
	 * Alias of `orElse`.
	 *
	 * Less strict version of [`alt`](#alt).
	 *
	 * The `W` suffix (short for **W**idening) means that the return types will be merged.
	 *
	 * @category legacy
	 * @since 2.9.0
	 */
	exports.altW = exports.orElse;
	/**
	 * Alias of `orElse`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.alt = exports.orElse;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Alt = {
	    URI: exports.URI,
	    map: _map,
	    alt: _alt
	};
	/**
	 * @since 2.7.0
	 */
	var zero = function () { return exports.none; };
	exports.zero = zero;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.Zero = {
	    URI: exports.URI,
	    zero: exports.zero
	};
	/**
	 * @category do notation
	 * @since 2.11.0
	 */
	exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Alternative = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    alt: _alt,
	    zero: exports.zero
	};
	/**
	 * @since 2.0.0
	 */
	var extend = function (f) { return function (wa) {
	    return (0, exports.isNone)(wa) ? exports.none : (0, exports.some)(f(wa));
	}; };
	exports.extend = extend;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Extend = {
	    URI: exports.URI,
	    map: _map,
	    extend: _extend
	};
	/**
	 * @category filtering
	 * @since 2.0.0
	 */
	exports.compact = (0, exports.flatMap)(function_1.identity);
	var defaultSeparated = /*#__PURE__*/ (0, Separated_1.separated)(exports.none, exports.none);
	/**
	 * @category filtering
	 * @since 2.0.0
	 */
	var separate = function (ma) {
	    return (0, exports.isNone)(ma) ? defaultSeparated : (0, Separated_1.separated)((0, exports.getLeft)(ma.value), (0, exports.getRight)(ma.value));
	};
	exports.separate = separate;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Compactable = {
	    URI: exports.URI,
	    compact: exports.compact,
	    separate: exports.separate
	};
	/**
	 * @category filtering
	 * @since 2.0.0
	 */
	var filter = function (predicate) {
	    return function (fa) {
	        return (0, exports.isNone)(fa) ? exports.none : predicate(fa.value) ? fa : exports.none;
	    };
	};
	exports.filter = filter;
	/**
	 * @category filtering
	 * @since 2.0.0
	 */
	var filterMap = function (f) { return function (fa) {
	    return (0, exports.isNone)(fa) ? exports.none : f(fa.value);
	}; };
	exports.filterMap = filterMap;
	/**
	 * @category filtering
	 * @since 2.0.0
	 */
	var partition = function (predicate) {
	    return function (fa) {
	        return (0, Separated_1.separated)(_filter(fa, (0, Predicate_1.not)(predicate)), _filter(fa, predicate));
	    };
	};
	exports.partition = partition;
	/**
	 * @category filtering
	 * @since 2.0.0
	 */
	var partitionMap = function (f) { return (0, function_1.flow)((0, exports.map)(f), exports.separate); };
	exports.partitionMap = partitionMap;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Filterable = {
	    URI: exports.URI,
	    map: _map,
	    compact: exports.compact,
	    separate: exports.separate,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap
	};
	/**
	 * @category traversing
	 * @since 2.6.3
	 */
	var traverse = function (F) {
	    return function (f) {
	        return function (ta) {
	            return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(f(ta.value), exports.some);
	        };
	    };
	};
	exports.traverse = traverse;
	/**
	 * @category traversing
	 * @since 2.6.3
	 */
	var sequence = function (F) {
	    return function (ta) {
	        return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(ta.value, exports.some);
	    };
	};
	exports.sequence = sequence;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Traversable = {
	    URI: exports.URI,
	    map: _map,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence
	};
	var _wither = /*#__PURE__*/ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
	var _wilt = /*#__PURE__*/ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
	/**
	 * @category filtering
	 * @since 2.6.5
	 */
	var wither = function (F) {
	    var _witherF = _wither(F);
	    return function (f) { return function (fa) { return _witherF(fa, f); }; };
	};
	exports.wither = wither;
	/**
	 * @category filtering
	 * @since 2.6.5
	 */
	var wilt = function (F) {
	    var _wiltF = _wilt(F);
	    return function (f) { return function (fa) { return _wiltF(fa, f); }; };
	};
	exports.wilt = wilt;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Witherable = {
	    URI: exports.URI,
	    map: _map,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    compact: exports.compact,
	    separate: exports.separate,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap,
	    wither: _wither,
	    wilt: _wilt
	};
	/**
	 * @since 2.7.0
	 */
	var throwError = function () { return exports.none; };
	exports.throwError = throwError;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.MonadThrow = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    chain: exports.flatMap,
	    throwError: exports.throwError
	};
	/**
	 * Transforms an `Either` to an `Option` discarding the error.
	 *
	 * Alias of [getRight](#getright)
	 *
	 * @category conversions
	 * @since 2.0.0
	 */
	exports.fromEither = exports.getRight;
	/**
	 * @category instances
	 * @since 2.11.0
	 */
	exports.FromEither = {
	    URI: exports.URI,
	    fromEither: exports.fromEither
	};
	// -------------------------------------------------------------------------------------
	// refinements
	// -------------------------------------------------------------------------------------
	/**
	 * Returns `true` if the option is an instance of `Some`, `false` otherwise.
	 *
	 * @example
	 * import { some, none, isSome } from 'fp-ts/Option'
	 *
	 * assert.strictEqual(isSome(some(1)), true)
	 * assert.strictEqual(isSome(none), false)
	 *
	 * @category refinements
	 * @since 2.0.0
	 */
	exports.isSome = _.isSome;
	/**
	 * Returns `true` if the option is `None`, `false` otherwise.
	 *
	 * @example
	 * import { some, none, isNone } from 'fp-ts/Option'
	 *
	 * assert.strictEqual(isNone(some(1)), false)
	 * assert.strictEqual(isNone(none), true)
	 *
	 * @category refinements
	 * @since 2.0.0
	 */
	var isNone = function (fa) { return fa._tag === 'None'; };
	exports.isNone = isNone;
	/**
	 * Less strict version of [`match`](#match).
	 *
	 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	var matchW = function (onNone, onSome) {
	    return function (ma) {
	        return (0, exports.isNone)(ma) ? onNone() : onSome(ma.value);
	    };
	};
	exports.matchW = matchW;
	/**
	 * Alias of [`matchW`](#matchw).
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.foldW = exports.matchW;
	/**
	 * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is
	 * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.
	 *
	 * @example
	 * import { some, none, match } from 'fp-ts/Option'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.strictEqual(
	 *   pipe(
	 *     some(1),
	 *     match(() => 'a none', a => `a some containing ${a}`)
	 *   ),
	 *   'a some containing 1'
	 * )
	 *
	 * assert.strictEqual(
	 *   pipe(
	 *     none,
	 *     match(() => 'a none', a => `a some containing ${a}`)
	 *   ),
	 *   'a none'
	 * )
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.match = exports.matchW;
	/**
	 * Alias of [`match`](#match).
	 *
	 * @category pattern matching
	 * @since 2.0.0
	 */
	exports.fold = exports.match;
	/**
	 * Less strict version of [`getOrElse`](#getorelse).
	 *
	 * The `W` suffix (short for **W**idening) means that the handler return type will be merged.
	 *
	 * @category error handling
	 * @since 2.6.0
	 */
	var getOrElseW = function (onNone) {
	    return function (ma) {
	        return (0, exports.isNone)(ma) ? onNone() : ma.value;
	    };
	};
	exports.getOrElseW = getOrElseW;
	/**
	 * Extracts the value out of the structure, if it exists. Otherwise returns the given default value
	 *
	 * @example
	 * import { some, none, getOrElse } from 'fp-ts/Option'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.strictEqual(
	 *   pipe(
	 *     some(1),
	 *     getOrElse(() => 0)
	 *   ),
	 *   1
	 * )
	 * assert.strictEqual(
	 *   pipe(
	 *     none,
	 *     getOrElse(() => 0)
	 *   ),
	 *   0
	 * )
	 *
	 * @category error handling
	 * @since 2.0.0
	 */
	exports.getOrElse = exports.getOrElseW;
	/**
	 * @category mapping
	 * @since 2.10.0
	 */
	exports.flap = (0, Functor_1.flap)(exports.Functor);
	/**
	 * Combine two effectful actions, keeping only the result of the first.
	 *
	 * @since 2.0.0
	 */
	exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
	/**
	 * Combine two effectful actions, keeping only the result of the second.
	 *
	 * @since 2.0.0
	 */
	exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
	/**
	 * @category sequencing
	 * @since 2.0.0
	 */
	exports.flatten = exports.compact;
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @category combinators
	 * @since 2.15.0
	 */
	exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @example
	 * import { pipe } from 'fp-ts/function'
	 * import * as O from 'fp-ts/Option'
	 * import * as E from 'fp-ts/Either'
	 *
	 * const compute = (value: number) => pipe(
	 *   O.of(value),
	 *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),
	 * )
	 *
	 * assert.deepStrictEqual(compute(1), O.of(1))
	 * assert.deepStrictEqual(compute(-42), O.none)
	 *
	 * @category combinators
	 * @since 2.16.0
	 */
	exports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));
	/**
	 * @since 2.0.0
	 */
	exports.duplicate = (0, exports.extend)(function_1.identity);
	/**
	 * @category lifting
	 * @since 2.11.0
	 */
	exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
	/**
	 * @category sequencing
	 * @since 2.11.0
	 */
	exports.chainEitherK = 
	/*#__PURE__*/ (0, FromEither_1.chainEitherK)(exports.FromEither, exports.Chain);
	/**
	 * Alias of `tapEither`.
	 *
	 * @category legacy
	 * @since 2.12.0
	 */
	exports.chainFirstEitherK = exports.tapEither;
	/**
	 * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise
	 * returns the value wrapped in a `Some`.
	 *
	 * @example
	 * import { none, some, fromNullable } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(fromNullable(undefined), none)
	 * assert.deepStrictEqual(fromNullable(null), none)
	 * assert.deepStrictEqual(fromNullable(1), some(1))
	 *
	 * @category conversions
	 * @since 2.0.0
	 */
	var fromNullable = function (a) { return (a == null ? exports.none : (0, exports.some)(a)); };
	exports.fromNullable = fromNullable;
	/**
	 * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a
	 * `Some`.
	 *
	 * See also [`tryCatchK`](#trycatchk).
	 *
	 * @example
	 * import { none, some, tryCatch } from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(
	 *   tryCatch(() => {
	 *     throw new Error()
	 *   }),
	 *   none
	 * )
	 * assert.deepStrictEqual(tryCatch(() => 1), some(1))
	 *
	 * @category interop
	 * @since 2.0.0
	 */
	var tryCatch = function (f) {
	    try {
	        return (0, exports.some)(f());
	    }
	    catch (e) {
	        return exports.none;
	    }
	};
	exports.tryCatch = tryCatch;
	/**
	 * Converts a function that may throw to one returning a `Option`.
	 *
	 * @category interop
	 * @since 2.10.0
	 */
	var tryCatchK = function (f) {
	    return function () {
	        var a = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            a[_i] = arguments[_i];
	        }
	        return (0, exports.tryCatch)(function () { return f.apply(void 0, a); });
	    };
	};
	exports.tryCatchK = tryCatchK;
	/**
	 * Returns a *smart constructor* from a function that returns a nullable value.
	 *
	 * @example
	 * import { fromNullableK, none, some } from 'fp-ts/Option'
	 *
	 * const f = (s: string): number | undefined => {
	 *   const n = parseFloat(s)
	 *   return isNaN(n) ? undefined : n
	 * }
	 *
	 * const g = fromNullableK(f)
	 *
	 * assert.deepStrictEqual(g('1'), some(1))
	 * assert.deepStrictEqual(g('a'), none)
	 *
	 * @category lifting
	 * @since 2.9.0
	 */
	var fromNullableK = function (f) { return (0, function_1.flow)(f, exports.fromNullable); };
	exports.fromNullableK = fromNullableK;
	/**
	 * This is `chain` + `fromNullable`, useful when working with optional values.
	 *
	 * @example
	 * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * interface Employee {
	 *   readonly company?: {
	 *     readonly address?: {
	 *       readonly street?: {
	 *         readonly name?: string
	 *       }
	 *     }
	 *   }
	 * }
	 *
	 * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     fromNullable(employee1.company),
	 *     chainNullableK(company => company.address),
	 *     chainNullableK(address => address.street),
	 *     chainNullableK(street => street.name)
	 *   ),
	 *   some('high street')
	 * )
	 *
	 * const employee2: Employee = { company: { address: { street: {} } } }
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     fromNullable(employee2.company),
	 *     chainNullableK(company => company.address),
	 *     chainNullableK(address => address.street),
	 *     chainNullableK(street => street.name)
	 *   ),
	 *   none
	 * )
	 *
	 * @category sequencing
	 * @since 2.9.0
	 */
	var chainNullableK = function (f) {
	    return function (ma) {
	        return (0, exports.isNone)(ma) ? exports.none : (0, exports.fromNullable)(f(ma.value));
	    };
	};
	exports.chainNullableK = chainNullableK;
	/**
	 * Extracts the value out of the structure, if it exists. Otherwise returns `null`.
	 *
	 * @example
	 * import { some, none, toNullable } from 'fp-ts/Option'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.strictEqual(
	 *   pipe(
	 *     some(1),
	 *     toNullable
	 *   ),
	 *   1
	 * )
	 * assert.strictEqual(
	 *   pipe(
	 *     none,
	 *     toNullable
	 *   ),
	 *   null
	 * )
	 *
	 * @category conversions
	 * @since 2.0.0
	 */
	exports.toNullable = (0, exports.match)(function_1.constNull, function_1.identity);
	/**
	 * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.
	 *
	 * @example
	 * import { some, none, toUndefined } from 'fp-ts/Option'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.strictEqual(
	 *   pipe(
	 *     some(1),
	 *     toUndefined
	 *   ),
	 *   1
	 * )
	 * assert.strictEqual(
	 *   pipe(
	 *     none,
	 *     toUndefined
	 *   ),
	 *   undefined
	 * )
	 *
	 * @category conversions
	 * @since 2.0.0
	 */
	exports.toUndefined = (0, exports.match)(function_1.constUndefined, function_1.identity);
	function elem(E) {
	    return function (a, ma) {
	        if (ma === undefined) {
	            var elemE_1 = elem(E);
	            return function (ma) { return elemE_1(a, ma); };
	        }
	        return (0, exports.isNone)(ma) ? false : E.equals(a, ma.value);
	    };
	}
	exports.elem = elem;
	/**
	 * Returns `true` if the predicate is satisfied by the wrapped value
	 *
	 * @example
	 * import { some, none, exists } from 'fp-ts/Option'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.strictEqual(
	 *   pipe(
	 *     some(1),
	 *     exists(n => n > 0)
	 *   ),
	 *   true
	 * )
	 * assert.strictEqual(
	 *   pipe(
	 *     some(1),
	 *     exists(n => n > 1)
	 *   ),
	 *   false
	 * )
	 * assert.strictEqual(
	 *   pipe(
	 *     none,
	 *     exists(n => n > 0)
	 *   ),
	 *   false
	 * )
	 *
	 * @since 2.0.0
	 */
	var exists = function (predicate) {
	    return function (ma) {
	        return (0, exports.isNone)(ma) ? false : predicate(ma.value);
	    };
	};
	exports.exists = exists;
	// -------------------------------------------------------------------------------------
	// do notation
	// -------------------------------------------------------------------------------------
	/**
	 * @category do notation
	 * @since 2.9.0
	 */
	exports.Do = (0, exports.of)(_.emptyRecord);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
	var let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);
	exports.let = let_;
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bind = chainable.bind(exports.Chain);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.apS = (0, Apply_1.apS)(exports.Apply);
	/**
	 * @since 2.11.0
	 */
	exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
	// -------------------------------------------------------------------------------------
	// array utils
	// -------------------------------------------------------------------------------------
	/**
	 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyNonEmptyArrayWithIndex = function (f) {
	    return function (as) {
	        var o = f(0, _.head(as));
	        if ((0, exports.isNone)(o)) {
	            return exports.none;
	        }
	        var out = [o.value];
	        for (var i = 1; i < as.length; i++) {
	            var o_1 = f(i, as[i]);
	            if ((0, exports.isNone)(o_1)) {
	                return exports.none;
	            }
	            out.push(o_1.value);
	        }
	        return (0, exports.some)(out);
	    };
	};
	exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyArrayWithIndex = function (f) {
	    var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
	    return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };
	};
	exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverse(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	var traverseArray = function (f) {
	    return (0, exports.traverseReadonlyArrayWithIndex)(function (_, a) { return f(a); });
	};
	exports.traverseArray = traverseArray;
	/**
	 * Equivalent to `ReadonlyArray#sequence(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.sequenceArray = 
	/*#__PURE__*/ (0, exports.traverseArray)(function_1.identity);
	// -------------------------------------------------------------------------------------
	// legacy
	// -------------------------------------------------------------------------------------
	/**
	 * Alias of `flatMap`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.chain = exports.flatMap;
	/**
	 * Alias of `tap`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.chainFirst = exports.tap;
	// -------------------------------------------------------------------------------------
	// deprecated
	// -------------------------------------------------------------------------------------
	/**
	 * Use `Refinement` module instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	function getRefinement(getOption) {
	    return function (a) { return (0, exports.isSome)(getOption(a)); };
	}
	exports.getRefinement = getRefinement;
	/**
	 * Use [`chainNullableK`](#chainnullablek) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.mapNullable = exports.chainNullableK;
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`
	 * (where `O` is from `import O from 'fp-ts/Option'`)
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.option = {
	    URI: exports.URI,
	    map: _map,
	    of: exports.of,
	    ap: _ap,
	    chain: exports.flatMap,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    zero: exports.zero,
	    alt: _alt,
	    extend: _extend,
	    compact: exports.compact,
	    separate: exports.separate,
	    filter: _filter,
	    filterMap: _filterMap,
	    partition: _partition,
	    partitionMap: _partitionMap,
	    wither: _wither,
	    wilt: _wilt,
	    throwError: exports.throwError
	};
	/**
	 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getApplySemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);
	/**
	 * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getApplyMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
	/**
	 * Use
	 *
	 * ```ts
	 * import { first } from 'fp-ts/Semigroup'
	 * import { getMonoid } from 'fp-ts/Option'
	 *
	 * getMonoid(first())
	 * ```
	 *
	 * instead.
	 *
	 * Monoid returning the left-most non-`None` value
	 *
	 * | x       | y       | concat(x, y) |
	 * | ------- | ------- | ------------ |
	 * | none    | none    | none         |
	 * | some(a) | none    | some(a)      |
	 * | none    | some(b) | some(b)      |
	 * | some(a) | some(b) | some(a)      |
	 *
	 * @example
	 * import { getFirstMonoid, some, none } from 'fp-ts/Option'
	 *
	 * const M = getFirstMonoid<number>()
	 * assert.deepStrictEqual(M.concat(none, none), none)
	 * assert.deepStrictEqual(M.concat(some(1), none), some(1))
	 * assert.deepStrictEqual(M.concat(none, some(2)), some(2))
	 * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	var getFirstMonoid = function () { return (0, exports.getMonoid)((0, Semigroup_1.first)()); };
	exports.getFirstMonoid = getFirstMonoid;
	/**
	 * Use
	 *
	 * ```ts
	 * import { last } from 'fp-ts/Semigroup'
	 * import { getMonoid } from 'fp-ts/Option'
	 *
	 * getMonoid(last())
	 * ```
	 *
	 * instead.
	 *
	 * Monoid returning the right-most non-`None` value
	 *
	 * | x       | y       | concat(x, y) |
	 * | ------- | ------- | ------------ |
	 * | none    | none    | none         |
	 * | some(a) | none    | some(a)      |
	 * | none    | some(b) | some(b)      |
	 * | some(a) | some(b) | some(b)      |
	 *
	 * @example
	 * import { getLastMonoid, some, none } from 'fp-ts/Option'
	 *
	 * const M = getLastMonoid<number>()
	 * assert.deepStrictEqual(M.concat(none, none), none)
	 * assert.deepStrictEqual(M.concat(some(1), none), some(1))
	 * assert.deepStrictEqual(M.concat(none, some(2)), some(2))
	 * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	var getLastMonoid = function () { return (0, exports.getMonoid)((0, Semigroup_1.last)()); };
	exports.getLastMonoid = getLastMonoid; 
} (Option));

var TaskEither = {};

var Compactable = {};

var __createBinding$1 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$1 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
};
Object.defineProperty(Compactable, "__esModule", { value: true });
Compactable.getCompactableComposition = Compactable.separate = Compactable.compact = void 0;
var function_1$4 = _function;
var Functor_1$2 = Functor;
var Option_1$1 = Option;
var S = __importStar$1(Separated);
function compact(F, G) {
    return function (fga) { return F.map(fga, G.compact); };
}
Compactable.compact = compact;
function separate(F, C, G) {
    var _compact = compact(F, C);
    var _map = (0, Functor_1$2.map)(F, G);
    return function (fge) { return S.separated(_compact((0, function_1$4.pipe)(fge, _map(Option_1$1.getLeft))), _compact((0, function_1$4.pipe)(fge, _map(Option_1$1.getRight)))); };
}
Compactable.separate = separate;
/** @deprecated */
function getCompactableComposition(F, G) {
    var map = (0, Functor_1$2.getFunctorComposition)(F, G).map;
    return {
        map: map,
        compact: compact(F, G),
        separate: separate(F, G, G)
    };
}
Compactable.getCompactableComposition = getCompactableComposition;

var Either = {};

var ChainRec = {};

Object.defineProperty(ChainRec, "__esModule", { value: true });
ChainRec.tailRec = void 0;
/**
 * @since 2.0.0
 */
var tailRec = function (startWith, f) {
    var ab = f(startWith);
    while (ab._tag === 'Left') {
        ab = f(ab.left);
    }
    return ab.right;
};
ChainRec.tailRec = tailRec;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.asUnit = exports.as = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.flatMap = exports.right = exports.left = void 0;
	exports.chainFirstW = exports.chainFirst = exports.chain = exports.chainW = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toError = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.tap = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = void 0;
	exports.getValidation = exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.either = exports.stringifyJSON = exports.parseJSON = void 0;
	var Applicative_1 = Applicative;
	var Apply_1 = Apply;
	var chainable = __importStar(Chain);
	var ChainRec_1 = ChainRec;
	var FromEither_1 = FromEither;
	var function_1 = _function;
	var Functor_1 = Functor;
	var _ = __importStar(internal);
	var Separated_1 = Separated;
	var Witherable_1 = Witherable;
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
	 * structure.
	 *
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.left = _.left;
	/**
	 * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
	 * of this structure.
	 *
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.right = _.right;
	/**
	 * @category sequencing
	 * @since 2.14.0
	 */
	exports.flatMap = (0, function_1.dual)(2, function (ma, f) { return ((0, exports.isLeft)(ma) ? ma : f(ma.right)); });
	var _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };
	var _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };
	/* istanbul ignore next */
	var _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };
	/* istanbul ignore next */
	var _foldMap = function (M) { return function (fa, f) {
	    var foldMapM = (0, exports.foldMap)(M);
	    return (0, function_1.pipe)(fa, foldMapM(f));
	}; };
	/* istanbul ignore next */
	var _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };
	var _traverse = function (F) {
	    var traverseF = (0, exports.traverse)(F);
	    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };
	};
	var _bimap = function (fa, f, g) { return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g)); };
	var _mapLeft = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f)); };
	/* istanbul ignore next */
	var _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };
	/* istanbul ignore next */
	var _extend = function (wa, f) { return (0, function_1.pipe)(wa, (0, exports.extend)(f)); };
	var _chainRec = function (a, f) {
	    return (0, ChainRec_1.tailRec)(f(a), function (e) {
	        return (0, exports.isLeft)(e) ? (0, exports.right)((0, exports.left)(e.left)) : (0, exports.isLeft)(e.right) ? (0, exports.left)(f(e.right.left)) : (0, exports.right)((0, exports.right)(e.right.right));
	    });
	};
	/**
	 * @category type lambdas
	 * @since 2.0.0
	 */
	exports.URI = 'Either';
	/**
	 * @category instances
	 * @since 2.0.0
	 */
	var getShow = function (SE, SA) { return ({
	    show: function (ma) { return ((0, exports.isLeft)(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")")); }
	}); };
	exports.getShow = getShow;
	/**
	 * @category instances
	 * @since 2.0.0
	 */
	var getEq = function (EL, EA) { return ({
	    equals: function (x, y) {
	        return x === y || ((0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EL.equals(x.left, y.left) : (0, exports.isRight)(y) && EA.equals(x.right, y.right));
	    }
	}); };
	exports.getEq = getEq;
	/**
	 * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are
	 * concatenated using the provided `Semigroup`
	 *
	 * @example
	 * import { getSemigroup, left, right } from 'fp-ts/Either'
	 * import { SemigroupSum } from 'fp-ts/number'
	 *
	 * const S = getSemigroup<string, number>(SemigroupSum)
	 * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))
	 * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))
	 * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))
	 * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	var getSemigroup = function (S) { return ({
	    concat: function (x, y) { return ((0, exports.isLeft)(y) ? x : (0, exports.isLeft)(x) ? y : (0, exports.right)(S.concat(x.right, y.right))); }
	}); };
	exports.getSemigroup = getSemigroup;
	/**
	 * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.
	 *
	 * @category filtering
	 * @since 2.10.0
	 */
	var getCompactable = function (M) {
	    var empty = (0, exports.left)(M.empty);
	    return {
	        URI: exports.URI,
	        _E: undefined,
	        compact: function (ma) { return ((0, exports.isLeft)(ma) ? ma : ma.right._tag === 'None' ? empty : (0, exports.right)(ma.right.value)); },
	        separate: function (ma) {
	            return (0, exports.isLeft)(ma)
	                ? (0, Separated_1.separated)(ma, ma)
	                : (0, exports.isLeft)(ma.right)
	                    ? (0, Separated_1.separated)((0, exports.right)(ma.right.left), empty)
	                    : (0, Separated_1.separated)(empty, (0, exports.right)(ma.right.right));
	        }
	    };
	};
	exports.getCompactable = getCompactable;
	/**
	 * Builds a `Filterable` instance for `Either` given `Monoid` for the left side
	 *
	 * @category filtering
	 * @since 2.10.0
	 */
	var getFilterable = function (M) {
	    var empty = (0, exports.left)(M.empty);
	    var _a = (0, exports.getCompactable)(M), compact = _a.compact, separate = _a.separate;
	    var filter = function (ma, predicate) {
	        return (0, exports.isLeft)(ma) ? ma : predicate(ma.right) ? ma : empty;
	    };
	    var partition = function (ma, p) {
	        return (0, exports.isLeft)(ma)
	            ? (0, Separated_1.separated)(ma, ma)
	            : p(ma.right)
	                ? (0, Separated_1.separated)(empty, (0, exports.right)(ma.right))
	                : (0, Separated_1.separated)((0, exports.right)(ma.right), empty);
	    };
	    return {
	        URI: exports.URI,
	        _E: undefined,
	        map: _map,
	        compact: compact,
	        separate: separate,
	        filter: filter,
	        filterMap: function (ma, f) {
	            if ((0, exports.isLeft)(ma)) {
	                return ma;
	            }
	            var ob = f(ma.right);
	            return ob._tag === 'None' ? empty : (0, exports.right)(ob.value);
	        },
	        partition: partition,
	        partitionMap: function (ma, f) {
	            if ((0, exports.isLeft)(ma)) {
	                return (0, Separated_1.separated)(ma, ma);
	            }
	            var e = f(ma.right);
	            return (0, exports.isLeft)(e) ? (0, Separated_1.separated)((0, exports.right)(e.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(e.right));
	        }
	    };
	};
	exports.getFilterable = getFilterable;
	/**
	 * Builds `Witherable` instance for `Either` given `Monoid` for the left side
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	var getWitherable = function (M) {
	    var F_ = (0, exports.getFilterable)(M);
	    var C = (0, exports.getCompactable)(M);
	    return {
	        URI: exports.URI,
	        _E: undefined,
	        map: _map,
	        compact: F_.compact,
	        separate: F_.separate,
	        filter: F_.filter,
	        filterMap: F_.filterMap,
	        partition: F_.partition,
	        partitionMap: F_.partitionMap,
	        traverse: _traverse,
	        sequence: exports.sequence,
	        reduce: _reduce,
	        foldMap: _foldMap,
	        reduceRight: _reduceRight,
	        wither: (0, Witherable_1.witherDefault)(exports.Traversable, C),
	        wilt: (0, Witherable_1.wiltDefault)(exports.Traversable, C)
	    };
	};
	exports.getWitherable = getWitherable;
	/**
	 * The default [`Applicative`](#applicative) instance returns the first error, if you want to
	 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
	 *
	 * @example
	 * import * as A from 'fp-ts/Apply'
	 * import * as E from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 * import * as S from 'fp-ts/Semigroup'
	 * import * as string from 'fp-ts/string'
	 *
	 * const parseString = (u: unknown): E.Either<string, string> =>
	 *   typeof u === 'string' ? E.right(u) : E.left('not a string')
	 *
	 * const parseNumber = (u: unknown): E.Either<string, number> =>
	 *   typeof u === 'number' ? E.right(u) : E.left('not a number')
	 *
	 * interface Person {
	 *   readonly name: string
	 *   readonly age: number
	 * }
	 *
	 * const parsePerson = (
	 *   input: Record<string, unknown>
	 * ): E.Either<string, Person> =>
	 *   pipe(
	 *     E.Do,
	 *     E.apS('name', parseString(input.name)),
	 *     E.apS('age', parseNumber(input.age))
	 *   )
	 *
	 * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error
	 *
	 * const Applicative = E.getApplicativeValidation(
	 *   pipe(string.Semigroup, S.intercalate(', '))
	 * )
	 *
	 * const apS = A.apS(Applicative)
	 *
	 * const parsePersonAll = (
	 *   input: Record<string, unknown>
	 * ): E.Either<string, Person> =>
	 *   pipe(
	 *     E.Do,
	 *     apS('name', parseString(input.name)),
	 *     apS('age', parseNumber(input.age))
	 *   )
	 *
	 * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors
	 *
	 * @category error handling
	 * @since 2.7.0
	 */
	var getApplicativeValidation = function (SE) { return ({
	    URI: exports.URI,
	    _E: undefined,
	    map: _map,
	    ap: function (fab, fa) {
	        return (0, exports.isLeft)(fab)
	            ? (0, exports.isLeft)(fa)
	                ? (0, exports.left)(SE.concat(fab.left, fa.left))
	                : fab
	            : (0, exports.isLeft)(fa)
	                ? fa
	                : (0, exports.right)(fab.right(fa.right));
	    },
	    of: exports.of
	}); };
	exports.getApplicativeValidation = getApplicativeValidation;
	/**
	 * The default [`Alt`](#alt) instance returns the last error, if you want to
	 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
	 *
	 * @example
	 * import * as E from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 * import * as S from 'fp-ts/Semigroup'
	 * import * as string from 'fp-ts/string'
	 *
	 * const parseString = (u: unknown): E.Either<string, string> =>
	 *   typeof u === 'string' ? E.right(u) : E.left('not a string')
	 *
	 * const parseNumber = (u: unknown): E.Either<string, number> =>
	 *   typeof u === 'number' ? E.right(u) : E.left('not a number')
	 *
	 * const parse = (u: unknown): E.Either<string, string | number> =>
	 *   pipe(
	 *     parseString(u),
	 *     E.alt<string, string | number>(() => parseNumber(u))
	 *   )
	 *
	 * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error
	 *
	 * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))
	 *
	 * const parseAll = (u: unknown): E.Either<string, string | number> =>
	 *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))
	 *
	 * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors
	 *
	 * @category error handling
	 * @since 2.7.0
	 */
	var getAltValidation = function (SE) { return ({
	    URI: exports.URI,
	    _E: undefined,
	    map: _map,
	    alt: function (me, that) {
	        if ((0, exports.isRight)(me)) {
	            return me;
	        }
	        var ea = that();
	        return (0, exports.isLeft)(ea) ? (0, exports.left)(SE.concat(me.left, ea.left)) : ea;
	    }
	}); };
	exports.getAltValidation = getAltValidation;
	/**
	 * @category mapping
	 * @since 2.0.0
	 */
	var map = function (f) { return function (fa) {
	    return (0, exports.isLeft)(fa) ? fa : (0, exports.right)(f(fa.right));
	}; };
	exports.map = map;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Functor = {
	    URI: exports.URI,
	    map: _map
	};
	/**
	 * Maps the `Right` value of this `Either` to the specified constant value.
	 *
	 * @category mapping
	 * @since 2.16.0
	 */
	exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
	/**
	 * Maps the `Right` value of this `Either` to the void constant value.
	 *
	 * @category mapping
	 * @since 2.16.0
	 */
	exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
	/**
	 * @category constructors
	 * @since 2.7.0
	 */
	exports.of = exports.right;
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Pointed = {
	    URI: exports.URI,
	    of: exports.of
	};
	/**
	 * Less strict version of [`ap`](#ap).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @since 2.8.0
	 */
	var apW = function (fa) { return function (fab) {
	    return (0, exports.isLeft)(fab) ? fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
	}; };
	exports.apW = apW;
	/**
	 * @since 2.0.0
	 */
	exports.ap = exports.apW;
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Apply = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Applicative = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Chain = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Monad = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    chain: exports.flatMap
	};
	/**
	 * Left-associative fold of a structure.
	 *
	 * @example
	 * import { pipe } from 'fp-ts/function'
	 * import * as E from 'fp-ts/Either'
	 *
	 * const startWith = 'prefix'
	 * const concat = (a: string, b: string) => `${a}:${b}`
	 *
	 * assert.deepStrictEqual(
	 *   pipe(E.right('a'), E.reduce(startWith, concat)),
	 *   'prefix:a'
	 * )
	 *
	 * assert.deepStrictEqual(
	 *   pipe(E.left('e'), E.reduce(startWith, concat)),
	 *   'prefix'
	 * )
	 *
	 * @category folding
	 * @since 2.0.0
	 */
	var reduce = function (b, f) { return function (fa) {
	    return (0, exports.isLeft)(fa) ? b : f(b, fa.right);
	}; };
	exports.reduce = reduce;
	/**
	 * Map each element of the structure to a monoid, and combine the results.
	 *
	 * @example
	 * import { pipe } from 'fp-ts/function'
	 * import * as E from 'fp-ts/Either'
	 * import * as S from 'fp-ts/string'
	 *
	 * const yell = (a: string) => `${a}!`
	 *
	 * assert.deepStrictEqual(
	 *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),
	 *   'a!'
	 * )
	 *
	 * assert.deepStrictEqual(
	 *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),
	 *   S.Monoid.empty
	 * )
	 *
	 * @category folding
	 * @since 2.0.0
	 */
	var foldMap = function (M) { return function (f) { return function (fa) {
	    return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);
	}; }; };
	exports.foldMap = foldMap;
	/**
	 * Right-associative fold of a structure.
	 *
	 * @example
	 * import { pipe } from 'fp-ts/function'
	 * import * as E from 'fp-ts/Either'
	 *
	 * const startWith = 'postfix'
	 * const concat = (a: string, b: string) => `${a}:${b}`
	 *
	 * assert.deepStrictEqual(
	 *   pipe(E.right('a'), E.reduceRight(startWith, concat)),
	 *   'a:postfix'
	 * )
	 *
	 * assert.deepStrictEqual(
	 *   pipe(E.left('e'), E.reduceRight(startWith, concat)),
	 *   'postfix'
	 * )
	 *
	 * @category folding
	 * @since 2.0.0
	 */
	var reduceRight = function (b, f) { return function (fa) {
	    return (0, exports.isLeft)(fa) ? b : f(fa.right, b);
	}; };
	exports.reduceRight = reduceRight;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Foldable = {
	    URI: exports.URI,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight
	};
	/**
	 * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.
	 *
	 * @example
	 * import { pipe } from 'fp-ts/function'
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import * as E from 'fp-ts/Either'
	 * import * as O from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),
	 *   O.some(E.right('a'))
	 *  )
	 *
	 * assert.deepStrictEqual(
	 *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),
	 *   O.none
	 * )
	 *
	 * @category traversing
	 * @since 2.6.3
	 */
	var traverse = function (F) {
	    return function (f) {
	        return function (ta) {
	            return (0, exports.isLeft)(ta) ? F.of((0, exports.left)(ta.left)) : F.map(f(ta.right), exports.right);
	        };
	    };
	};
	exports.traverse = traverse;
	/**
	 * Evaluate each monadic action in the structure from left to right, and collect the results.
	 *
	 * @example
	 * import { pipe } from 'fp-ts/function'
	 * import * as E from 'fp-ts/Either'
	 * import * as O from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),
	 *   O.some(E.right('a'))
	 *  )
	 *
	 * assert.deepStrictEqual(
	 *   pipe(E.right(O.none), E.sequence(O.Applicative)),
	 *   O.none
	 * )
	 *
	 * @category traversing
	 * @since 2.6.3
	 */
	var sequence = function (F) {
	    return function (ma) {
	        return (0, exports.isLeft)(ma) ? F.of((0, exports.left)(ma.left)) : F.map(ma.right, exports.right);
	    };
	};
	exports.sequence = sequence;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Traversable = {
	    URI: exports.URI,
	    map: _map,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence
	};
	/**
	 * Map a pair of functions over the two type arguments of the bifunctor.
	 *
	 * @category mapping
	 * @since 2.0.0
	 */
	var bimap = function (f, g) { return function (fa) {
	    return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : (0, exports.right)(g(fa.right));
	}; };
	exports.bimap = bimap;
	/**
	 * Map a function over the first type argument of a bifunctor.
	 *
	 * @category error handling
	 * @since 2.0.0
	 */
	var mapLeft = function (f) { return function (fa) {
	    return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : fa;
	}; };
	exports.mapLeft = mapLeft;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Bifunctor = {
	    URI: exports.URI,
	    bimap: _bimap,
	    mapLeft: _mapLeft
	};
	/**
	 * Less strict version of [`alt`](#alt).
	 *
	 * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.
	 *
	 * @category error handling
	 * @since 2.9.0
	 */
	var altW = function (that) { return function (fa) {
	    return (0, exports.isLeft)(fa) ? that() : fa;
	}; };
	exports.altW = altW;
	/**
	 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
	 * types of kind `* -> *`.
	 *
	 * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).
	 *
	 * | x        | y        | pipe(x, alt(() => y) |
	 * | -------- | -------- | -------------------- |
	 * | left(a)  | left(b)  | left(b)              |
	 * | left(a)  | right(2) | right(2)             |
	 * | right(1) | left(b)  | right(1)             |
	 * | right(1) | right(2) | right(1)             |
	 *
	 * @example
	 * import * as E from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     E.left('a'),
	 *     E.alt(() => E.left('b'))
	 *   ),
	 *   E.left('b')
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     E.left('a'),
	 *     E.alt(() => E.right(2))
	 *   ),
	 *   E.right(2)
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     E.right(1),
	 *     E.alt(() => E.left('b'))
	 *   ),
	 *   E.right(1)
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     E.right(1),
	 *     E.alt(() => E.right(2))
	 *   ),
	 *   E.right(1)
	 * )
	 *
	 * @category error handling
	 * @since 2.0.0
	 */
	exports.alt = exports.altW;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Alt = {
	    URI: exports.URI,
	    map: _map,
	    alt: _alt
	};
	/**
	 * @since 2.0.0
	 */
	var extend = function (f) { return function (wa) {
	    return (0, exports.isLeft)(wa) ? wa : (0, exports.right)(f(wa));
	}; };
	exports.extend = extend;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Extend = {
	    URI: exports.URI,
	    map: _map,
	    extend: _extend
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.ChainRec = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    chain: exports.flatMap,
	    chainRec: _chainRec
	};
	/**
	 * @since 2.6.3
	 */
	exports.throwError = exports.left;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.MonadThrow = {
	    URI: exports.URI,
	    map: _map,
	    ap: _ap,
	    of: exports.of,
	    chain: exports.flatMap,
	    throwError: exports.throwError
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.FromEither = {
	    URI: exports.URI,
	    fromEither: function_1.identity
	};
	/**
	 * @example
	 * import { fromPredicate, left, right } from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     1,
	 *     fromPredicate(
	 *       (n) => n > 0,
	 *       () => 'error'
	 *     )
	 *   ),
	 *   right(1)
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     -1,
	 *     fromPredicate(
	 *       (n) => n > 0,
	 *       () => 'error'
	 *     )
	 *   ),
	 *   left('error')
	 * )
	 *
	 * @category lifting
	 * @since 2.0.0
	 */
	exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
	// -------------------------------------------------------------------------------------
	// conversions
	// -------------------------------------------------------------------------------------
	/**
	 * @example
	 * import * as E from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 * import * as O from 'fp-ts/Option'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     O.some(1),
	 *     E.fromOption(() => 'error')
	 *   ),
	 *   E.right(1)
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     O.none,
	 *     E.fromOption(() => 'error')
	 *   ),
	 *   E.left('error')
	 * )
	 *
	 * @category conversions
	 * @since 2.0.0
	 */
	exports.fromOption = 
	/*#__PURE__*/ (0, FromEither_1.fromOption)(exports.FromEither);
	// -------------------------------------------------------------------------------------
	// refinements
	// -------------------------------------------------------------------------------------
	/**
	 * Returns `true` if the either is an instance of `Left`, `false` otherwise.
	 *
	 * @category refinements
	 * @since 2.0.0
	 */
	exports.isLeft = _.isLeft;
	/**
	 * Returns `true` if the either is an instance of `Right`, `false` otherwise.
	 *
	 * @category refinements
	 * @since 2.0.0
	 */
	exports.isRight = _.isRight;
	/**
	 * Less strict version of [`match`](#match).
	 *
	 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	var matchW = function (onLeft, onRight) {
	    return function (ma) {
	        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : onRight(ma.right);
	    };
	};
	exports.matchW = matchW;
	/**
	 * Alias of [`matchW`](#matchw).
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.foldW = exports.matchW;
	/**
	 * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,
	 * if the value is a `Right` the inner value is applied to the second function.
	 *
	 * @example
	 * import { match, left, right } from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * function onLeft(errors: Array<string>): string {
	 *   return `Errors: ${errors.join(', ')}`
	 * }
	 *
	 * function onRight(value: number): string {
	 *   return `Ok: ${value}`
	 * }
	 *
	 * assert.strictEqual(
	 *   pipe(
	 *     right(1),
	 *     match(onLeft, onRight)
	 *   ),
	 *   'Ok: 1'
	 * )
	 * assert.strictEqual(
	 *   pipe(
	 *     left(['error 1', 'error 2']),
	 *     match(onLeft, onRight)
	 *   ),
	 *   'Errors: error 1, error 2'
	 * )
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.match = exports.matchW;
	/**
	 * Alias of [`match`](#match).
	 *
	 * @category pattern matching
	 * @since 2.0.0
	 */
	exports.fold = exports.match;
	/**
	 * Less strict version of [`getOrElse`](#getorelse).
	 *
	 * The `W` suffix (short for **W**idening) means that the handler return type will be merged.
	 *
	 * @category error handling
	 * @since 2.6.0
	 */
	var getOrElseW = function (onLeft) {
	    return function (ma) {
	        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma.right;
	    };
	};
	exports.getOrElseW = getOrElseW;
	/**
	 * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.
	 *
	 * @example
	 * import { getOrElse, left, right } from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     right(1),
	 *     getOrElse(() => 0)
	 *   ),
	 *   1
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     left('error'),
	 *     getOrElse(() => 0)
	 *   ),
	 *   0
	 * )
	 *
	 * @category error handling
	 * @since 2.0.0
	 */
	exports.getOrElse = exports.getOrElseW;
	// -------------------------------------------------------------------------------------
	// combinators
	// -------------------------------------------------------------------------------------
	/**
	 * @category mapping
	 * @since 2.10.0
	 */
	exports.flap = (0, Functor_1.flap)(exports.Functor);
	/**
	 * Combine two effectful actions, keeping only the result of the first.
	 *
	 * @since 2.0.0
	 */
	exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
	/**
	 * Less strict version of [`apFirst`](#apfirst)
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @since 2.12.0
	 */
	exports.apFirstW = exports.apFirst;
	/**
	 * Combine two effectful actions, keeping only the result of the second.
	 *
	 * @since 2.0.0
	 */
	exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
	/**
	 * Less strict version of [`apSecond`](#apsecond)
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @since 2.12.0
	 */
	exports.apSecondW = exports.apSecond;
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @category combinators
	 * @since 2.15.0
	 */
	exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
	/**
	 * Less strict version of [`flatten`](#flatten).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category sequencing
	 * @since 2.11.0
	 */
	exports.flattenW = 
	/*#__PURE__*/ (0, exports.flatMap)(function_1.identity);
	/**
	 * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.
	 *
	 * @example
	 * import * as E from 'fp-ts/Either'
	 *
	 * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))
	 * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))
	 * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))
	 *
	 * @category sequencing
	 * @since 2.0.0
	 */
	exports.flatten = exports.flattenW;
	/**
	 * @since 2.0.0
	 */
	exports.duplicate = (0, exports.extend)(function_1.identity);
	/**
	 * Use `liftOption`.
	 *
	 * @category legacy
	 * @since 2.10.0
	 */
	exports.fromOptionK = 
	/*#__PURE__*/ (0, FromEither_1.fromOptionK)(exports.FromEither);
	/**
	 * Use `flatMapOption`.
	 *
	 * @category legacy
	 * @since 2.11.0
	 */
	exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
	/**
	 * Use `flatMapOption`.
	 *
	 * @category legacy
	 * @since 2.13.2
	 */
	exports.chainOptionKW = exports.chainOptionK;
	/** @internal */
	var _FromEither = {
	    fromEither: exports.FromEither.fromEither
	};
	/**
	 * @category lifting
	 * @since 2.15.0
	 */
	exports.liftNullable = _.liftNullable(_FromEither);
	/**
	 * @category lifting
	 * @since 2.15.0
	 */
	exports.liftOption = _.liftOption(_FromEither);
	/** @internal */
	var _FlatMap = {
	    flatMap: exports.flatMap
	};
	/**
	 * @category sequencing
	 * @since 2.15.0
	 */
	exports.flatMapNullable = _.flatMapNullable(_FromEither, _FlatMap);
	/**
	 * @category sequencing
	 * @since 2.15.0
	 */
	exports.flatMapOption = _.flatMapOption(_FromEither, _FlatMap);
	/**
	 * @example
	 * import * as E from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 *
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     E.right(1),
	 *     E.filterOrElse(
	 *       (n) => n > 0,
	 *       () => 'error'
	 *     )
	 *   ),
	 *   E.right(1)
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     E.right(-1),
	 *     E.filterOrElse(
	 *       (n) => n > 0,
	 *       () => 'error'
	 *     )
	 *   ),
	 *   E.left('error')
	 * )
	 * assert.deepStrictEqual(
	 *   pipe(
	 *     E.left('a'),
	 *     E.filterOrElse(
	 *       (n) => n > 0,
	 *       () => 'error'
	 *     )
	 *   ),
	 *   E.left('a')
	 * )
	 *
	 * @category filtering
	 * @since 2.0.0
	 */
	exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
	/**
	 * Less strict version of [`filterOrElse`](#filterorelse).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category filtering
	 * @since 2.9.0
	 */
	exports.filterOrElseW = exports.filterOrElse;
	/**
	 * Returns a `Right` if is a `Left` (and vice versa).
	 *
	 * @since 2.0.0
	 */
	var swap = function (ma) { return ((0, exports.isLeft)(ma) ? (0, exports.right)(ma.left) : (0, exports.left)(ma.right)); };
	exports.swap = swap;
	/**
	 * Less strict version of [`orElse`](#orelse).
	 *
	 * The `W` suffix (short for **W**idening) means that the return types will be merged.
	 *
	 * @category error handling
	 * @since 2.10.0
	 */
	var orElseW = function (onLeft) {
	    return function (ma) {
	        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma;
	    };
	};
	exports.orElseW = orElseW;
	/**
	 * Useful for recovering from errors.
	 *
	 * @category error handling
	 * @since 2.0.0
	 */
	exports.orElse = exports.orElseW;
	/**
	 * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use
	 * the provided default as a `Left`.
	 *
	 * @example
	 * import { fromNullable, left, right } from 'fp-ts/Either'
	 *
	 * const parse = fromNullable('nully')
	 *
	 * assert.deepStrictEqual(parse(1), right(1))
	 * assert.deepStrictEqual(parse(null), left('nully'))
	 *
	 * @category conversions
	 * @since 2.0.0
	 */
	var fromNullable = function (e) {
	    return function (a) {
	        return a == null ? (0, exports.left)(e) : (0, exports.right)(a);
	    };
	};
	exports.fromNullable = fromNullable;
	/**
	 * Constructs a new `Either` from a function that might throw.
	 *
	 * See also [`tryCatchK`](#trycatchk).
	 *
	 * @example
	 * import * as E from 'fp-ts/Either'
	 *
	 * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {
	 *   if (as.length > 0) {
	 *     return as[0]
	 *   } else {
	 *     throw new Error('empty array')
	 *   }
	 * }
	 *
	 * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>
	 *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))
	 *
	 * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))
	 * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))
	 *
	 * @category interop
	 * @since 2.0.0
	 */
	var tryCatch = function (f, onThrow) {
	    try {
	        return (0, exports.right)(f());
	    }
	    catch (e) {
	        return (0, exports.left)(onThrow(e));
	    }
	};
	exports.tryCatch = tryCatch;
	/**
	 * Converts a function that may throw to one returning a `Either`.
	 *
	 * @category interop
	 * @since 2.10.0
	 */
	var tryCatchK = function (f, onThrow) {
	    return function () {
	        var a = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            a[_i] = arguments[_i];
	        }
	        return (0, exports.tryCatch)(function () { return f.apply(void 0, a); }, onThrow);
	    };
	};
	exports.tryCatchK = tryCatchK;
	/**
	 * Use `liftNullable`.
	 *
	 * @category legacy
	 * @since 2.9.0
	 */
	var fromNullableK = function (e) {
	    var from = (0, exports.fromNullable)(e);
	    return function (f) { return (0, function_1.flow)(f, from); };
	};
	exports.fromNullableK = fromNullableK;
	/**
	 * Use `flatMapNullable`.
	 *
	 * @category legacy
	 * @since 2.9.0
	 */
	var chainNullableK = function (e) {
	    var from = (0, exports.fromNullableK)(e);
	    return function (f) { return (0, exports.flatMap)(from(f)); };
	};
	exports.chainNullableK = chainNullableK;
	/**
	 * @category conversions
	 * @since 2.10.0
	 */
	exports.toUnion = (0, exports.foldW)(function_1.identity, function_1.identity);
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * Default value for the `onError` argument of `tryCatch`
	 *
	 * @since 2.0.0
	 */
	function toError(e) {
	    return e instanceof Error ? e : new Error(String(e));
	}
	exports.toError = toError;
	function elem(E) {
	    return function (a, ma) {
	        if (ma === undefined) {
	            var elemE_1 = elem(E);
	            return function (ma) { return elemE_1(a, ma); };
	        }
	        return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);
	    };
	}
	exports.elem = elem;
	/**
	 * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.
	 *
	 * @example
	 * import { exists, left, right } from 'fp-ts/Either'
	 *
	 * const gt2 = exists((n: number) => n > 2)
	 *
	 * assert.strictEqual(gt2(left('a')), false)
	 * assert.strictEqual(gt2(right(1)), false)
	 * assert.strictEqual(gt2(right(3)), true)
	 *
	 * @since 2.0.0
	 */
	var exists = function (predicate) {
	    return function (ma) {
	        return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
	    };
	};
	exports.exists = exists;
	// -------------------------------------------------------------------------------------
	// do notation
	// -------------------------------------------------------------------------------------
	/**
	 * @category do notation
	 * @since 2.9.0
	 */
	exports.Do = (0, exports.of)(_.emptyRecord);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
	var let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);
	exports.let = let_;
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bind = chainable.bind(exports.Chain);
	/**
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bindW = exports.bind;
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.apS = (0, Apply_1.apS)(exports.Apply);
	/**
	 * Less strict version of [`apS`](#aps).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.apSW = exports.apS;
	/**
	 * @since 2.11.0
	 */
	exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
	// -------------------------------------------------------------------------------------
	// array utils
	// -------------------------------------------------------------------------------------
	/**
	 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyNonEmptyArrayWithIndex = function (f) {
	    return function (as) {
	        var e = f(0, _.head(as));
	        if ((0, exports.isLeft)(e)) {
	            return e;
	        }
	        var out = [e.right];
	        for (var i = 1; i < as.length; i++) {
	            var e_1 = f(i, as[i]);
	            if ((0, exports.isLeft)(e_1)) {
	                return e_1;
	            }
	            out.push(e_1.right);
	        }
	        return (0, exports.right)(out);
	    };
	};
	exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyArrayWithIndex = function (f) {
	    var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
	    return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };
	};
	exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverse(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	var traverseArray = function (f) { return (0, exports.traverseReadonlyArrayWithIndex)(function (_, a) { return f(a); }); };
	exports.traverseArray = traverseArray;
	/**
	 * Equivalent to `ReadonlyArray#sequence(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.sequenceArray = 
	/*#__PURE__*/ (0, exports.traverseArray)(function_1.identity);
	// -------------------------------------------------------------------------------------
	// legacy
	// -------------------------------------------------------------------------------------
	/**
	 * Alias of `flatMap`.
	 *
	 * @category legacy
	 * @since 2.6.0
	 */
	exports.chainW = exports.flatMap;
	/**
	 * Alias of `flatMap`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.chain = exports.flatMap;
	/**
	 * Alias of `tap`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.chainFirst = exports.tap;
	/**
	 * Alias of `tap`.
	 *
	 * @category legacy
	 * @since 2.8.0
	 */
	exports.chainFirstW = exports.tap;
	/**
	 * Use [`parse`](./Json.ts.html#parse) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	function parseJSON(s, onError) {
	    return (0, exports.tryCatch)(function () { return JSON.parse(s); }, onError);
	}
	exports.parseJSON = parseJSON;
	/**
	 * Use [`stringify`](./Json.ts.html#stringify) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	var stringifyJSON = function (u, onError) {
	    return (0, exports.tryCatch)(function () {
	        var s = JSON.stringify(u);
	        if (typeof s !== 'string') {
	            throw new Error('Converting unsupported structure to JSON');
	        }
	        return s;
	    }, onError);
	};
	exports.stringifyJSON = stringifyJSON;
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`
	 * (where `E` is from `import E from 'fp-ts/Either'`)
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.either = {
	    URI: exports.URI,
	    map: _map,
	    of: exports.of,
	    ap: _ap,
	    chain: exports.flatMap,
	    reduce: _reduce,
	    foldMap: _foldMap,
	    reduceRight: _reduceRight,
	    traverse: _traverse,
	    sequence: exports.sequence,
	    bimap: _bimap,
	    mapLeft: _mapLeft,
	    alt: _alt,
	    extend: _extend,
	    chainRec: _chainRec,
	    throwError: exports.throwError
	};
	/**
	 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
	 *
	 * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values
	 * are concatenated using the provided `Semigroup`
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getApplySemigroup = 
	/*#__PURE__*/ (0, Apply_1.getApplySemigroup)(exports.Apply);
	/**
	 * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getApplyMonoid = 
	/*#__PURE__*/ (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
	/**
	 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	var getValidationSemigroup = function (SE, SA) {
	    return (0, Apply_1.getApplySemigroup)((0, exports.getApplicativeValidation)(SE))(SA);
	};
	exports.getValidationSemigroup = getValidationSemigroup;
	/**
	 * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	var getValidationMonoid = function (SE, MA) {
	    return (0, Applicative_1.getApplicativeMonoid)((0, exports.getApplicativeValidation)(SE))(MA);
	};
	exports.getValidationMonoid = getValidationMonoid;
	/**
	 * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	function getValidation(SE) {
	    var ap = (0, exports.getApplicativeValidation)(SE).ap;
	    var alt = (0, exports.getAltValidation)(SE).alt;
	    return {
	        URI: exports.URI,
	        _E: undefined,
	        map: _map,
	        of: exports.of,
	        chain: exports.flatMap,
	        bimap: _bimap,
	        mapLeft: _mapLeft,
	        reduce: _reduce,
	        foldMap: _foldMap,
	        reduceRight: _reduceRight,
	        extend: _extend,
	        traverse: _traverse,
	        sequence: exports.sequence,
	        chainRec: _chainRec,
	        throwError: exports.throwError,
	        ap: ap,
	        alt: alt
	    };
	}
	exports.getValidation = getValidation; 
} (Either));

var EitherT = {};

var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(EitherT, "__esModule", { value: true });
EitherT.getEitherM = EitherT.toUnion = EitherT.swap = EitherT.orLeft = EitherT.tapError = EitherT.orElseFirst = EitherT.orElse = EitherT.getOrElse = EitherT.matchE = EitherT.match = EitherT.altValidation = EitherT.mapError = EitherT.mapLeft = EitherT.mapBoth = EitherT.bimap = EitherT.alt = EitherT.flatMap = EitherT.chain = EitherT.ap = EitherT.map = EitherT.chainNullableK = EitherT.fromNullableK = EitherT.fromNullable = EitherT.leftF = EitherT.rightF = EitherT.left = EitherT.right = void 0;
var Apply_1 = Apply;
var E = __importStar(Either);
var function_1$3 = _function;
var Functor_1$1 = Functor;
function right(F) {
    return (0, function_1$3.flow)(E.right, F.of);
}
EitherT.right = right;
function left(F) {
    return (0, function_1$3.flow)(E.left, F.of);
}
EitherT.left = left;
function rightF(F) {
    return function (fa) { return F.map(fa, E.right); };
}
EitherT.rightF = rightF;
function leftF(F) {
    return function (fe) { return F.map(fe, E.left); };
}
EitherT.leftF = leftF;
function fromNullable(F) {
    return function (e) { return (0, function_1$3.flow)(E.fromNullable(e), F.of); };
}
EitherT.fromNullable = fromNullable;
function fromNullableK(F) {
    var fromNullableF = fromNullable(F);
    return function (e) {
        var fromNullableFE = fromNullableF(e);
        return function (f) { return (0, function_1$3.flow)(f, fromNullableFE); };
    };
}
EitherT.fromNullableK = fromNullableK;
function chainNullableK(M) {
    var chainM = chain(M);
    var fromNullableKM = fromNullableK(M);
    return function (e) {
        var fromNullableKMe = fromNullableKM(e);
        return function (f) { return chainM(fromNullableKMe(f)); };
    };
}
EitherT.chainNullableK = chainNullableK;
function map(F) {
    return (0, Functor_1$1.map)(F, E.Functor);
}
EitherT.map = map;
function ap(F) {
    return (0, Apply_1.ap)(F, E.Apply);
}
EitherT.ap = ap;
function chain(M) {
    var flatMapM = flatMap(M);
    return function (f) { return function (ma) { return flatMapM(ma, f); }; };
}
EitherT.chain = chain;
/** @internal */
function flatMap(M) {
    return function (ma, f) { return M.chain(ma, function (e) { return (E.isLeft(e) ? M.of(e) : f(e.right)); }); };
}
EitherT.flatMap = flatMap;
function alt(M) {
    return function (second) { return function (first) { return M.chain(first, function (e) { return (E.isLeft(e) ? second() : M.of(e)); }); }; };
}
EitherT.alt = alt;
function bimap(F) {
    var mapBothF = mapBoth(F);
    return function (f, g) { return function (self) { return mapBothF(self, f, g); }; };
}
EitherT.bimap = bimap;
/** @internal */
function mapBoth(F) {
    return function (self, f, g) { return F.map(self, E.bimap(f, g)); };
}
EitherT.mapBoth = mapBoth;
function mapLeft(F) {
    var mapErrorF = mapError(F);
    return function (f) { return function (self) { return mapErrorF(self, f); }; };
}
EitherT.mapLeft = mapLeft;
/** @internal */
function mapError(F) {
    return function (self, f) { return F.map(self, E.mapLeft(f)); };
}
EitherT.mapError = mapError;
function altValidation(M, S) {
    return function (second) { return function (first) {
        return M.chain(first, E.match(function (e1) {
            return M.map(second(), E.mapLeft(function (e2) { return S.concat(e1, e2); }));
        }, right(M)));
    }; };
}
EitherT.altValidation = altValidation;
function match(F) {
    return function (onLeft, onRight) { return function (ma) { return F.map(ma, E.match(onLeft, onRight)); }; };
}
EitherT.match = match;
function matchE(M) {
    return function (onLeft, onRight) { return function (ma) { return M.chain(ma, E.match(onLeft, onRight)); }; };
}
EitherT.matchE = matchE;
function getOrElse(M) {
    return function (onLeft) { return function (ma) { return M.chain(ma, E.match(onLeft, M.of)); }; };
}
EitherT.getOrElse = getOrElse;
function orElse(M) {
    return function (onLeft) { return function (ma) { return M.chain(ma, function (e) { return (E.isLeft(e) ? onLeft(e.left) : M.of(e)); }); }; };
}
EitherT.orElse = orElse;
function orElseFirst(M) {
    var tapErrorM = tapError(M);
    return function (onLeft) { return function (ma) { return tapErrorM(ma, onLeft); }; };
}
EitherT.orElseFirst = orElseFirst;
/** @internal */
function tapError(M) {
    var orElseM = orElse(M);
    return function (ma, onLeft) {
        return (0, function_1$3.pipe)(ma, orElseM(function (e) { return M.map(onLeft(e), function (eb) { return (E.isLeft(eb) ? eb : E.left(e)); }); }));
    };
}
EitherT.tapError = tapError;
function orLeft(M) {
    return function (onLeft) { return function (ma) {
        return M.chain(ma, E.match(function (e) { return M.map(onLeft(e), E.left); }, function (a) { return M.of(E.right(a)); }));
    }; };
}
EitherT.orLeft = orLeft;
function swap(F) {
    return function (ma) { return F.map(ma, E.swap); };
}
EitherT.swap = swap;
function toUnion(F) {
    return function (fa) { return F.map(fa, E.toUnion); };
}
EitherT.toUnion = toUnion;
/** @deprecated  */
/* istanbul ignore next */
function getEitherM(M) {
    var _ap = ap(M);
    var _map = map(M);
    var _chain = chain(M);
    var _alt = alt(M);
    var _bimap = bimap(M);
    var _mapLeft = mapLeft(M);
    var _fold = matchE(M);
    var _getOrElse = getOrElse(M);
    var _orElse = orElse(M);
    return {
        map: function (fa, f) { return (0, function_1$3.pipe)(fa, _map(f)); },
        ap: function (fab, fa) { return (0, function_1$3.pipe)(fab, _ap(fa)); },
        of: right(M),
        chain: function (ma, f) { return (0, function_1$3.pipe)(ma, _chain(f)); },
        alt: function (fa, that) { return (0, function_1$3.pipe)(fa, _alt(that)); },
        bimap: function (fea, f, g) { return (0, function_1$3.pipe)(fea, _bimap(f, g)); },
        mapLeft: function (fea, f) { return (0, function_1$3.pipe)(fea, _mapLeft(f)); },
        fold: function (fa, onLeft, onRight) { return (0, function_1$3.pipe)(fa, _fold(onLeft, onRight)); },
        getOrElse: function (fa, onLeft) { return (0, function_1$3.pipe)(fa, _getOrElse(onLeft)); },
        orElse: function (fa, f) { return (0, function_1$3.pipe)(fa, _orElse(f)); },
        swap: swap(M),
        rightM: rightF(M),
        leftM: leftF(M),
        left: left(M)
    };
}
EitherT.getEitherM = getEitherM;

var Filterable = {};

Object.defineProperty(Filterable, "__esModule", { value: true });
Filterable.getFilterableComposition = Filterable.partitionMap = Filterable.partition = Filterable.filterMap = Filterable.filter = void 0;
/**
 * `Filterable` represents data structures which can be _partitioned_/_filtered_.
 *
 * Adapted from https://github.com/LiamGoodacre/purescript-filterable/blob/master/src/Data/Filterable.purs
 *
 * @since 2.0.0
 */
var Compactable_1 = Compactable;
var function_1$2 = _function;
var Functor_1 = Functor;
var Option_1 = Option;
var Predicate_1 = Predicate;
var Separated_1 = Separated;
function filter(F, G) {
    return function (predicate) { return function (fga) { return F.map(fga, function (ga) { return G.filter(ga, predicate); }); }; };
}
Filterable.filter = filter;
function filterMap(F, G) {
    return function (f) { return function (fga) { return F.map(fga, function (ga) { return G.filterMap(ga, f); }); }; };
}
Filterable.filterMap = filterMap;
function partition(F, G) {
    var _filter = filter(F, G);
    return function (predicate) {
        var left = _filter((0, Predicate_1.not)(predicate));
        var right = _filter(predicate);
        return function (fgb) { return (0, Separated_1.separated)(left(fgb), right(fgb)); };
    };
}
Filterable.partition = partition;
function partitionMap(F, G) {
    var _filterMap = filterMap(F, G);
    return function (f) { return function (fga) {
        return (0, Separated_1.separated)((0, function_1$2.pipe)(fga, _filterMap(function (a) { return (0, Option_1.getLeft)(f(a)); })), (0, function_1$2.pipe)(fga, _filterMap(function (a) { return (0, Option_1.getRight)(f(a)); })));
    }; };
}
Filterable.partitionMap = partitionMap;
/** @deprecated */
function getFilterableComposition(F, G) {
    var map = (0, Functor_1.getFunctorComposition)(F, G).map;
    var _compact = (0, Compactable_1.compact)(F, G);
    var _separate = (0, Compactable_1.separate)(F, G, G);
    var _filter = filter(F, G);
    var _filterMap = filterMap(F, G);
    var _partition = partition(F, G);
    var _partitionMap = partitionMap(F, G);
    return {
        map: map,
        compact: _compact,
        separate: _separate,
        filter: function (fga, f) { return (0, function_1$2.pipe)(fga, _filter(f)); },
        filterMap: function (fga, f) { return (0, function_1$2.pipe)(fga, _filterMap(f)); },
        partition: function (fga, p) { return (0, function_1$2.pipe)(fga, _partition(p)); },
        partitionMap: function (fga, f) { return (0, function_1$2.pipe)(fga, _partitionMap(f)); }
    };
}
Filterable.getFilterableComposition = getFilterableComposition;

var FromIO = {};

Object.defineProperty(FromIO, "__esModule", { value: true });
FromIO.tapIO = FromIO.chainFirstIOK = FromIO.chainIOK = FromIO.fromIOK = void 0;
/**
 * Lift a computation from the `IO` monad
 *
 * @since 2.10.0
 */
var Chain_1$1 = Chain;
var function_1$1 = _function;
function fromIOK(F) {
    return function (f) { return (0, function_1$1.flow)(f, F.fromIO); };
}
FromIO.fromIOK = fromIOK;
function chainIOK(F, M) {
    return function (f) {
        var g = (0, function_1$1.flow)(f, F.fromIO);
        return function (first) { return M.chain(first, g); };
    };
}
FromIO.chainIOK = chainIOK;
function chainFirstIOK(F, M) {
    var tapIOM = tapIO(F, M);
    return function (f) { return function (first) { return tapIOM(first, f); }; };
}
FromIO.chainFirstIOK = chainFirstIOK;
/** @internal */
function tapIO(F, M) {
    var chainFirstM = (0, Chain_1$1.tap)(M);
    return function (self, f) { return chainFirstM(self, (0, function_1$1.flow)(f, F.fromIO)); };
}
FromIO.tapIO = tapIO;

var FromTask = {};

Object.defineProperty(FromTask, "__esModule", { value: true });
FromTask.tapTask = FromTask.chainFirstTaskK = FromTask.chainTaskK = FromTask.fromTaskK = void 0;
/**
 * Lift a computation from the `Task` monad
 *
 * @since 2.10.0
 */
var Chain_1 = Chain;
var function_1 = _function;
function fromTaskK(F) {
    return function (f) { return (0, function_1.flow)(f, F.fromTask); };
}
FromTask.fromTaskK = fromTaskK;
function chainTaskK(F, M) {
    return function (f) {
        var g = (0, function_1.flow)(f, F.fromTask);
        return function (first) { return M.chain(first, g); };
    };
}
FromTask.chainTaskK = chainTaskK;
function chainFirstTaskK(F, M) {
    var tapTaskM = tapTask(F, M);
    return function (f) { return function (first) { return tapTaskM(first, f); }; };
}
FromTask.chainFirstTaskK = chainFirstTaskK;
/** @internal */
function tapTask(F, M) {
    var tapM = (0, Chain_1.tap)(M);
    return function (self, f) { return tapM(self, (0, function_1.flow)(f, F.fromTask)); };
}
FromTask.tapTask = tapTask;

var Task = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.never = exports.FromTask = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.tapIO = exports.tap = exports.flatMapIO = exports.FromIO = exports.MonadTask = exports.fromTask = exports.MonadIO = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecond = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.getRaceMonoid = exports.URI = exports.flatten = exports.flatMap = exports.of = exports.ap = exports.map = exports.delay = exports.fromIO = void 0;
	exports.getMonoid = exports.getSemigroup = exports.taskSeq = exports.task = exports.chainFirst = exports.chain = void 0;
	/**
	 * ```ts
	 * interface Task<A> {
	 *   (): Promise<A>
	 * }
	 * ```
	 *
	 * `Task<A>` represents an asynchronous computation that yields a value of type `A` and **never fails**.
	 * If you want to represent an asynchronous computation that may fail, please see `TaskEither`.
	 *
	 * @since 2.0.0
	 */
	var Applicative_1 = Applicative;
	var Apply_1 = Apply;
	var chainable = __importStar(Chain);
	var FromIO_1 = FromIO;
	var function_1 = _function;
	var Functor_1 = Functor;
	var _ = __importStar(internal);
	// -------------------------------------------------------------------------------------
	// conversions
	// -------------------------------------------------------------------------------------
	/**
	 * @category conversions
	 * @since 2.0.0
	 */
	var fromIO = function (ma) { return function () { return Promise.resolve().then(ma); }; };
	exports.fromIO = fromIO;
	// -------------------------------------------------------------------------------------
	// combinators
	// -------------------------------------------------------------------------------------
	/**
	 * Creates a task that will complete after a time delay
	 *
	 * @example
	 * import { sequenceT } from 'fp-ts/Apply'
	 * import * as T from 'fp-ts/Task'
	 * import { takeRight } from 'fp-ts/Array'
	 *
	 * async function test() {
	 *   const log: Array<string> = []
	 *   const append = (message: string): T.Task<void> =>
	 *     T.fromIO(() => {
	 *       log.push(message)
	 *     })
	 *   const fa = append('a')
	 *   const fb = T.delay(20)(append('b'))
	 *   const fc = T.delay(10)(append('c'))
	 *   const fd = append('d')
	 *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()
	 *   assert.deepStrictEqual(takeRight(2)(log), ['c', 'b'])
	 * }
	 *
	 * test()
	 *
	 * @since 2.0.0
	 */
	function delay(millis) {
	    return function (ma) { return function () {
	        return new Promise(function (resolve) {
	            setTimeout(function () {
	                Promise.resolve().then(ma).then(resolve);
	            }, millis);
	        });
	    }; };
	}
	exports.delay = delay;
	var _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };
	var _apPar = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };
	var _apSeq = function (fab, fa) { return (0, exports.flatMap)(fab, function (f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); }); };
	/**
	 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
	 * use the type constructor `F` to represent some computational context.
	 *
	 * @category mapping
	 * @since 2.0.0
	 */
	var map = function (f) { return function (fa) { return function () {
	    return Promise.resolve().then(fa).then(f);
	}; }; };
	exports.map = map;
	/**
	 * @since 2.0.0
	 */
	var ap = function (fa) { return function (fab) { return function () {
	    return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function (_a) {
	        var f = _a[0], a = _a[1];
	        return f(a);
	    });
	}; }; };
	exports.ap = ap;
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	var of = function (a) { return function () { return Promise.resolve(a); }; };
	exports.of = of;
	/**
	 * @category sequencing
	 * @since 2.14.0
	 */
	exports.flatMap = (0, function_1.dual)(2, function (ma, f) {
	    return function () {
	        return Promise.resolve()
	            .then(ma)
	            .then(function (a) { return f(a)(); });
	    };
	});
	/**
	 * @category sequencing
	 * @since 2.0.0
	 */
	exports.flatten = (0, exports.flatMap)(function_1.identity);
	/**
	 * @category type lambdas
	 * @since 2.0.0
	 */
	exports.URI = 'Task';
	/**
	 * Monoid returning the first completed task.
	 *
	 * Note: uses `Promise.race` internally.
	 *
	 * @example
	 * import * as T from 'fp-ts/Task'
	 *
	 * async function test() {
	 *   const S = T.getRaceMonoid<string>()
	 *   const fa = T.delay(20)(T.of('a'))
	 *   const fb = T.delay(10)(T.of('b'))
	 *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')
	 * }
	 *
	 * test()
	 *
	 * @category instances
	 * @since 2.0.0
	 */
	function getRaceMonoid() {
	    return {
	        concat: function (x, y) { return function () { return Promise.race([Promise.resolve().then(x), Promise.resolve().then(y)]); }; },
	        empty: exports.never
	    };
	}
	exports.getRaceMonoid = getRaceMonoid;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Functor = {
	    URI: exports.URI,
	    map: _map
	};
	/**
	 * Maps the value to the specified constant value.
	 *
	 * @category mapping
	 * @since 2.16.0
	 */
	exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
	/**
	 * Maps the value to the void constant value.
	 *
	 * @category mapping
	 * @since 2.16.0
	 */
	exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
	/**
	 * @category mapping
	 * @since 2.10.0
	 */
	exports.flap = (0, Functor_1.flap)(exports.Functor);
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Pointed = {
	    URI: exports.URI,
	    of: exports.of
	};
	/**
	 * Runs computations in parallel.
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	exports.ApplyPar = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apPar
	};
	/**
	 * Combine two effectful actions, keeping only the result of the first.
	 *
	 * @since 2.0.0
	 */
	exports.apFirst = (0, Apply_1.apFirst)(exports.ApplyPar);
	/**
	 * Combine two effectful actions, keeping only the result of the second.
	 *
	 * @since 2.0.0
	 */
	exports.apSecond = (0, Apply_1.apSecond)(exports.ApplyPar);
	/**
	 * Runs computations in parallel.
	 *
	 * @category instances
	 * @since 2.7.0
	 */
	exports.ApplicativePar = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apPar,
	    of: exports.of
	};
	/**
	 * Runs computations sequentially.
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	exports.ApplySeq = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apSeq
	};
	/**
	 * Runs computations sequentially.
	 *
	 * @category instances
	 * @since 2.7.0
	 */
	exports.ApplicativeSeq = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apSeq,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Chain = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apPar,
	    chain: exports.flatMap
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Monad = {
	    URI: exports.URI,
	    map: _map,
	    of: exports.of,
	    ap: _apPar,
	    chain: exports.flatMap
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.MonadIO = {
	    URI: exports.URI,
	    map: _map,
	    of: exports.of,
	    ap: _apPar,
	    chain: exports.flatMap,
	    fromIO: exports.fromIO
	};
	/**
	 * @category zone of death
	 * @since 2.7.0
	 * @deprecated
	 */
	exports.fromTask = function_1.identity;
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.MonadTask = {
	    URI: exports.URI,
	    map: _map,
	    of: exports.of,
	    ap: _apPar,
	    chain: exports.flatMap,
	    fromIO: exports.fromIO,
	    fromTask: exports.fromTask
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.FromIO = {
	    URI: exports.URI,
	    fromIO: exports.fromIO
	};
	/** @internal */
	var _FlatMap = {
	    flatMap: exports.flatMap
	};
	/** @internal */
	var _FromIO = {
	    fromIO: exports.FromIO.fromIO
	};
	/**
	 * @category sequencing
	 * @since 2.16.0
	 */
	exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @category combinators
	 * @since 2.15.0
	 */
	exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @example
	 * import { pipe } from 'fp-ts/function'
	 * import * as T from 'fp-ts/Task'
	 * import * as Console from 'fp-ts/Console'
	 *
	 * // Will produce `Hello, fp-ts` to the stdout
	 * const effect = pipe(
	 *   T.of('fp-ts'),
	 *   T.tapIO((value) => Console.log(`Hello, ${value}`)),
	 * )
	 *
	 * async function test() {
	 *   assert.deepStrictEqual(await effect(), 'fp-ts')
	 * }
	 *
	 * test()
	 *
	 * @category combinators
	 * @since 2.16.0
	 */
	exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
	/**
	 * @category lifting
	 * @since 2.4.0
	 */
	exports.fromIOK = 
	/*#__PURE__*/ (0, FromIO_1.fromIOK)(exports.FromIO);
	/**
	 * Alias of `flatMapIO`.
	 *
	 * @category legacy
	 * @since 2.4.0
	 */
	exports.chainIOK = exports.flatMapIO;
	/**
	 * Alias of `tapIO`.
	 *
	 * @category legacy
	 * @since 2.10.0
	 */
	exports.chainFirstIOK = exports.tapIO;
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.FromTask = {
	    URI: exports.URI,
	    fromIO: exports.fromIO,
	    fromTask: exports.fromTask
	};
	// -------------------------------------------------------------------------------------
	// utils
	// -------------------------------------------------------------------------------------
	/**
	 * A `Task` that never completes.
	 *
	 * @since 2.0.0
	 */
	var never = function () { return new Promise(function (_) { return undefined; }); };
	exports.never = never;
	// -------------------------------------------------------------------------------------
	// do notation
	// -------------------------------------------------------------------------------------
	/**
	 * @category do notation
	 * @since 2.9.0
	 */
	exports.Do = (0, exports.of)(_.emptyRecord);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
	var let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);
	exports.let = let_;
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bind = chainable.bind(exports.Chain);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.apS = (0, Apply_1.apS)(exports.ApplyPar);
	/**
	 * @since 2.11.0
	 */
	exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
	// -------------------------------------------------------------------------------------
	// array utils
	// -------------------------------------------------------------------------------------
	/**
	 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyNonEmptyArrayWithIndex = function (f) {
	    return function (as) {
	        return function () {
	            return Promise.all(as.map(function (a, i) { return Promise.resolve().then(function () { return f(i, a)(); }); }));
	        };
	    };
	};
	exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyArrayWithIndex = function (f) {
	    var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
	    return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };
	};
	exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {
	    return function (as) {
	        return function () {
	            return _.tail(as).reduce(function (acc, a, i) {
	                return acc.then(function (bs) {
	                    return Promise.resolve()
	                        .then(f(i + 1, a))
	                        .then(function (b) {
	                        bs.push(b);
	                        return bs;
	                    });
	                });
	            }, Promise.resolve()
	                .then(f(0, _.head(as)))
	                .then(_.singleton));
	        };
	    };
	};
	exports.traverseReadonlyNonEmptyArrayWithIndexSeq = traverseReadonlyNonEmptyArrayWithIndexSeq;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyArrayWithIndexSeq = function (f) {
	    var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndexSeq)(f);
	    return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };
	};
	exports.traverseReadonlyArrayWithIndexSeq = traverseReadonlyArrayWithIndexSeq;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverse(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	var traverseArray = function (f) {
	    return (0, exports.traverseReadonlyArrayWithIndex)(function (_, a) { return f(a); });
	};
	exports.traverseArray = traverseArray;
	/**
	 * Equivalent to `ReadonlyArray#sequence(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.sequenceArray = 
	/*#__PURE__*/ (0, exports.traverseArray)(function_1.identity);
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.traverseSeqArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq;
	/**
	 * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	var traverseSeqArray = function (f) {
	    return (0, exports.traverseReadonlyArrayWithIndexSeq)(function (_, a) { return f(a); });
	};
	exports.traverseSeqArray = traverseSeqArray;
	/**
	 * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.sequenceSeqArray = 
	/*#__PURE__*/ (0, exports.traverseSeqArray)(function_1.identity);
	// -------------------------------------------------------------------------------------
	// legacy
	// -------------------------------------------------------------------------------------
	/**
	 * Alias of `flatMap`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.chain = exports.flatMap;
	/**
	 * Alias of `tap`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.chainFirst = exports.tap;
	// -------------------------------------------------------------------------------------
	// deprecated
	// -------------------------------------------------------------------------------------
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.task`
	 * (where `T` is from `import T from 'fp-ts/Task'`)
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.task = {
	    URI: exports.URI,
	    map: _map,
	    of: exports.of,
	    ap: _apPar,
	    chain: exports.flatMap,
	    fromIO: exports.fromIO,
	    fromTask: exports.fromTask
	};
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.taskSeq`
	 * (where `T` is from `import T from 'fp-ts/Task'`)
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.taskSeq = {
	    URI: exports.URI,
	    map: _map,
	    of: exports.of,
	    ap: _apSeq,
	    chain: exports.flatMap,
	    fromIO: exports.fromIO,
	    fromTask: exports.fromTask
	};
	/**
	 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getSemigroup = (0, Apply_1.getApplySemigroup)(exports.ApplySeq);
	/**
	 * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
	 *
	 * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.ApplicativeSeq); 
} (Task));

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.throwError = exports.of = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.flatMap = exports.apW = exports.ap = exports.mapLeft = exports.mapError = exports.bimap = exports.mapBoth = exports.map = exports.fromIOEitherK = exports.chainTaskOptionK = exports.chainTaskOptionKW = exports.fromTaskOptionK = exports.swap = exports.orLeft = exports.orElseFirstTaskK = exports.orElseFirstIOK = exports.tapError = exports.orElseW = exports.orElse = exports.chainNullableK = exports.fromNullableK = exports.fromNullable = exports.toUnion = exports.tryCatchK = exports.tryCatch = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromTaskOption = exports.fromIOEither = exports.fromEither = exports.fromTask = exports.fromIO = exports.leftIO = exports.rightIO = exports.leftTask = exports.rightTask = exports.right = exports.left = void 0;
	exports.fromPredicate = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.flatMapTaskOption = exports.flatMapIOEither = exports.flatMapTask = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.Alt = exports.Bifunctor = exports.tapTask = exports.tapIO = exports.tapEither = exports.tap = exports.FromTask = exports.FromIO = exports.FromEither = exports.MonadThrow = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.getFilterable = exports.getCompactable = exports.getAltTaskValidation = exports.getApplicativeTaskValidation = exports.URI = void 0;
	exports.getTaskValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.taskEitherSeq = exports.taskEither = exports.orElseFirstW = exports.orElseFirst = exports.chainFirstW = exports.chainFirst = exports.chainW = exports.chain = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.bracketW = exports.bracket = exports.taskify = exports.chainIOEitherK = exports.chainIOEitherKW = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = void 0;
	var Applicative_1 = Applicative;
	var Apply_1 = Apply;
	var chainable = __importStar(Chain);
	var Compactable_1 = Compactable;
	var E = __importStar(Either);
	var ET = __importStar(EitherT);
	var Filterable_1 = Filterable;
	var FromEither_1 = FromEither;
	var FromIO_1 = FromIO;
	var FromTask_1 = FromTask;
	var function_1 = _function;
	var Functor_1 = Functor;
	var _ = __importStar(internal);
	var T = __importStar(Task);
	// -------------------------------------------------------------------------------------
	// constructors
	// -------------------------------------------------------------------------------------
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.left = ET.left(T.Pointed);
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.right = ET.right(T.Pointed);
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.rightTask = ET.rightF(T.Functor);
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.leftTask = ET.leftF(T.Functor);
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.rightIO = (0, function_1.flow)(T.fromIO, exports.rightTask);
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.leftIO = (0, function_1.flow)(T.fromIO, exports.leftTask);
	// -------------------------------------------------------------------------------------
	// conversions
	// -------------------------------------------------------------------------------------
	/**
	 * @category conversions
	 * @since 2.7.0
	 */
	exports.fromIO = exports.rightIO;
	/**
	 * @category conversions
	 * @since 2.7.0
	 */
	exports.fromTask = exports.rightTask;
	/**
	 * @category conversions
	 * @since 2.0.0
	 */
	exports.fromEither = T.of;
	/**
	 * @category conversions
	 * @since 2.0.0
	 */
	exports.fromIOEither = T.fromIO;
	/**
	 * @category conversions
	 * @since 2.11.0
	 */
	var fromTaskOption = function (onNone) {
	    return T.map(E.fromOption(onNone));
	};
	exports.fromTaskOption = fromTaskOption;
	/**
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.match = 
	/*#__PURE__*/ ET.match(T.Functor);
	/**
	 * Less strict version of [`match`](#match).
	 *
	 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.matchW = exports.match;
	/**
	 * The `E` suffix (short for **E**ffect) means that the handlers return an effect (`Task`).
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.matchE = ET.matchE(T.Monad);
	/**
	 * Alias of [`matchE`](#matche).
	 *
	 * @category pattern matching
	 * @since 2.0.0
	 */
	exports.fold = exports.matchE;
	/**
	 * Less strict version of [`matchE`](#matche).
	 *
	 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.matchEW = exports.matchE;
	/**
	 * Alias of [`matchEW`](#matchew).
	 *
	 * @category pattern matching
	 * @since 2.10.0
	 */
	exports.foldW = exports.matchEW;
	/**
	 * @category error handling
	 * @since 2.0.0
	 */
	exports.getOrElse = 
	/*#__PURE__*/ ET.getOrElse(T.Monad);
	/**
	 * Less strict version of [`getOrElse`](#getorelse).
	 *
	 * The `W` suffix (short for **W**idening) means that the handler return type will be merged.
	 *
	 * @category error handling
	 * @since 2.6.0
	 */
	exports.getOrElseW = exports.getOrElse;
	/**
	 * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.
	 *
	 * See also [`tryCatchK`](#trycatchk).
	 *
	 * @example
	 * import { left, right } from 'fp-ts/Either'
	 * import { tryCatch } from 'fp-ts/TaskEither'
	 *
	 * tryCatch(() => Promise.resolve(1), String)().then(result => {
	 *   assert.deepStrictEqual(result, right(1))
	 * })
	 * tryCatch(() => Promise.reject('error'), String)().then(result => {
	 *   assert.deepStrictEqual(result, left('error'))
	 * })
	 *
	 * @category interop
	 * @since 2.0.0
	 */
	var tryCatch = function (f, onRejected) {
	    return function () { return __awaiter(void 0, void 0, void 0, function () {
	        var reason_1;
	        return __generator(this, function (_a) {
	            switch (_a.label) {
	                case 0:
	                    _a.trys.push([0, 2, , 3]);
	                    return [4 /*yield*/, f().then(_.right)];
	                case 1: return [2 /*return*/, _a.sent()];
	                case 2:
	                    reason_1 = _a.sent();
	                    return [2 /*return*/, _.left(onRejected(reason_1))];
	                case 3: return [2 /*return*/];
	            }
	        });
	    }); };
	};
	exports.tryCatch = tryCatch;
	/**
	 * Converts a function returning a `Promise` to one returning a `TaskEither`.
	 *
	 * @category interop
	 * @since 2.5.0
	 */
	var tryCatchK = function (f, onRejected) {
	    return function () {
	        var a = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            a[_i] = arguments[_i];
	        }
	        return (0, exports.tryCatch)(function () { return f.apply(void 0, a); }, onRejected);
	    };
	};
	exports.tryCatchK = tryCatchK;
	/**
	 * @category conversions
	 * @since 2.10.0
	 */
	exports.toUnion = ET.toUnion(T.Functor);
	/**
	 * @category conversions
	 * @since 2.12.0
	 */
	exports.fromNullable = ET.fromNullable(T.Pointed);
	/**
	 * Use `liftNullable`.
	 *
	 * @category legacy
	 * @since 2.12.0
	 */
	exports.fromNullableK = ET.fromNullableK(T.Pointed);
	/**
	 * Use `flatMapNullable`.
	 *
	 * @category legacy
	 * @since 2.12.0
	 */
	exports.chainNullableK = 
	/*#__PURE__*/ ET.chainNullableK(T.Monad);
	// -------------------------------------------------------------------------------------
	// combinators
	// -------------------------------------------------------------------------------------
	/**
	 * Returns `ma` if is a `Right` or the value returned by `onLeft` otherwise.
	 *
	 * See also [alt](#alt).
	 *
	 * @example
	 * import * as E from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 * import * as TE from 'fp-ts/TaskEither'
	 *
	 * async function test() {
	 *   const errorHandler = TE.orElse((error: string) => TE.right(`recovering from ${error}...`))
	 *   assert.deepStrictEqual(await pipe(TE.right('ok'), errorHandler)(), E.right('ok'))
	 *   assert.deepStrictEqual(await pipe(TE.left('ko'), errorHandler)(), E.right('recovering from ko...'))
	 * }
	 *
	 * test()
	 *
	 * @category error handling
	 * @since 2.0.0
	 */
	exports.orElse = 
	/*#__PURE__*/ ET.orElse(T.Monad);
	/**
	 * Less strict version of [`orElse`](#orelse).
	 *
	 * The `W` suffix (short for **W**idening) means that the return types will be merged.
	 *
	 * @category error handling
	 * @since 2.10.0
	 */
	exports.orElseW = exports.orElse;
	/**
	 * Returns an effect that effectfully "peeks" at the failure of this effect.
	 *
	 * @category error handling
	 * @since 2.15.0
	 */
	exports.tapError = (0, function_1.dual)(2, ET.tapError(T.Monad));
	/**
	 * @category error handling
	 * @since 2.12.0
	 */
	var orElseFirstIOK = function (onLeft) { return (0, exports.tapError)((0, exports.fromIOK)(onLeft)); };
	exports.orElseFirstIOK = orElseFirstIOK;
	/**
	 * @category error handling
	 * @since 2.12.0
	 */
	var orElseFirstTaskK = function (onLeft) { return (0, exports.tapError)((0, exports.fromTaskK)(onLeft)); };
	exports.orElseFirstTaskK = orElseFirstTaskK;
	/**
	 * @category error handling
	 * @since 2.11.0
	 */
	exports.orLeft = 
	/*#__PURE__*/ ET.orLeft(T.Monad);
	/**
	 * @since 2.0.0
	 */
	exports.swap = ET.swap(T.Functor);
	/**
	 * @category lifting
	 * @since 2.11.0
	 */
	var fromTaskOptionK = function (onNone) {
	    var from = (0, exports.fromTaskOption)(onNone);
	    return function (f) { return (0, function_1.flow)(f, from); };
	};
	exports.fromTaskOptionK = fromTaskOptionK;
	/**
	 * Use `flatMapTaskOption`.
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category legacy
	 * @since 2.12.3
	 */
	var chainTaskOptionKW = function (onNone) {
	    return function (f) {
	        return function (ma) {
	            return (0, exports.flatMap)(ma, (0, exports.fromTaskOptionK)(onNone)(f));
	        };
	    };
	};
	exports.chainTaskOptionKW = chainTaskOptionKW;
	/**
	 * Use `flatMapTaskOption`.
	 *
	 * @category legacy
	 * @since 2.11.0
	 */
	exports.chainTaskOptionK = exports.chainTaskOptionKW;
	/**
	 * @category lifting
	 * @since 2.4.0
	 */
	var fromIOEitherK = function (f) { return (0, function_1.flow)(f, exports.fromIOEither); };
	exports.fromIOEitherK = fromIOEitherK;
	var _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };
	var _apPar = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };
	var _apSeq = function (fab, fa) { return (0, exports.flatMap)(fab, function (f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); }); };
	/* istanbul ignore next */
	var _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };
	/**
	 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
	 * use the type constructor `F` to represent some computational context.
	 *
	 * @category mapping
	 * @since 2.0.0
	 */
	exports.map = ET.map(T.Functor);
	/**
	 * Returns a `TaskEither` whose failure and success channels have been mapped by the specified pair of functions, `f` and `g`.
	 *
	 * @example
	 * import * as TaskEither from 'fp-ts/TaskEither'
	 * import * as Either from 'fp-ts/Either'
	 *
	 * const f = (s: string) => new Error(s)
	 * const g = (n: number) => n * 2
	 *
	 * async function test() {
	 *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.right(1), f, g)(), Either.right(2))
	 *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.left('err'), f, g)(), Either.left(new Error('err')))
	 * }
	 *
	 * test()
	 *
	 * @category error handling
	 * @since 2.16.0
	 */
	exports.mapBoth = (0, function_1.dual)(3, ET.mapBoth(T.Functor));
	/**
	 * Alias of `mapBoth`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.bimap = exports.mapBoth;
	/**
	 * Returns a `TaskEither` with its error channel mapped using the specified function.
	 *
	 * @example
	 * import * as TaskEither from 'fp-ts/TaskEither'
	 * import * as Either from 'fp-ts/Either'
	 *
	 * const f = (s: string) => new Error(s)
	 *
	 * async function test() {
	 *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.right(1), f)(), Either.right(1))
	 *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.left('err'), f)(), Either.left(new Error('err')))
	 * }
	 *
	 * test()
	 *
	 * @category error handling
	 * @since 2.16.0
	 */
	exports.mapError = (0, function_1.dual)(2, ET.mapError(T.Functor));
	/**
	 * Alias of `mapError`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.mapLeft = exports.mapError;
	/**
	 * @since 2.0.0
	 */
	exports.ap = 
	/*#__PURE__*/ ET.ap(T.ApplyPar);
	/**
	 * Less strict version of [`ap`](#ap).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @since 2.8.0
	 */
	exports.apW = exports.ap;
	/**
	 * @category sequencing
	 * @since 2.14.0
	 */
	exports.flatMap = (0, function_1.dual)(2, ET.flatMap(T.Monad));
	/**
	 * Less strict version of [`flatten`](#flatten).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category sequencing
	 * @since 2.11.0
	 */
	exports.flattenW = 
	/*#__PURE__*/ (0, exports.flatMap)(function_1.identity);
	/**
	 * @category sequencing
	 * @since 2.0.0
	 */
	exports.flatten = exports.flattenW;
	/**
	 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
	 * types of kind `* -> *`.
	 *
	 * In case of `TaskEither` returns `fa` if is a `Right` or the value returned by `that` otherwise.
	 *
	 * See also [orElse](#orelse).
	 *
	 * @example
	 * import * as E from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 * import * as TE from 'fp-ts/TaskEither'
	 *
	 * async function test() {
	 *   assert.deepStrictEqual(
	 *     await pipe(
	 *       TE.right(1),
	 *       TE.alt(() => TE.right(2))
	 *     )(),
	 *     E.right(1)
	 *   )
	 *   assert.deepStrictEqual(
	 *     await pipe(
	 *       TE.left('a'),
	 *       TE.alt(() => TE.right(2))
	 *     )(),
	 *     E.right(2)
	 *   )
	 *   assert.deepStrictEqual(
	 *     await pipe(
	 *       TE.left('a'),
	 *       TE.alt(() => TE.left('b'))
	 *     )(),
	 *     E.left('b')
	 *   )
	 * }
	 *
	 * test()
	 *
	 * @category error handling
	 * @since 2.0.0
	 */
	exports.alt = 
	/*#__PURE__*/ ET.alt(T.Monad);
	/**
	 * Less strict version of [`alt`](#alt).
	 *
	 * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.
	 *
	 * @category error handling
	 * @since 2.9.0
	 */
	exports.altW = exports.alt;
	/**
	 * @category constructors
	 * @since 2.0.0
	 */
	exports.of = exports.right;
	/**
	 * @since 2.7.0
	 */
	exports.throwError = exports.left;
	/**
	 * @category type lambdas
	 * @since 2.0.0
	 */
	exports.URI = 'TaskEither';
	/**
	 * The default [`ApplicativePar`](#applicativepar) instance returns the first error, if you want to
	 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
	 *
	 * @example
	 * import * as E from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 * import * as RA from 'fp-ts/ReadonlyArray'
	 * import * as S from 'fp-ts/Semigroup'
	 * import * as string from 'fp-ts/string'
	 * import * as T from 'fp-ts/Task'
	 * import * as TE from 'fp-ts/TaskEither'
	 *
	 * interface User {
	 *   readonly id: string
	 *   readonly name: string
	 * }
	 *
	 * const remoteDatabase: ReadonlyArray<User> = [
	 *   { id: 'id1', name: 'John' },
	 *   { id: 'id2', name: 'Mary' },
	 *   { id: 'id3', name: 'Joey' }
	 * ]
	 *
	 * const fetchUser = (id: string): TE.TaskEither<string, User> =>
	 *   pipe(
	 *     remoteDatabase,
	 *     RA.findFirst((user) => user.id === id),
	 *     TE.fromOption(() => `${id} not found`)
	 *   )
	 *
	 * async function test() {
	 *   assert.deepStrictEqual(
	 *     await pipe(['id4', 'id5'], RA.traverse(TE.ApplicativePar)(fetchUser))(),
	 *     E.left('id4 not found') // <= first error
	 *   )
	 *
	 *   const Applicative = TE.getApplicativeTaskValidation(
	 *     T.ApplyPar,
	 *     pipe(string.Semigroup, S.intercalate(', '))
	 *   )
	 *
	 *   assert.deepStrictEqual(
	 *     await pipe(['id4', 'id5'], RA.traverse(Applicative)(fetchUser))(),
	 *     E.left('id4 not found, id5 not found') // <= all errors
	 *   )
	 * }
	 *
	 * test()
	 *
	 * @category error handling
	 * @since 2.7.0
	 */
	function getApplicativeTaskValidation(A, S) {
	    var ap = (0, Apply_1.ap)(A, E.getApplicativeValidation(S));
	    return {
	        URI: exports.URI,
	        _E: undefined,
	        map: _map,
	        ap: function (fab, fa) { return (0, function_1.pipe)(fab, ap(fa)); },
	        of: exports.of
	    };
	}
	exports.getApplicativeTaskValidation = getApplicativeTaskValidation;
	/**
	 * The default [`Alt`](#alt) instance returns the last error, if you want to
	 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
	 *
	 * See [`getAltValidation`](./Either.ts.html#getaltvalidation).
	 *
	 * @category error handling
	 * @since 2.7.0
	 */
	function getAltTaskValidation(S) {
	    var alt = ET.altValidation(T.Monad, S);
	    return {
	        URI: exports.URI,
	        _E: undefined,
	        map: _map,
	        alt: function (fa, that) { return (0, function_1.pipe)(fa, alt(that)); }
	    };
	}
	exports.getAltTaskValidation = getAltTaskValidation;
	/**
	 * @category filtering
	 * @since 2.10.0
	 */
	var getCompactable = function (M) {
	    var C = E.getCompactable(M);
	    return {
	        URI: exports.URI,
	        _E: undefined,
	        compact: (0, Compactable_1.compact)(T.Functor, C),
	        separate: (0, Compactable_1.separate)(T.Functor, C, E.Functor)
	    };
	};
	exports.getCompactable = getCompactable;
	/**
	 * @category filtering
	 * @since 2.1.0
	 */
	function getFilterable(M) {
	    var F = E.getFilterable(M);
	    var C = (0, exports.getCompactable)(M);
	    var filter = (0, Filterable_1.filter)(T.Functor, F);
	    var filterMap = (0, Filterable_1.filterMap)(T.Functor, F);
	    var partition = (0, Filterable_1.partition)(T.Functor, F);
	    var partitionMap = (0, Filterable_1.partitionMap)(T.Functor, F);
	    return {
	        URI: exports.URI,
	        _E: undefined,
	        map: _map,
	        compact: C.compact,
	        separate: C.separate,
	        filter: function (fa, predicate) { return (0, function_1.pipe)(fa, filter(predicate)); },
	        filterMap: function (fa, f) { return (0, function_1.pipe)(fa, filterMap(f)); },
	        partition: function (fa, predicate) { return (0, function_1.pipe)(fa, partition(predicate)); },
	        partitionMap: function (fa, f) { return (0, function_1.pipe)(fa, partitionMap(f)); }
	    };
	}
	exports.getFilterable = getFilterable;
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Functor = {
	    URI: exports.URI,
	    map: _map
	};
	/**
	 * Maps the `Right` value of this `TaskEither` to the specified constant value.
	 *
	 * @category mapping
	 * @since 2.16.0
	 */
	exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
	/**
	 * Maps the `Right` value of this `TaskEither` to the void constant value.
	 *
	 * @category mapping
	 * @since 2.16.0
	 */
	exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
	/**
	 * @category mapping
	 * @since 2.10.0
	 */
	exports.flap = (0, Functor_1.flap)(exports.Functor);
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Pointed = {
	    URI: exports.URI,
	    of: exports.of
	};
	/**
	 * Runs computations in parallel.
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	exports.ApplyPar = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apPar
	};
	/**
	 * Combine two effectful actions, keeping only the result of the first.
	 *
	 * @since 2.0.0
	 */
	exports.apFirst = (0, Apply_1.apFirst)(exports.ApplyPar);
	/**
	 * Less strict version of [`apFirst`](#apfirst).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @since 2.12.0
	 */
	exports.apFirstW = exports.apFirst;
	/**
	 * Combine two effectful actions, keeping only the result of the second.
	 *
	 * @since 2.0.0
	 */
	exports.apSecond = (0, Apply_1.apSecond)(exports.ApplyPar);
	/**
	 * Less strict version of [`apSecond`](#apsecond).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @since 2.12.0
	 */
	exports.apSecondW = exports.apSecond;
	/**
	 * Runs computations in parallel.
	 *
	 * @category instances
	 * @since 2.7.0
	 */
	exports.ApplicativePar = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apPar,
	    of: exports.of
	};
	/**
	 * Runs computations sequentially.
	 *
	 * @category instances
	 * @since 2.10.0
	 */
	exports.ApplySeq = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apSeq
	};
	/**
	 * Runs computations sequentially.
	 *
	 * @category instances
	 * @since 2.7.0
	 */
	exports.ApplicativeSeq = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apSeq,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Chain = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apPar,
	    chain: exports.flatMap
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.Monad = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apPar,
	    chain: exports.flatMap,
	    of: exports.of
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.MonadIO = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apPar,
	    chain: exports.flatMap,
	    of: exports.of,
	    fromIO: exports.fromIO
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.MonadTask = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apPar,
	    chain: exports.flatMap,
	    of: exports.of,
	    fromIO: exports.fromIO,
	    fromTask: exports.fromTask
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.MonadThrow = {
	    URI: exports.URI,
	    map: _map,
	    ap: _apPar,
	    chain: exports.flatMap,
	    of: exports.of,
	    throwError: exports.throwError
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.FromEither = {
	    URI: exports.URI,
	    fromEither: exports.fromEither
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.FromIO = {
	    URI: exports.URI,
	    fromIO: exports.fromIO
	};
	/**
	 * @category instances
	 * @since 2.10.0
	 */
	exports.FromTask = {
	    URI: exports.URI,
	    fromIO: exports.fromIO,
	    fromTask: exports.fromTask
	};
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @category combinators
	 * @since 2.15.0
	 */
	exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @example
	 * import * as E from 'fp-ts/Either'
	 * import { pipe } from 'fp-ts/function'
	 * import * as TE from 'fp-ts/TaskEither'
	 *
	 * const checkString = (value: string) => pipe(
	 *   TE.of(value),
	 *   TE.tapEither(() => value.length > 0 ? E.right('ok') : E.left('error'))
	 * )
	 *
	 * async function test() {
	 *   assert.deepStrictEqual(await checkString('')(), E.left('error'))
	 *   assert.deepStrictEqual(await checkString('fp-ts')(), E.right('fp-ts'))
	 * }
	 *
	 * test()
	 *
	 * @category combinators
	 * @since 2.16.0
	 */
	exports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @example
	 * import { pipe } from 'fp-ts/function'
	 * import * as TE from 'fp-ts/TaskEither'
	 * import * as E from 'fp-ts/Either'
	 * import * as Console from 'fp-ts/Console'
	 *
	 *
	 * // Will produce `Hello, fp-ts` to the stdout
	 * const effectA = TE.tapIO(
	 *   TE.of(1),
	 *   (value) => Console.log(`Hello, ${value}`)
	 * )
	 *
	 * // No output to the stdout
	 * const effectB = pipe(
	 *   TE.left('error'),
	 *   TE.tapIO((value) => Console.log(`Hello, ${value}`))
	 * )
	 *
	 * async function test() {
	 *   assert.deepStrictEqual(await effectA(), E.of(1))
	 *   assert.deepStrictEqual(await effectB(), E.left('error'))
	 * }
	 *
	 * test()
	 *
	 * @category combinators
	 * @since 2.16.0
	 */
	exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
	/**
	 * Composes computations in sequence, using the return value of one computation to determine the next computation and
	 * keeping only the result of the first.
	 *
	 * @example
	 * import * as TE from 'fp-ts/TaskEither'
	 * import * as T from 'fp-ts/Task'
	 * import * as E from 'fp-ts/Either'
	 *
	 *
	 * const effect = TE.tapIO(
	 *   TE.of(1),
	 *   (value) => T.of(value + 1)
	 * )
	 *
	 * async function test() {
	 *   assert.deepStrictEqual(await effect(), E.of(1))
	 * }
	 *
	 * test()
	 *
	 * @category combinators
	 * @since 2.16.0
	 */
	exports.tapTask = (0, function_1.dual)(2, (0, FromTask_1.tapTask)(exports.FromTask, exports.Chain));
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Bifunctor = {
	    URI: exports.URI,
	    bimap: exports.mapBoth,
	    mapLeft: exports.mapError
	};
	/**
	 * @category instances
	 * @since 2.7.0
	 */
	exports.Alt = {
	    URI: exports.URI,
	    map: _map,
	    alt: _alt
	};
	/**
	 * @category conversions
	 * @since 2.0.0
	 */
	exports.fromOption = 
	/*#__PURE__*/ (0, FromEither_1.fromOption)(exports.FromEither);
	/**
	 * Use `liftOption`.
	 *
	 * @category legacy
	 * @since 2.10.0
	 */
	exports.fromOptionK = 
	/*#__PURE__*/ (0, FromEither_1.fromOptionK)(exports.FromEither);
	/**
	 * Use `flatMapOption`.
	 *
	 * @category legacy
	 * @since 2.10.0
	 */
	exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
	/**
	 * Use `flatMapOption`.
	 *
	 * @category legacy
	 * @since 2.13.2
	 */
	exports.chainOptionKW = 
	 exports.chainOptionK;
	/** @internal */
	var _FromEither = {
	    fromEither: exports.FromEither.fromEither
	};
	/**
	 * @category lifting
	 * @since 2.15.0
	 */
	exports.liftNullable = _.liftNullable(_FromEither);
	/**
	 * @category lifting
	 * @since 2.15.0
	 */
	exports.liftOption = _.liftOption(_FromEither);
	/** @internal */
	var _FlatMap = {
	    flatMap: exports.flatMap
	};
	/** @internal */
	var _FromIO = {
	    fromIO: exports.FromIO.fromIO
	};
	/** @internal */
	var _FromTask = {
	    fromTask: exports.fromTask
	};
	/**
	 * @category sequencing
	 * @since 2.15.0
	 */
	exports.flatMapNullable = _.flatMapNullable(_FromEither, _FlatMap);
	/**
	 * @category sequencing
	 * @since 2.15.0
	 */
	exports.flatMapOption = _.flatMapOption(_FromEither, _FlatMap);
	/**
	 * @category sequencing
	 * @since 2.15.0
	 */
	exports.flatMapEither = _.flatMapEither(_FromEither, _FlatMap);
	/**
	 * @category sequencing
	 * @since 2.15.0
	 */
	exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
	/**
	 * @category sequencing
	 * @since 2.16.0
	 */
	exports.flatMapTask = _.flatMapTask(_FromTask, _FlatMap);
	/**
	 * @category sequencing
	 * @since 2.16.0
	 */
	exports.flatMapIOEither = (0, function_1.dual)(2, function (self, f) {
	    return (0, exports.flatMap)(self, (0, exports.fromIOEitherK)(f));
	});
	/**
	 * @category sequencing
	 * @since 2.16.0
	 */
	exports.flatMapTaskOption = (0, function_1.dual)(3, function (self, f, onNone) {
	    return (0, exports.flatMap)(self, function (a) { return (0, exports.fromTaskOption)(function () { return onNone(a); })(f(a)); });
	});
	/**
	 * Alias of `flatMapEither`.
	 *
	 * @category legacy
	 * @since 2.4.0
	 */
	exports.chainEitherK = exports.flatMapEither;
	/**
	 * Alias of `flatMapEither`.
	 *
	 * @category legacy
	 * @since 2.6.1
	 */
	exports.chainEitherKW = exports.flatMapEither;
	/**
	 * Alias of `tapEither`.
	 *
	 * @category legacy
	 * @since 2.12.0
	 */
	exports.chainFirstEitherK = exports.tapEither;
	/**
	 * Alias of `tapEither`.
	 *
	 * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category legacy
	 * @since 2.12.0
	 */
	exports.chainFirstEitherKW = exports.tapEither;
	/**
	 * @category lifting
	 * @since 2.0.0
	 */
	exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
	/**
	 * @category filtering
	 * @since 2.0.0
	 */
	exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
	/**
	 * Less strict version of [`filterOrElse`](#filterorelse).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category filtering
	 * @since 2.9.0
	 */
	exports.filterOrElseW = exports.filterOrElse;
	/**
	 * @category lifting
	 * @since 2.4.0
	 */
	exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
	/**
	 * @category lifting
	 * @since 2.10.0
	 */
	exports.fromIOK = (0, FromIO_1.fromIOK)(exports.FromIO);
	/**
	 * Alias of `flatMapIO`.
	 *
	 * @category legacy
	 * @since 2.10.0
	 */
	exports.chainIOK = exports.flatMapIO;
	/**
	 * Alias of `tapIO`.
	 *
	 * @category legacy
	 * @since 2.10.0
	 */
	exports.chainFirstIOK = exports.tapIO;
	/**
	 * @category lifting
	 * @since 2.10.0
	 */
	exports.fromTaskK = (0, FromTask_1.fromTaskK)(exports.FromTask);
	/**
	 * Alias of `flatMapTask`.
	 *
	 * @category legacy
	 * @since 2.10.0
	 */
	exports.chainTaskK = exports.flatMapTask;
	/**
	 * Alias of `tapTask`.
	 *
	 * @category legacy
	 * @since 2.10.0
	 */
	exports.chainFirstTaskK = exports.tapTask;
	/**
	 * Alias of `flatMapIOEither`.
	 *
	 * Less strict version of [`chainIOEitherK`](#chainioeitherk).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category legacy
	 * @since 2.6.1
	 */
	exports.chainIOEitherKW = exports.flatMapIOEither;
	/**
	 * Alias of `flatMapIOEither`.
	 *
	 * @category legacy
	 * @since 2.4.0
	 */
	exports.chainIOEitherK = exports.flatMapIOEither;
	function taskify(f) {
	    return function () {
	        var args = Array.prototype.slice.call(arguments);
	        return function () {
	            return new Promise(function (resolve) {
	                var cbResolver = function (e, r) { return (e != null ? resolve(_.left(e)) : resolve(_.right(r))); };
	                f.apply(null, args.concat(cbResolver));
	            });
	        };
	    };
	}
	exports.taskify = taskify;
	/**
	 * Make sure that a resource is cleaned up in the event of an exception (\*). The release action is called regardless of
	 * whether the body action throws (\*) or returns.
	 *
	 * (\*) i.e. returns a `Left`
	 *
	 * @since 2.0.0
	 */
	var bracket = function (acquire, use, release) { return (0, exports.bracketW)(acquire, use, release); };
	exports.bracket = bracket;
	/**
	 * Less strict version of [`bracket`](#bracket).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @since 2.12.0
	 */
	var bracketW = function (acquire, use, release) {
	    return (0, exports.flatMap)(acquire, function (a) { return T.flatMap(use(a), function (e) { return (0, exports.flatMap)(release(a, e), function () { return T.of(e); }); }); });
	};
	exports.bracketW = bracketW;
	// -------------------------------------------------------------------------------------
	// do notation
	// -------------------------------------------------------------------------------------
	/**
	 * @category do notation
	 * @since 2.9.0
	 */
	exports.Do = (0, exports.of)(_.emptyRecord);
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
	var let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);
	exports.let = let_;
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bind = chainable.bind(exports.Chain);
	/**
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.bindW = exports.bind;
	/**
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.apS = (0, Apply_1.apS)(exports.ApplyPar);
	/**
	 * Less strict version of [`apS`](#aps).
	 *
	 * The `W` suffix (short for **W**idening) means that the error types will be merged.
	 *
	 * @category do notation
	 * @since 2.8.0
	 */
	exports.apSW = exports.apS;
	/**
	 * @since 2.11.0
	 */
	exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
	// -------------------------------------------------------------------------------------
	// array utils
	// -------------------------------------------------------------------------------------
	/**
	 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyNonEmptyArrayWithIndex = function (f) {
	    return (0, function_1.flow)(T.traverseReadonlyNonEmptyArrayWithIndex(f), T.map(E.traverseReadonlyNonEmptyArrayWithIndex(function_1.SK)));
	};
	exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyArrayWithIndex = function (f) {
	    var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
	    return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };
	};
	exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {
	    return function (as) {
	        return function () {
	            return _.tail(as).reduce(function (acc, a, i) {
	                return acc.then(function (ebs) {
	                    return _.isLeft(ebs)
	                        ? acc
	                        : f(i + 1, a)().then(function (eb) {
	                            if (_.isLeft(eb)) {
	                                return eb;
	                            }
	                            ebs.right.push(eb.right);
	                            return ebs;
	                        });
	                });
	            }, f(0, _.head(as))().then(E.map(_.singleton)));
	        };
	    };
	};
	exports.traverseReadonlyNonEmptyArrayWithIndexSeq = traverseReadonlyNonEmptyArrayWithIndexSeq;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
	 *
	 * @category traversing
	 * @since 2.11.0
	 */
	var traverseReadonlyArrayWithIndexSeq = function (f) {
	    var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndexSeq)(f);
	    return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };
	};
	exports.traverseReadonlyArrayWithIndexSeq = traverseReadonlyArrayWithIndexSeq;
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
	/**
	 * Equivalent to `ReadonlyArray#traverse(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	var traverseArray = function (f) { return (0, exports.traverseReadonlyArrayWithIndex)(function (_, a) { return f(a); }); };
	exports.traverseArray = traverseArray;
	/**
	 * Equivalent to `ReadonlyArray#sequence(Applicative)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.sequenceArray = 
	/*#__PURE__*/ (0, exports.traverseArray)(function_1.identity);
	/**
	 * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.traverseSeqArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq;
	/**
	 * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	var traverseSeqArray = function (f) { return (0, exports.traverseReadonlyArrayWithIndexSeq)(function (_, a) { return f(a); }); };
	exports.traverseSeqArray = traverseSeqArray;
	/**
	 * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.
	 *
	 * @category traversing
	 * @since 2.9.0
	 */
	exports.sequenceSeqArray = 
	/*#__PURE__*/ (0, exports.traverseSeqArray)(function_1.identity);
	// -------------------------------------------------------------------------------------
	// legacy
	// -------------------------------------------------------------------------------------
	/**
	 * Alias of `flatMap`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.chain = exports.flatMap;
	/**
	 * Alias of `flatMap`.
	 *
	 * @category legacy
	 * @since 2.6.0
	 */
	exports.chainW = exports.flatMap;
	/**
	 * Alias of `tap`.
	 *
	 * @category legacy
	 * @since 2.0.0
	 */
	exports.chainFirst = exports.tap;
	/**
	 * Alias of `tap`.
	 *
	 * @category legacy
	 * @since 2.8.0
	 */
	exports.chainFirstW = exports.tap;
	/**
	 * Alias of `tapError`.
	 *
	 * @category legacy
	 * @since 2.11.0
	 */
	exports.orElseFirst = exports.tapError;
	/**
	 * Alias of `tapError`.
	 *
	 * @category legacy
	 * @since 2.11.0
	 */
	exports.orElseFirstW = exports.tapError;
	// -------------------------------------------------------------------------------------
	// deprecated
	// -------------------------------------------------------------------------------------
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEither`
	 * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.taskEither = {
	    URI: exports.URI,
	    bimap: exports.mapBoth,
	    mapLeft: exports.mapError,
	    map: _map,
	    of: exports.of,
	    ap: _apPar,
	    chain: exports.flatMap,
	    alt: _alt,
	    fromIO: exports.fromIO,
	    fromTask: exports.fromTask,
	    throwError: exports.throwError
	};
	/**
	 * This instance is deprecated, use small, specific instances instead.
	 * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEitherSeq`
	 * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.taskEitherSeq = {
	    URI: exports.URI,
	    bimap: exports.mapBoth,
	    mapLeft: exports.mapError,
	    map: _map,
	    of: exports.of,
	    ap: _apSeq,
	    chain: exports.flatMap,
	    alt: _alt,
	    fromIO: exports.fromIO,
	    fromTask: exports.fromTask,
	    throwError: exports.throwError
	};
	/**
	 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getApplySemigroup = 
	/*#__PURE__*/ (0, Apply_1.getApplySemigroup)(exports.ApplySeq);
	/**
	 * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	exports.getApplyMonoid = 
	/*#__PURE__*/ (0, Applicative_1.getApplicativeMonoid)(exports.ApplicativeSeq);
	/**
	 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	var getSemigroup = function (S) {
	    return (0, Apply_1.getApplySemigroup)(T.ApplySeq)(E.getSemigroup(S));
	};
	exports.getSemigroup = getSemigroup;
	/**
	 * Use [`getApplicativeTaskValidation`](#getapplicativetaskvalidation) and [`getAltTaskValidation`](#getalttaskvalidation) instead.
	 *
	 * @category zone of death
	 * @since 2.0.0
	 * @deprecated
	 */
	function getTaskValidation(SE) {
	    var applicativeTaskValidation = getApplicativeTaskValidation(T.ApplicativePar, SE);
	    var altTaskValidation = getAltTaskValidation(SE);
	    return {
	        URI: exports.URI,
	        _E: undefined,
	        map: _map,
	        ap: applicativeTaskValidation.ap,
	        of: exports.of,
	        chain: exports.flatMap,
	        bimap: exports.mapBoth,
	        mapLeft: exports.mapError,
	        alt: altTaskValidation.alt,
	        fromIO: exports.fromIO,
	        fromTask: exports.fromTask,
	        throwError: exports.throwError
	    };
	}
	exports.getTaskValidation = getTaskValidation; 
} (TaskEither));

const log = (message) => console.log(`\t## - ${message}`);
// TODO: This is a pure datatype, convert to type alias or interface
class Context {
    constructor(projectId, blockfrostUrl, network) {
        this.projectId = projectId;
        this.network = network;
        this.blockfrostUrl = blockfrostUrl;
    }
}
// [[testing-wallet-discussion]]
// DISCUSSION: Currently this class is more of a testing helper rather than being a NodeJS
//             implementation of the WalletAPI. It has extra methods for funding a wallet
//             and minting test tokens and it is missing some required methods like getUTxOs.
//
//             If we want to support a NodeJS implementation of the WalletAPI we should
//             probably remove the extra methods and find a way to share the Blockfrost
//             (or eventual underlying service) for testing.
//
//             It we don't want to support a NodeJS library for the moment, then this could
//             be moved to a @marlowe.io/runtime-xxx package, as it is not helping test the
//             wallet, but the runtime.
/**
 * @hidden
 */
class SingleAddressWallet {
    constructor(context, privateKeyBech32) {
        this.tokenBalance = (assetId) => _function.pipe(TaskEither.tryCatch(() => this.blockfrostApi.addresses(unAddressBech32(this.address)), (reason) => new Error(`Error while retrieving assetBalance : ${reason}`)), TaskEither.map((content) => _function.pipe(content.amount ?? [], _Array.filter((amount) => amount.unit ===
            toUnit(unPolicyId(assetId.policyId), fromText(assetId.assetName))), _Array.map((amount) => BigInt(amount.quantity)), _Array.head, Option.getOrElse(() => 0n))));
        // see [[testing-wallet-discussion]]
        this.provision = (provisionning) => _function.pipe(provisionning, _Array.reduce(this.lucid.newTx(), (tx, account) => tx.payToAddress(unAddressBech32(account[0].address), {
            lovelace: account[1],
        })), build, TaskEither.chain(this.signSubmitAndWaitConfirmation));
        this.sign = (txBuilt) => TaskEither.tryCatch(() => txBuilt.sign().complete(), (reason) => new Error(`Error while signing : ${reason}`));
        this.submit = (signedTx) => TaskEither.tryCatch(() => signedTx.submit(), (reason) => new Error(`Error while submitting : ${reason}`));
        // see [[testing-wallet-discussion]]
        this.signSubmitAndWaitConfirmation = (txBuilt) => _function.pipe(this.sign(txBuilt), TaskEither.chain(this.submit), TaskEither.chainFirst((txHash) => TaskEither.of(log(`<> Tx ${txHash} submitted.`))), TaskEither.chain((txHash) => TaskEither.tryCatch(() => this.waitConfirmation(txHash), (reason) => new Error(`Error while retrieving assetBalance : ${reason}`))));
        // FIXME: Implement
        // see [[testing-wallet-discussion]]
        this.getUTxOs = Task.of([]);
        this.privateKeyBech32 = privateKeyBech32;
        this.context = context;
        this.blockfrostApi = new lib$1.BlockFrostAPI({
            projectId: context.projectId,
        });
    }
    // TODO: Extract this to its own function
    static async Initialise(context, privateKeyBech32) {
        const account = new SingleAddressWallet(context, privateKeyBech32);
        await account.initialise();
        return account;
    }
    // TODO: Extract this to its own function
    static async Random(context) {
        const privateKey = C.PrivateKey.generate_ed25519().to_bech32();
        const account = new SingleAddressWallet(context, privateKey);
        await account.initialise();
        return account;
    }
    async initialise() {
        this.lucid = await Lucid.new(new Blockfrost(this.context.blockfrostUrl, this.context.projectId), this.context.network);
        this.lucid.selectWalletFromPrivateKey(this.privateKeyBech32);
        this.address = addressBech32(await this.lucid.wallet.address());
        this.getChangeAddress = Task.of(this.address);
        this.getUsedAddresses = Task.of([this.address]);
        this.getCollaterals = Task.of([]);
    }
    async getCIP30Network() {
        if (this.lucid.network === "Mainnet") {
            return "Mainnet";
        }
        else {
            return "Testnets";
        }
    }
    async getTokens() {
        try {
            const content = await this.blockfrostApi.addresses(unAddressBech32(this.address));
            return _function.pipe(content.amount ?? [], _Array.map((tokenBlockfrost) => tokenBlockfrost.unit === "lovelace"
                ? lovelaces(BigInt(tokenBlockfrost.quantity))
                : token(BigInt(tokenBlockfrost.quantity).valueOf())(assetId(mkPolicyId(fromUnit(tokenBlockfrost.unit).policyId))(getAssetName(tokenBlockfrost.unit)))));
        }
        catch (reason) {
            throw new Error(`Error while retrieving assetBalance : ${reason}`);
        }
    }
    async getLovelaces() {
        try {
            const content = await this.blockfrostApi.addresses(unAddressBech32(this.address));
            return _function.pipe(content.amount ?? [], _Array.filter((amount) => amount.unit === "lovelace"), _Array.map((amount) => BigInt(amount.quantity)), _Array.head, Option.getOrElse(() => 0n));
        }
        catch (reason) {
            throw new Error(`Error while retrieving assetBalance : ${reason}`);
        }
    }
    // see [[testing-wallet-discussion]]
    randomPolicyId() {
        const { paymentCredential } = getAddressDetails(unAddressBech32(this.address));
        const before = this.lucid.currentSlot() + 5 * 60;
        const json = {
            type: "all",
            scripts: [
                {
                    type: "before",
                    slot: before.valueOf(),
                },
                { type: "sig", keyHash: paymentCredential?.hash },
            ],
        };
        const script = this.lucid.utils.nativeScriptFromJson(json);
        const policyId = this.lucid.utils.mintingPolicyToId(script);
        return [script, policyId];
    }
    // see [[testing-wallet-discussion]]
    mintRandomTokens(assetName, amount) {
        const policyRefs = this.randomPolicyId();
        const [mintingPolicy, policyId] = policyRefs;
        return unsafeTaskEither(_function.pipe(this.lucid
            .newTx()
            .mintAssets({
            [toUnit(policyId, fromText(assetName))]: amount.valueOf(),
        })
            .validTo(Date.now() + 100000)
            .attachMintingPolicy(mintingPolicy), build, TaskEither.chain(this.signSubmitAndWaitConfirmation), TaskEither.map(() => token(amount)(assetId(mkPolicyId(policyRefs[1]))(assetName)))));
    }
    async signTxTheCIP30Way(cborHex) {
        const tx = C.Transaction.from_bytes(fromHex(cborHex));
        try {
            const txSigned = await this.lucid.wallet.signTx(tx);
            return toHex$2(txSigned.to_bytes());
        }
        catch (reason) {
            throw new Error(`Error while signing : ${reason}`);
        }
    }
    waitConfirmation(txHash) {
        try {
            return this.lucid.awaitTx(txHash);
        }
        catch (reason) {
            throw new Error(`Error while awiting : ${reason}`);
        }
    }
}
const build = (tx) => TaskEither.tryCatch(() => tx.complete(), (reason) => new Error(`Error while building Tx : ${reason}`));
const getAssetName = (unit) => {
    const assetName = fromUnit(unit).assetName;
    return assetName ? hexToUTF8_1(assetName) : "";
};
/**
 * Currently used for testing
 * see [[testing-wallet-discussion]]
 * @hidden
 */
const getPrivateKeyFromHexString = (privateKeyHex) => C.PrivateKey.from_bytes(Buffer.from(privateKeyHex, "hex")).to_bech32();

export { Context, SingleAddressWallet, getPrivateKeyFromHexString };
